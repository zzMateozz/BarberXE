{"version":3,"sources":["../../src/metadata/ColumnMetadata.ts"],"names":[],"mappings":"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","file":"ColumnMetadata.js","sourcesContent":["import { ColumnType } from \"../driver/types/ColumnTypes\"\r\nimport { EntityMetadata } from \"./EntityMetadata\"\r\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\r\nimport { RelationMetadata } from \"./RelationMetadata\"\r\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { ColumnMetadataArgs } from \"../metadata-args/ColumnMetadataArgs\"\r\nimport { DataSource } from \"../data-source/DataSource\"\r\nimport { OrmUtils } from \"../util/OrmUtils\"\r\nimport { ValueTransformer } from \"../decorator/options/ValueTransformer\"\r\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { VirtualColumnOptions } from \"../decorator/options/VirtualColumnOptions\"\r\n\r\n/**\r\n * This metadata contains all information about entity's column.\r\n */\r\nexport class ColumnMetadata {\r\n    readonly \"@instanceof\" = Symbol.for(\"ColumnMetadata\")\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Target class where column decorator is used.\r\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\r\n     */\r\n    target: Function | string\r\n\r\n    /**\r\n     * Entity metadata where this column metadata is.\r\n     *\r\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\r\n     */\r\n    entityMetadata: EntityMetadata\r\n\r\n    /**\r\n     * Embedded metadata where this column metadata is.\r\n     * If this column is not in embed then this property value is undefined.\r\n     */\r\n    embeddedMetadata?: EmbeddedMetadata\r\n\r\n    /**\r\n     * If column is a foreign key of some relation then this relation's metadata will be there.\r\n     * If this column does not have a foreign key then this property value is undefined.\r\n     */\r\n    relationMetadata?: RelationMetadata\r\n\r\n    /**\r\n     * Class's property name on which this column is applied.\r\n     */\r\n    propertyName: string\r\n\r\n    /**\r\n     * The database type of the column.\r\n     */\r\n    type: ColumnType\r\n\r\n    /**\r\n     * Type's length in the database.\r\n     */\r\n    length: string = \"\"\r\n\r\n    /**\r\n     * Type's display width in the database.\r\n     */\r\n    width?: number\r\n\r\n    /**\r\n     * Defines column character set.\r\n     */\r\n    charset?: string\r\n\r\n    /**\r\n     * Defines column collation.\r\n     */\r\n    collation?: string\r\n\r\n    /**\r\n     * Indicates if this column is a primary key.\r\n     */\r\n    isPrimary: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column is generated (auto increment or generated other way).\r\n     */\r\n    isGenerated: boolean = false\r\n\r\n    /**\r\n     * Indicates if column can contain nulls or not.\r\n     */\r\n    isNullable: boolean = false\r\n\r\n    /**\r\n     * Indicates if column is selected by query builder or not.\r\n     */\r\n    isSelect: boolean = true\r\n\r\n    /**\r\n     * Indicates if column is inserted by default or not.\r\n     */\r\n    isInsert: boolean = true\r\n\r\n    /**\r\n     * Indicates if column allows updates or not.\r\n     */\r\n    isUpdate: boolean = true\r\n\r\n    /**\r\n     * Specifies generation strategy if this column will use auto increment.\r\n     */\r\n    generationStrategy?: \"uuid\" | \"increment\" | \"rowid\"\r\n\r\n    /**\r\n     * Identity column type. Supports only in Postgres 10+.\r\n     */\r\n    generatedIdentity?: \"ALWAYS\" | \"BY DEFAULT\"\r\n\r\n    /**\r\n     * Column comment.\r\n     * This feature is not supported by all databases.\r\n     */\r\n    comment?: string\r\n\r\n    /**\r\n     * Default database value.\r\n     */\r\n    default?:\r\n        | number\r\n        | boolean\r\n        | string\r\n        | null\r\n        | (number | boolean | string)[]\r\n        | Record<string, object>\r\n        | (() => string)\r\n\r\n    /**\r\n     * ON UPDATE trigger. Works only for MySQL.\r\n     */\r\n    onUpdate?: string\r\n\r\n    /**\r\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\r\n     * which is the maximum number of digits that are stored for the values.\r\n     */\r\n    precision?: number | null\r\n\r\n    /**\r\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\r\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\r\n     */\r\n    scale?: number\r\n\r\n    /**\r\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\r\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\r\n     */\r\n    zerofill: boolean = false\r\n\r\n    /**\r\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\r\n     */\r\n    unsigned: boolean = false\r\n\r\n    /**\r\n     * Array of possible enumerated values.\r\n     *\r\n     * `postgres` and `mysql` store enum values as strings but we want to keep support\r\n     * for numeric and heterogeneous based typescript enums, so we need (string|number)[]\r\n     */\r\n    enum?: (string | number)[]\r\n\r\n    /**\r\n     * Exact name of enum\r\n     */\r\n    enumName?: string\r\n\r\n    /**\r\n     * Generated column expression.\r\n     */\r\n    asExpression?: string\r\n\r\n    /**\r\n     * Generated column type.\r\n     */\r\n    generatedType?: \"VIRTUAL\" | \"STORED\"\r\n\r\n    /**\r\n     * Return type of HSTORE column.\r\n     * Returns value as string or as object.\r\n     */\r\n    hstoreType?: \"object\" | \"string\"\r\n\r\n    /**\r\n     * Indicates if this column is an array.\r\n     */\r\n    isArray: boolean = false\r\n\r\n    /**\r\n     * Gets full path to this column property (including column property name).\r\n     * Full path is relevant when column is used in embeds (one or multiple nested).\r\n     * For example it will return \"counters.subcounters.likes\".\r\n     * If property is not in embeds then it returns just property name of the column.\r\n     */\r\n    propertyPath: string\r\n\r\n    /**\r\n     * Same as property path, but dots are replaced with '_'.\r\n     * Used in query builder statements.\r\n     */\r\n    propertyAliasName: string\r\n\r\n    /**\r\n     * Gets full path to this column database name (including column database name).\r\n     * Full path is relevant when column is used in embeds (one or multiple nested).\r\n     * For example it will return \"counters.subcounters.likes\".\r\n     * If property is not in embeds then it returns just database name of the column.\r\n     */\r\n    databasePath: string\r\n\r\n    /**\r\n     * Complete column name in the database including its embedded prefixes.\r\n     */\r\n    databaseName: string\r\n\r\n    /**\r\n     * Database name in the database without embedded prefixes applied.\r\n     */\r\n    databaseNameWithoutPrefixes: string\r\n\r\n    /**\r\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\r\n     */\r\n    givenDatabaseName?: string\r\n\r\n    /**\r\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\r\n     */\r\n    isVirtual: boolean = false\r\n\r\n    /**\r\n     * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\r\n     * This property is used in tandem the virtual column decorator.\r\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\r\n     */\r\n    isVirtualProperty: boolean = false\r\n\r\n    /**\r\n     * Query to be used to populate the column data. This query is used when generating the relational db script.\r\n     * The query function is called with the current entities alias either defined by the Entity Decorator or automatically\r\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\r\n     */\r\n    query?: (alias: string) => string\r\n\r\n    /**\r\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\r\n     */\r\n    isDiscriminator: boolean = false\r\n\r\n    /**\r\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\r\n     */\r\n    isTreeLevel: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column contains an entity creation date.\r\n     */\r\n    isCreateDate: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column contains an entity update date.\r\n     */\r\n    isUpdateDate: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column contains an entity delete date.\r\n     */\r\n    isDeleteDate: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column contains an entity version.\r\n     */\r\n    isVersion: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column contains an object id.\r\n     */\r\n    isObjectId: boolean = false\r\n\r\n    /**\r\n     * If this column is foreign key then it references some other column,\r\n     * and this property will contain reference to this column.\r\n     */\r\n    referencedColumn: ColumnMetadata | undefined\r\n\r\n    /**\r\n     * If this column is primary key then this specifies the name for it.\r\n     */\r\n    primaryKeyConstraintName?: string\r\n\r\n    /**\r\n     * If this column is foreign key then this specifies the name for it.\r\n     */\r\n    foreignKeyConstraintName?: string\r\n\r\n    /**\r\n     * Specifies a value transformer that is to be used to (un)marshal\r\n     * this column when reading or writing to the database.\r\n     */\r\n    transformer?: ValueTransformer | ValueTransformer[]\r\n\r\n    /**\r\n     * Column type in the case if this column is in the closure table.\r\n     * Column can be ancestor or descendant in the closure tables.\r\n     */\r\n    closureType?: \"ancestor\" | \"descendant\"\r\n\r\n    /**\r\n     * Indicates if this column is nested set's left column.\r\n     * Used only in tree entities with nested-set type.\r\n     */\r\n    isNestedSetLeft: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column is nested set's right column.\r\n     * Used only in tree entities with nested-set type.\r\n     */\r\n    isNestedSetRight: boolean = false\r\n\r\n    /**\r\n     * Indicates if this column is materialized path's path column.\r\n     * Used only in tree entities with materialized path type.\r\n     */\r\n    isMaterializedPath: boolean = false\r\n\r\n    /**\r\n     * Spatial Feature Type (Geometry, Point, Polygon, etc.)\r\n     */\r\n    spatialFeatureType?: string\r\n\r\n    /**\r\n     * SRID (Spatial Reference ID (EPSG code))\r\n     */\r\n    srid?: number\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(options: {\r\n        connection: DataSource\r\n        entityMetadata: EntityMetadata\r\n        embeddedMetadata?: EmbeddedMetadata\r\n        referencedColumn?: ColumnMetadata\r\n        args: ColumnMetadataArgs\r\n        closureType?: \"ancestor\" | \"descendant\"\r\n        nestedSetLeft?: boolean\r\n        nestedSetRight?: boolean\r\n        materializedPath?: boolean\r\n    }) {\r\n        this.entityMetadata = options.entityMetadata\r\n        this.embeddedMetadata = options.embeddedMetadata!\r\n        this.referencedColumn = options.referencedColumn\r\n        if (options.args.target) this.target = options.args.target\r\n        if (options.args.propertyName)\r\n            this.propertyName = options.args.propertyName\r\n        if (options.args.options.name)\r\n            this.givenDatabaseName = options.args.options.name\r\n        if (options.args.options.type) this.type = options.args.options.type\r\n        if (options.args.options.length)\r\n            this.length = options.args.options.length\r\n                ? options.args.options.length.toString()\r\n                : \"\"\r\n        if (options.args.options.width) this.width = options.args.options.width\r\n        if (options.args.options.charset)\r\n            this.charset = options.args.options.charset\r\n        if (options.args.options.collation)\r\n            this.collation = options.args.options.collation\r\n        if (options.args.options.primary)\r\n            this.isPrimary = options.args.options.primary\r\n        if (options.args.options.default === null)\r\n            // to make sure default: null is the same as nullable: true\r\n            this.isNullable = true\r\n        if (options.args.options.nullable !== undefined)\r\n            this.isNullable = options.args.options.nullable\r\n        if (options.args.options.select !== undefined)\r\n            this.isSelect = options.args.options.select\r\n        if (options.args.options.insert !== undefined)\r\n            this.isInsert = options.args.options.insert\r\n        if (options.args.options.update !== undefined)\r\n            this.isUpdate = options.args.options.update\r\n        if (options.args.options.readonly !== undefined)\r\n            this.isUpdate = !options.args.options.readonly\r\n        if (options.args.options.comment)\r\n            this.comment = options.args.options.comment\r\n        if (options.args.options.default !== undefined)\r\n            this.default = options.args.options.default\r\n        if (options.args.options.onUpdate)\r\n            this.onUpdate = options.args.options.onUpdate\r\n        if (options.args.options.generatedIdentity)\r\n            this.generatedIdentity = options.args.options.generatedIdentity\r\n        if (\r\n            options.args.options.scale !== null &&\r\n            options.args.options.scale !== undefined\r\n        )\r\n            this.scale = options.args.options.scale\r\n        if (options.args.options.zerofill) {\r\n            this.zerofill = options.args.options.zerofill\r\n            this.unsigned = true // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\r\n        }\r\n        if (options.args.options.unsigned)\r\n            this.unsigned = options.args.options.unsigned\r\n        if (options.args.options.precision !== null)\r\n            this.precision = options.args.options.precision\r\n        if (options.args.options.enum) {\r\n            if (\r\n                ObjectUtils.isObject(options.args.options.enum) &&\r\n                !Array.isArray(options.args.options.enum)\r\n            ) {\r\n                this.enum = Object.keys(options.args.options.enum)\r\n                    // remove numeric keys - typescript numeric enum types generate them\r\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\r\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\r\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\r\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\r\n                    // generated SQL statements contains string representation of that function which leads into syntax error\r\n                    // at database side.\r\n                    .filter(\r\n                        (key) =>\r\n                            isNaN(+key) &&\r\n                            typeof (options.args.options.enum as ObjectLiteral)[\r\n                                key\r\n                            ] !== \"function\",\r\n                    )\r\n                    .map(\r\n                        (key) =>\r\n                            (options.args.options.enum as ObjectLiteral)[key],\r\n                    )\r\n            } else {\r\n                this.enum = options.args.options.enum\r\n            }\r\n        }\r\n        if (options.args.options.enumName) {\r\n            this.enumName = options.args.options.enumName\r\n        }\r\n        if (options.args.options.primaryKeyConstraintName) {\r\n            this.primaryKeyConstraintName =\r\n                options.args.options.primaryKeyConstraintName\r\n        }\r\n        if (options.args.options.foreignKeyConstraintName) {\r\n            this.foreignKeyConstraintName =\r\n                options.args.options.foreignKeyConstraintName\r\n        }\r\n        if (options.args.options.asExpression) {\r\n            this.asExpression = options.args.options.asExpression\r\n            this.generatedType = options.args.options.generatedType\r\n                ? options.args.options.generatedType\r\n                : \"VIRTUAL\"\r\n        }\r\n        if (options.args.options.hstoreType)\r\n            this.hstoreType = options.args.options.hstoreType\r\n        if (options.args.options.array)\r\n            this.isArray = options.args.options.array\r\n        if (options.args.mode) {\r\n            this.isVirtualProperty = options.args.mode === \"virtual-property\"\r\n            this.isVirtual = options.args.mode === \"virtual\"\r\n            this.isTreeLevel = options.args.mode === \"treeLevel\"\r\n            this.isCreateDate = options.args.mode === \"createDate\"\r\n            this.isUpdateDate = options.args.mode === \"updateDate\"\r\n            this.isDeleteDate = options.args.mode === \"deleteDate\"\r\n            this.isVersion = options.args.mode === \"version\"\r\n            this.isObjectId = options.args.mode === \"objectId\"\r\n        }\r\n        if (this.isVirtualProperty) {\r\n            this.isInsert = false\r\n            this.isUpdate = false\r\n        }\r\n        if (options.args.options.transformer)\r\n            this.transformer = options.args.options.transformer\r\n        if (options.args.options.spatialFeatureType)\r\n            this.spatialFeatureType = options.args.options.spatialFeatureType\r\n        if (options.args.options.srid !== undefined)\r\n            this.srid = options.args.options.srid\r\n        if ((options.args.options as VirtualColumnOptions).query)\r\n            this.query = (options.args.options as VirtualColumnOptions).query\r\n        if (this.isTreeLevel)\r\n            this.type = options.connection.driver.mappedDataTypes.treeLevel\r\n        if (this.isCreateDate) {\r\n            if (!this.type)\r\n                this.type = options.connection.driver.mappedDataTypes.createDate\r\n            if (!this.default)\r\n                this.default = () =>\r\n                    options.connection.driver.mappedDataTypes.createDateDefault\r\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\r\n            if (\r\n                this.precision === undefined &&\r\n                options.args.options.precision === undefined &&\r\n                options.connection.driver.mappedDataTypes.createDatePrecision\r\n            )\r\n                this.precision =\r\n                    options.connection.driver.mappedDataTypes.createDatePrecision\r\n        }\r\n        if (this.isUpdateDate) {\r\n            if (!this.type)\r\n                this.type = options.connection.driver.mappedDataTypes.updateDate\r\n            if (!this.default)\r\n                this.default = () =>\r\n                    options.connection.driver.mappedDataTypes.updateDateDefault\r\n            if (!this.onUpdate)\r\n                this.onUpdate =\r\n                    options.connection.driver.mappedDataTypes.updateDateDefault\r\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\r\n            if (\r\n                this.precision === undefined &&\r\n                options.args.options.precision === undefined &&\r\n                options.connection.driver.mappedDataTypes.updateDatePrecision\r\n            )\r\n                this.precision =\r\n                    options.connection.driver.mappedDataTypes.updateDatePrecision\r\n        }\r\n        if (this.isDeleteDate) {\r\n            if (!this.type)\r\n                this.type = options.connection.driver.mappedDataTypes.deleteDate\r\n            if (!this.isNullable)\r\n                this.isNullable =\r\n                    options.connection.driver.mappedDataTypes.deleteDateNullable\r\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\r\n            if (\r\n                this.precision === undefined &&\r\n                options.args.options.precision === undefined &&\r\n                options.connection.driver.mappedDataTypes.deleteDatePrecision\r\n            )\r\n                this.precision =\r\n                    options.connection.driver.mappedDataTypes.deleteDatePrecision\r\n        }\r\n        if (this.isVersion)\r\n            this.type = options.connection.driver.mappedDataTypes.version\r\n        if (options.closureType) this.closureType = options.closureType\r\n        if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft\r\n        if (options.nestedSetRight)\r\n            this.isNestedSetRight = options.nestedSetRight\r\n        if (options.materializedPath)\r\n            this.isMaterializedPath = options.materializedPath\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates entity id map from the given entity ids array.\r\n     */\r\n    createValueMap(value: any, useDatabaseName = false) {\r\n        // extract column value from embeds of entity if column is in embedded\r\n        if (this.embeddedMetadata) {\r\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\r\n            // we need to get value of \"id\" column from the post real entity object and return it in a\r\n            // { data: { information: { counters: { id: ... } } } } format\r\n\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\r\n\r\n            // now need to access post[data][information][counters] to get column value from the counters\r\n            // and on each step we need to create complex literal object, e.g. first { data },\r\n            // then { data: { information } }, then { data: { information: { counters } } },\r\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\r\n            // this recursive function helps doing that\r\n            const extractEmbeddedColumnValue = (\r\n                propertyNames: string[],\r\n                map: ObjectLiteral,\r\n            ): any => {\r\n                const propertyName = propertyNames.shift()\r\n                if (propertyName) {\r\n                    map[propertyName] = {}\r\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName])\r\n                    return map\r\n                }\r\n\r\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\r\n                if (\r\n                    (this.generationStrategy === \"increment\" ||\r\n                        this.generationStrategy === \"rowid\") &&\r\n                    this.type === \"bigint\" &&\r\n                    value !== null\r\n                )\r\n                    value = String(value)\r\n\r\n                map[useDatabaseName ? this.databaseName : this.propertyName] =\r\n                    value\r\n                return map\r\n            }\r\n            return extractEmbeddedColumnValue(propertyNames, {})\r\n        } else {\r\n            // no embeds - no problems. Simply return column property name and its value of the entity\r\n\r\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\r\n            if (\r\n                (this.generationStrategy === \"increment\" ||\r\n                    this.generationStrategy === \"rowid\") &&\r\n                this.type === \"bigint\" &&\r\n                value !== null\r\n            )\r\n                value = String(value)\r\n\r\n            return {\r\n                [useDatabaseName ? this.databaseName : this.propertyName]:\r\n                    value,\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extracts column value and returns its column name with this value in a literal object.\r\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\r\n     *\r\n     * Examples what this method can return depend if this column is in embeds.\r\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\r\n     */\r\n    getEntityValueMap(\r\n        entity: ObjectLiteral,\r\n        options?: { skipNulls?: boolean },\r\n    ): ObjectLiteral | undefined {\r\n        const returnNulls = false // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\r\n\r\n        // extract column value from embeds of entity if column is in embedded\r\n        if (this.embeddedMetadata) {\r\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\r\n            // we need to get value of \"id\" column from the post real entity object and return it in a\r\n            // { data: { information: { counters: { id: ... } } } } format\r\n\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\r\n            const isEmbeddedArray = this.embeddedMetadata.isArray\r\n\r\n            // now need to access post[data][information][counters] to get column value from the counters\r\n            // and on each step we need to create complex literal object, e.g. first { data },\r\n            // then { data: { information } }, then { data: { information: { counters } } },\r\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\r\n            // this recursive function helps doing that\r\n            const extractEmbeddedColumnValue = (\r\n                propertyNames: string[],\r\n                value: ObjectLiteral,\r\n            ): ObjectLiteral => {\r\n                if (value === undefined) {\r\n                    return {}\r\n                }\r\n\r\n                const propertyName = propertyNames.shift()\r\n\r\n                if (propertyName) {\r\n                    const submap = extractEmbeddedColumnValue(\r\n                        propertyNames,\r\n                        value[propertyName],\r\n                    )\r\n                    if (Object.keys(submap).length > 0) {\r\n                        return { [propertyName]: submap }\r\n                    }\r\n                    return {}\r\n                }\r\n\r\n                if (isEmbeddedArray && Array.isArray(value)) {\r\n                    return value.map((v) => ({\r\n                        [this.propertyName]: v[this.propertyName],\r\n                    }))\r\n                }\r\n\r\n                if (\r\n                    value[this.propertyName] !== undefined &&\r\n                    (returnNulls === false || value[this.propertyName] !== null)\r\n                ) {\r\n                    return { [this.propertyName]: value[this.propertyName] }\r\n                }\r\n\r\n                return {}\r\n            }\r\n            const map = extractEmbeddedColumnValue(propertyNames, entity)\r\n\r\n            return Object.keys(map).length > 0 ? map : undefined\r\n        } else {\r\n            // no embeds - no problems. Simply return column property name and its value of the entity\r\n            /**\r\n             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\r\n             * DO NOT use `entity[\r\n                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\r\n             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\r\n             */\r\n            if (\r\n                this.relationMetadata &&\r\n                !Object.getOwnPropertyDescriptor(\r\n                    entity,\r\n                    this.relationMetadata.propertyName,\r\n                )?.get &&\r\n                entity[this.relationMetadata.propertyName] &&\r\n                ObjectUtils.isObject(entity[this.relationMetadata.propertyName])\r\n            ) {\r\n                if (this.relationMetadata.joinColumns.length > 1) {\r\n                    const map = this.relationMetadata.joinColumns.reduce(\r\n                        (map, joinColumn) => {\r\n                            const value =\r\n                                joinColumn.referencedColumn!.getEntityValueMap(\r\n                                    entity[this.relationMetadata!.propertyName],\r\n                                )\r\n                            if (value === undefined) return map\r\n                            return OrmUtils.mergeDeep(map, value)\r\n                        },\r\n                        {},\r\n                    )\r\n                    if (Object.keys(map).length > 0)\r\n                        return { [this.propertyName]: map }\r\n                } else {\r\n                    const value =\r\n                        this.relationMetadata.joinColumns[0].referencedColumn!.getEntityValue(\r\n                            entity[this.relationMetadata!.propertyName],\r\n                        )\r\n                    if (value) {\r\n                        return { [this.propertyName]: value }\r\n                    }\r\n                }\r\n\r\n                return undefined\r\n            } else {\r\n                if (\r\n                    entity[this.propertyName] !== undefined &&\r\n                    (returnNulls === false ||\r\n                        entity[this.propertyName] !== null)\r\n                ) {\r\n                    return { [this.propertyName]: entity[this.propertyName] }\r\n                }\r\n\r\n                return undefined\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extracts column value from the given entity.\r\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\r\n     */\r\n    getEntityValue(\r\n        entity: ObjectLiteral,\r\n        transform: boolean = false,\r\n    ): any | undefined {\r\n        if (entity === undefined || entity === null) return undefined\r\n\r\n        // extract column value from embeddeds of entity if column is in embedded\r\n        let value: any = undefined\r\n        if (this.embeddedMetadata) {\r\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\r\n            // we need to get value of \"id\" column from the post real entity object\r\n\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\r\n            const isEmbeddedArray = this.embeddedMetadata.isArray\r\n\r\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\r\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\r\n            const extractEmbeddedColumnValue = (\r\n                propertyNames: string[],\r\n                value: ObjectLiteral,\r\n            ): any => {\r\n                const propertyName = propertyNames.shift()\r\n                return propertyName && value\r\n                    ? extractEmbeddedColumnValue(\r\n                          propertyNames,\r\n                          value[propertyName],\r\n                      )\r\n                    : value\r\n            }\r\n\r\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\r\n            const embeddedObject = extractEmbeddedColumnValue(\r\n                propertyNames,\r\n                entity,\r\n            )\r\n            if (embeddedObject) {\r\n                if (this.relationMetadata && this.referencedColumn) {\r\n                    const relatedEntity =\r\n                        this.relationMetadata.getEntityValue(embeddedObject)\r\n                    if (\r\n                        relatedEntity &&\r\n                        ObjectUtils.isObject(relatedEntity) &&\r\n                        !InstanceChecker.isFindOperator(relatedEntity) &&\r\n                        !Buffer.isBuffer(relatedEntity)\r\n                    ) {\r\n                        value =\r\n                            this.referencedColumn.getEntityValue(relatedEntity)\r\n                    } else if (\r\n                        embeddedObject[this.propertyName] &&\r\n                        ObjectUtils.isObject(\r\n                            embeddedObject[this.propertyName],\r\n                        ) &&\r\n                        !InstanceChecker.isFindOperator(\r\n                            embeddedObject[this.propertyName],\r\n                        ) &&\r\n                        !Buffer.isBuffer(embeddedObject[this.propertyName]) &&\r\n                        !(embeddedObject[this.propertyName] instanceof Date)\r\n                    ) {\r\n                        value = this.referencedColumn.getEntityValue(\r\n                            embeddedObject[this.propertyName],\r\n                        )\r\n                    } else {\r\n                        value = embeddedObject[this.propertyName]\r\n                    }\r\n                } else if (this.referencedColumn) {\r\n                    value = this.referencedColumn.getEntityValue(\r\n                        embeddedObject[this.propertyName],\r\n                    )\r\n                } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\r\n                    value = embeddedObject.map((o) => o[this.propertyName])\r\n                } else {\r\n                    value = embeddedObject[this.propertyName]\r\n                }\r\n            }\r\n        } else {\r\n            // no embeds - no problems. Simply return column name by property name of the entity\r\n            if (this.relationMetadata && this.referencedColumn) {\r\n                const relatedEntity =\r\n                    this.relationMetadata.getEntityValue(entity)\r\n                if (\r\n                    relatedEntity &&\r\n                    ObjectUtils.isObject(relatedEntity) &&\r\n                    !InstanceChecker.isFindOperator(relatedEntity) &&\r\n                    !(typeof relatedEntity === \"function\") &&\r\n                    !Buffer.isBuffer(relatedEntity)\r\n                ) {\r\n                    value = this.referencedColumn.getEntityValue(relatedEntity)\r\n                } else if (\r\n                    entity[this.propertyName] &&\r\n                    ObjectUtils.isObject(entity[this.propertyName]) &&\r\n                    !InstanceChecker.isFindOperator(\r\n                        entity[this.propertyName],\r\n                    ) &&\r\n                    !(typeof entity[this.propertyName] === \"function\") &&\r\n                    !Buffer.isBuffer(entity[this.propertyName]) &&\r\n                    !(entity[this.propertyName] instanceof Date)\r\n                ) {\r\n                    value = this.referencedColumn.getEntityValue(\r\n                        entity[this.propertyName],\r\n                    )\r\n                } else {\r\n                    value = entity[this.propertyName]\r\n                }\r\n            } else if (this.referencedColumn) {\r\n                value = this.referencedColumn.getEntityValue(\r\n                    entity[this.propertyName],\r\n                )\r\n            } else {\r\n                value = entity[this.propertyName]\r\n            }\r\n        }\r\n\r\n        if (transform && this.transformer)\r\n            value = ApplyValueTransformers.transformTo(this.transformer, value)\r\n\r\n        return value\r\n    }\r\n\r\n    /**\r\n     * Sets given entity's column value.\r\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\r\n     */\r\n    setEntityValue(entity: ObjectLiteral, value: any): void {\r\n        if (this.embeddedMetadata) {\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const extractEmbeddedColumnValue = (\r\n                embeddedMetadatas: EmbeddedMetadata[],\r\n                map: ObjectLiteral,\r\n            ): any => {\r\n                // if (!object[embeddedMetadata.propertyName])\r\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\r\n\r\n                const embeddedMetadata = embeddedMetadatas.shift()\r\n                if (embeddedMetadata) {\r\n                    if (!map[embeddedMetadata.propertyName])\r\n                        map[embeddedMetadata.propertyName] =\r\n                            embeddedMetadata.create()\r\n\r\n                    extractEmbeddedColumnValue(\r\n                        embeddedMetadatas,\r\n                        map[embeddedMetadata.propertyName],\r\n                    )\r\n                    return map\r\n                }\r\n                map[this.propertyName] = value\r\n                return map\r\n            }\r\n            return extractEmbeddedColumnValue(\r\n                [...this.embeddedMetadata.embeddedMetadataTree],\r\n                entity,\r\n            )\r\n        } else {\r\n            // we write a deep object in this entity only if the column is virtual\r\n            // because if its not virtual it means the user defined a real column for this relation\r\n            // also we don't do it if column is inside a junction table\r\n            if (\r\n                !this.entityMetadata.isJunction &&\r\n                this.isVirtual &&\r\n                this.referencedColumn &&\r\n                this.referencedColumn.propertyName !== this.propertyName\r\n            ) {\r\n                if (!(this.propertyName in entity)) {\r\n                    entity[this.propertyName] = {}\r\n                }\r\n\r\n                entity[this.propertyName][this.referencedColumn.propertyName] =\r\n                    value\r\n            } else {\r\n                entity[this.propertyName] = value\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compares given entity's column value with a given value.\r\n     */\r\n    compareEntityValue(entity: any, valueToCompareWith: any) {\r\n        const columnValue = this.getEntityValue(entity)\r\n        if (ObjectUtils.isObject(columnValue)) {\r\n            return columnValue.equals(valueToCompareWith)\r\n        }\r\n        return columnValue === valueToCompareWith\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Builder Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    build(connection: DataSource): this {\r\n        this.propertyPath = this.buildPropertyPath()\r\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\")\r\n        this.databaseName = this.buildDatabaseName(connection)\r\n        this.databasePath = this.buildDatabasePath()\r\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(\r\n            this.propertyName,\r\n            this.givenDatabaseName,\r\n            [],\r\n        )\r\n        return this\r\n    }\r\n\r\n    protected buildPropertyPath(): string {\r\n        let path = \"\"\r\n        if (\r\n            this.embeddedMetadata &&\r\n            this.embeddedMetadata.parentPropertyNames.length\r\n        )\r\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\r\n\r\n        path += this.propertyName\r\n\r\n        // we add reference column to property path only if this column is virtual\r\n        // because if its not virtual it means user defined a real column for this relation\r\n        // also we don't do it if column is inside a junction table\r\n        if (\r\n            !this.entityMetadata.isJunction &&\r\n            this.isVirtual &&\r\n            this.referencedColumn &&\r\n            this.referencedColumn.propertyName !== this.propertyName\r\n        )\r\n            path += \".\" + this.referencedColumn.propertyName\r\n\r\n        return path\r\n    }\r\n\r\n    protected buildDatabasePath(): string {\r\n        let path = \"\"\r\n        if (\r\n            this.embeddedMetadata &&\r\n            this.embeddedMetadata.parentPropertyNames.length\r\n        )\r\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\r\n\r\n        path += this.databaseName\r\n\r\n        // we add reference column to property path only if this column is virtual\r\n        // because if its not virtual it means user defined a real column for this relation\r\n        // also we don't do it if column is inside a junction table\r\n        if (\r\n            !this.entityMetadata.isJunction &&\r\n            this.isVirtual &&\r\n            this.referencedColumn &&\r\n            this.referencedColumn.databaseName !== this.databaseName\r\n        )\r\n            path += \".\" + this.referencedColumn.databaseName\r\n\r\n        return path\r\n    }\r\n\r\n    protected buildDatabaseName(connection: DataSource): string {\r\n        let propertyNames = this.embeddedMetadata\r\n            ? this.embeddedMetadata.parentPrefixes\r\n            : []\r\n        if (connection.driver.options.type === \"mongodb\")\r\n            // we don't need to include embedded name for the mongodb column names\r\n            propertyNames = []\r\n        return connection.namingStrategy.columnName(\r\n            this.propertyName,\r\n            this.givenDatabaseName,\r\n            propertyNames,\r\n        )\r\n    }\r\n}\r\n"],"sourceRoot":".."}