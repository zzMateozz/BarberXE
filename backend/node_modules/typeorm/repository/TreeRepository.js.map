{"version":3,"sources":["../../src/repository/TreeRepository.ts"],"names":[],"mappings":"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","file":"TreeRepository.js","sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { DriverUtils } from \"../driver/DriverUtils\"\r\nimport { TypeORMError } from \"../error/TypeORMError\"\r\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\r\nimport { FindTreeOptions } from \"../find-options/FindTreeOptions\"\r\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\r\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\"\r\nimport { Repository } from \"./Repository\"\r\n\r\n/**\r\n * Repository with additional functions to work with trees.\r\n *\r\n * @see Repository\r\n */\r\nexport class TreeRepository<\r\n    Entity extends ObjectLiteral,\r\n> extends Repository<Entity> {\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets complete trees for all roots in the table.\r\n     */\r\n    async findTrees(options?: FindTreeOptions): Promise<Entity[]> {\r\n        const roots = await this.findRoots(options)\r\n        await Promise.all(\r\n            roots.map((root) => this.findDescendantsTree(root, options)),\r\n        )\r\n        return roots\r\n    }\r\n\r\n    /**\r\n     * Roots are entities that have no ancestors. Finds them all.\r\n     */\r\n    findRoots(options?: FindTreeOptions): Promise<Entity[]> {\r\n        const escapeAlias = (alias: string) =>\r\n            this.manager.connection.driver.escape(alias)\r\n        const escapeColumn = (column: string) =>\r\n            this.manager.connection.driver.escape(column)\r\n\r\n        const joinColumn = this.metadata.treeParentRelation!.joinColumns[0]\r\n        const parentPropertyName =\r\n            joinColumn.givenDatabaseName || joinColumn.databaseName\r\n\r\n        const qb = this.createQueryBuilder(\"treeEntity\")\r\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\r\n\r\n        return qb\r\n            .where(\r\n                `${escapeAlias(\"treeEntity\")}.${escapeColumn(\r\n                    parentPropertyName,\r\n                )} IS NULL`,\r\n            )\r\n            .getMany()\r\n    }\r\n\r\n    /**\r\n     * Gets all children (descendants) of the given entity. Returns them all in a flat array.\r\n     */\r\n    findDescendants(\r\n        entity: Entity,\r\n        options?: FindTreeOptions,\r\n    ): Promise<Entity[]> {\r\n        const qb = this.createDescendantsQueryBuilder(\r\n            \"treeEntity\",\r\n            \"treeClosure\",\r\n            entity,\r\n        )\r\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\r\n        return qb.getMany()\r\n    }\r\n\r\n    /**\r\n     * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\r\n     */\r\n    async findDescendantsTree(\r\n        entity: Entity,\r\n        options?: FindTreeOptions,\r\n    ): Promise<Entity> {\r\n        // todo: throw exception if there is no column of this relation?\r\n\r\n        const qb: SelectQueryBuilder<Entity> =\r\n            this.createDescendantsQueryBuilder(\r\n                \"treeEntity\",\r\n                \"treeClosure\",\r\n                entity,\r\n            )\r\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\r\n\r\n        const entities = await qb.getRawAndEntities()\r\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(\r\n            this.manager,\r\n            this.metadata,\r\n            \"treeEntity\",\r\n            entities.raw,\r\n        )\r\n        TreeRepositoryUtils.buildChildrenEntityTree(\r\n            this.metadata,\r\n            entity,\r\n            entities.entities,\r\n            relationMaps,\r\n            {\r\n                depth: -1,\r\n                ...options,\r\n            },\r\n        )\r\n\r\n        return entity\r\n    }\r\n\r\n    /**\r\n     * Gets number of descendants of the entity.\r\n     */\r\n    countDescendants(entity: Entity): Promise<number> {\r\n        return this.createDescendantsQueryBuilder(\r\n            \"treeEntity\",\r\n            \"treeClosure\",\r\n            entity,\r\n        ).getCount()\r\n    }\r\n\r\n    /**\r\n     * Creates a query builder used to get descendants of the entities in a tree.\r\n     */\r\n    createDescendantsQueryBuilder(\r\n        alias: string,\r\n        closureTableAlias: string,\r\n        entity: Entity,\r\n    ): SelectQueryBuilder<Entity> {\r\n        // create shortcuts for better readability\r\n        const escape = (alias: string) =>\r\n            this.manager.connection.driver.escape(alias)\r\n\r\n        if (this.metadata.treeType === \"closure-table\") {\r\n            const joinCondition =\r\n                this.metadata.closureJunctionTable.descendantColumns\r\n                    .map((column) => {\r\n                        return (\r\n                            escape(closureTableAlias) +\r\n                            \".\" +\r\n                            escape(column.propertyPath) +\r\n                            \" = \" +\r\n                            escape(alias) +\r\n                            \".\" +\r\n                            escape(column.referencedColumn!.propertyPath)\r\n                        )\r\n                    })\r\n                    .join(\" AND \")\r\n\r\n            const parameters: ObjectLiteral = {}\r\n            const whereCondition =\r\n                this.metadata.closureJunctionTable.ancestorColumns\r\n                    .map((column) => {\r\n                        parameters[column.referencedColumn!.propertyName] =\r\n                            column.referencedColumn!.getEntityValue(entity)\r\n                        return (\r\n                            escape(closureTableAlias) +\r\n                            \".\" +\r\n                            escape(column.propertyPath) +\r\n                            \" = :\" +\r\n                            column.referencedColumn!.propertyName\r\n                        )\r\n                    })\r\n                    .join(\" AND \")\r\n\r\n            return this.createQueryBuilder(alias)\r\n                .innerJoin(\r\n                    this.metadata.closureJunctionTable.tableName,\r\n                    closureTableAlias,\r\n                    joinCondition,\r\n                )\r\n                .where(whereCondition)\r\n                .setParameters(parameters)\r\n        } else if (this.metadata.treeType === \"nested-set\") {\r\n            const whereCondition =\r\n                alias +\r\n                \".\" +\r\n                this.metadata.nestedSetLeftColumn!.propertyPath +\r\n                \" BETWEEN \" +\r\n                \"joined.\" +\r\n                this.metadata.nestedSetLeftColumn!.propertyPath +\r\n                \" AND joined.\" +\r\n                this.metadata.nestedSetRightColumn!.propertyPath\r\n            const parameters: ObjectLiteral = {}\r\n            const joinCondition = this.metadata\r\n                .treeParentRelation!.joinColumns.map((joinColumn) => {\r\n                    const parameterName =\r\n                        joinColumn.referencedColumn!.propertyPath.replace(\r\n                            \".\",\r\n                            \"_\",\r\n                        )\r\n                    parameters[parameterName] =\r\n                        joinColumn.referencedColumn!.getEntityValue(entity)\r\n                    return (\r\n                        \"joined.\" +\r\n                        joinColumn.referencedColumn!.propertyPath +\r\n                        \" = :\" +\r\n                        parameterName\r\n                    )\r\n                })\r\n                .join(\" AND \")\r\n\r\n            return this.createQueryBuilder(alias)\r\n                .innerJoin(this.metadata.targetName, \"joined\", whereCondition)\r\n                .where(joinCondition, parameters)\r\n        } else if (this.metadata.treeType === \"materialized-path\") {\r\n            return this.createQueryBuilder(alias).where((qb) => {\r\n                const subQuery = qb\r\n                    .subQuery()\r\n                    .select(\r\n                        `${this.metadata.targetName}.${\r\n                            this.metadata.materializedPathColumn!.propertyPath\r\n                        }`,\r\n                        \"path\",\r\n                    )\r\n                    .from(this.metadata.target, this.metadata.targetName)\r\n                    .whereInIds(this.metadata.getEntityIdMap(entity))\r\n\r\n                if (\r\n                    DriverUtils.isSQLiteFamily(this.manager.connection.driver)\r\n                ) {\r\n                    return `${alias}.${\r\n                        this.metadata.materializedPathColumn!.propertyPath\r\n                    } LIKE ${subQuery.getQuery()} || '%'`\r\n                } else {\r\n                    return `${alias}.${\r\n                        this.metadata.materializedPathColumn!.propertyPath\r\n                    } LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`\r\n                }\r\n            })\r\n        }\r\n\r\n        throw new TypeORMError(`Supported only in tree entities`)\r\n    }\r\n\r\n    /**\r\n     * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\r\n     */\r\n    findAncestors(\r\n        entity: Entity,\r\n        options?: FindTreeOptions,\r\n    ): Promise<Entity[]> {\r\n        const qb = this.createAncestorsQueryBuilder(\r\n            \"treeEntity\",\r\n            \"treeClosure\",\r\n            entity,\r\n        )\r\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\r\n        return qb.getMany()\r\n    }\r\n\r\n    /**\r\n     * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\r\n     */\r\n    async findAncestorsTree(\r\n        entity: Entity,\r\n        options?: FindTreeOptions,\r\n    ): Promise<Entity> {\r\n        // todo: throw exception if there is no column of this relation?\r\n        const qb = this.createAncestorsQueryBuilder(\r\n            \"treeEntity\",\r\n            \"treeClosure\",\r\n            entity,\r\n        )\r\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\r\n\r\n        const entities = await qb.getRawAndEntities()\r\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(\r\n            this.manager,\r\n            this.metadata,\r\n            \"treeEntity\",\r\n            entities.raw,\r\n        )\r\n        TreeRepositoryUtils.buildParentEntityTree(\r\n            this.metadata,\r\n            entity,\r\n            entities.entities,\r\n            relationMaps,\r\n        )\r\n        return entity\r\n    }\r\n\r\n    /**\r\n     * Gets number of ancestors of the entity.\r\n     */\r\n    countAncestors(entity: Entity): Promise<number> {\r\n        return this.createAncestorsQueryBuilder(\r\n            \"treeEntity\",\r\n            \"treeClosure\",\r\n            entity,\r\n        ).getCount()\r\n    }\r\n\r\n    /**\r\n     * Creates a query builder used to get ancestors of the entities in the tree.\r\n     */\r\n    createAncestorsQueryBuilder(\r\n        alias: string,\r\n        closureTableAlias: string,\r\n        entity: Entity,\r\n    ): SelectQueryBuilder<Entity> {\r\n        // create shortcuts for better readability\r\n        // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\r\n\r\n        if (this.metadata.treeType === \"closure-table\") {\r\n            const joinCondition =\r\n                this.metadata.closureJunctionTable.ancestorColumns\r\n                    .map((column) => {\r\n                        return (\r\n                            closureTableAlias +\r\n                            \".\" +\r\n                            column.propertyPath +\r\n                            \" = \" +\r\n                            alias +\r\n                            \".\" +\r\n                            column.referencedColumn!.propertyPath\r\n                        )\r\n                    })\r\n                    .join(\" AND \")\r\n\r\n            const parameters: ObjectLiteral = {}\r\n            const whereCondition =\r\n                this.metadata.closureJunctionTable.descendantColumns\r\n                    .map((column) => {\r\n                        parameters[column.referencedColumn!.propertyName] =\r\n                            column.referencedColumn!.getEntityValue(entity)\r\n                        return (\r\n                            closureTableAlias +\r\n                            \".\" +\r\n                            column.propertyPath +\r\n                            \" = :\" +\r\n                            column.referencedColumn!.propertyName\r\n                        )\r\n                    })\r\n                    .join(\" AND \")\r\n\r\n            return this.createQueryBuilder(alias)\r\n                .innerJoin(\r\n                    this.metadata.closureJunctionTable.tableName,\r\n                    closureTableAlias,\r\n                    joinCondition,\r\n                )\r\n                .where(whereCondition)\r\n                .setParameters(parameters)\r\n        } else if (this.metadata.treeType === \"nested-set\") {\r\n            const joinCondition =\r\n                \"joined.\" +\r\n                this.metadata.nestedSetLeftColumn!.propertyPath +\r\n                \" BETWEEN \" +\r\n                alias +\r\n                \".\" +\r\n                this.metadata.nestedSetLeftColumn!.propertyPath +\r\n                \" AND \" +\r\n                alias +\r\n                \".\" +\r\n                this.metadata.nestedSetRightColumn!.propertyPath\r\n            const parameters: ObjectLiteral = {}\r\n            const whereCondition = this.metadata\r\n                .treeParentRelation!.joinColumns.map((joinColumn) => {\r\n                    const parameterName =\r\n                        joinColumn.referencedColumn!.propertyPath.replace(\r\n                            \".\",\r\n                            \"_\",\r\n                        )\r\n                    parameters[parameterName] =\r\n                        joinColumn.referencedColumn!.getEntityValue(entity)\r\n                    return (\r\n                        \"joined.\" +\r\n                        joinColumn.referencedColumn!.propertyPath +\r\n                        \" = :\" +\r\n                        parameterName\r\n                    )\r\n                })\r\n                .join(\" AND \")\r\n\r\n            return this.createQueryBuilder(alias)\r\n                .innerJoin(this.metadata.targetName, \"joined\", joinCondition)\r\n                .where(whereCondition, parameters)\r\n        } else if (this.metadata.treeType === \"materialized-path\") {\r\n            // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\r\n            return this.createQueryBuilder(alias).where((qb) => {\r\n                const subQuery = qb\r\n                    .subQuery()\r\n                    .select(\r\n                        `${this.metadata.targetName}.${\r\n                            this.metadata.materializedPathColumn!.propertyPath\r\n                        }`,\r\n                        \"path\",\r\n                    )\r\n                    .from(this.metadata.target, this.metadata.targetName)\r\n                    .whereInIds(this.metadata.getEntityIdMap(entity))\r\n\r\n                if (\r\n                    DriverUtils.isSQLiteFamily(this.manager.connection.driver)\r\n                ) {\r\n                    return `${subQuery.getQuery()} LIKE ${alias}.${\r\n                        this.metadata.materializedPathColumn!.propertyPath\r\n                    } || '%'`\r\n                } else {\r\n                    return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${\r\n                        this.metadata.materializedPathColumn!.propertyPath\r\n                    }, '%')`\r\n                }\r\n            })\r\n        }\r\n\r\n        throw new TypeORMError(`Supported only in tree entities`)\r\n    }\r\n\r\n    /**\r\n     * Moves entity to the children of then given entity.\r\n     *\r\n    move(entity: Entity, to: Entity): Promise<void> {\r\n        return Promise.resolve();\r\n    } */\r\n}\r\n"],"sourceRoot":".."}