{"version":3,"sources":["../../src/subscriber/Broadcaster.ts"],"names":[],"mappings":"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","file":"Broadcaster.js","sourcesContent":["import { EntitySubscriberInterface } from \"./EntitySubscriberInterface\"\r\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\r\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\r\nimport { BroadcasterResult } from \"./BroadcasterResult\"\r\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\r\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\n\r\ninterface BroadcasterEvents {\r\n    BeforeQuery: () => void\r\n    AfterQuery: () => void\r\n\r\n    BeforeTransactionCommit: () => void\r\n    AfterTransactionCommit: () => void\r\n    BeforeTransactionStart: () => void\r\n    AfterTransactionStart: () => void\r\n    BeforeTransactionRollback: () => void\r\n    AfterTransactionRollback: () => void\r\n\r\n    BeforeUpdate: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        updatedColumns?: ColumnMetadata[],\r\n        updatedRelations?: RelationMetadata[],\r\n    ) => void\r\n    AfterUpdate: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        updatedColumns?: ColumnMetadata[],\r\n        updatedRelations?: RelationMetadata[],\r\n    ) => void\r\n\r\n    BeforeInsert: (\r\n        metadata: EntityMetadata,\r\n        entity: ObjectLiteral | undefined,\r\n    ) => void\r\n    AfterInsert: (\r\n        metadata: EntityMetadata,\r\n        entity: ObjectLiteral | undefined,\r\n    ) => void\r\n\r\n    BeforeRemove: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n    ) => void\r\n    AfterRemove: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n    ) => void\r\n\r\n    BeforeSoftRemove: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n    ) => void\r\n    AfterSoftRemove: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n    ) => void\r\n\r\n    BeforeRecover: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n    ) => void\r\n    AfterRecover: (\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n    ) => void\r\n\r\n    Load: (metadata: EntityMetadata, entities: ObjectLiteral[]) => void\r\n}\r\n\r\n/**\r\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\r\n */\r\nexport class Broadcaster {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private queryRunner: QueryRunner) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    async broadcast<U extends keyof BroadcasterEvents>(\r\n        event: U,\r\n        ...args: Parameters<BroadcasterEvents[U]>\r\n    ): Promise<void> {\r\n        const result = new BroadcasterResult()\r\n\r\n        const broadcastFunction = this[`broadcast${event}Event` as keyof this]\r\n\r\n        if (typeof broadcastFunction === \"function\") {\r\n            ;(broadcastFunction as any).call(this, result, ...args)\r\n        }\r\n\r\n        await result.wait()\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_INSERT\" event.\r\n     * Before insert event is executed before entity is being inserted to the database for the first time.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeInsertEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity: undefined | ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.beforeInsertListeners.length) {\r\n            metadata.beforeInsertListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.beforeInsert\r\n                ) {\r\n                    const executionResult = subscriber.beforeInsert({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_UPDATE\" event.\r\n     * Before update event is executed before entity is being updated in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeUpdateEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        updatedColumns?: ColumnMetadata[],\r\n        updatedRelations?: RelationMetadata[],\r\n    ): void {\r\n        // todo: send relations too?\r\n        if (entity && metadata.beforeUpdateListeners.length) {\r\n            metadata.beforeUpdateListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.beforeUpdate\r\n                ) {\r\n                    const executionResult = subscriber.beforeUpdate({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        updatedColumns: updatedColumns || [],\r\n                        updatedRelations: updatedRelations || [],\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_REMOVE\" event.\r\n     * Before remove event is executed before entity is being removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeRemoveEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.beforeRemoveListeners.length) {\r\n            metadata.beforeRemoveListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.beforeRemove\r\n                ) {\r\n                    const executionResult = subscriber.beforeRemove({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(\r\n                            databaseEntity ?? identifier,\r\n                        ),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\r\n     * Before soft remove event is executed before entity is being soft removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeSoftRemoveEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.beforeSoftRemoveListeners.length) {\r\n            metadata.beforeSoftRemoveListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.beforeSoftRemove\r\n                ) {\r\n                    const executionResult = subscriber.beforeSoftRemove({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(\r\n                            databaseEntity ?? identifier,\r\n                        ),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_RECOVER\" event.\r\n     * Before recover event is executed before entity is being recovered in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeRecoverEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.beforeRecoverListeners.length) {\r\n            metadata.beforeRecoverListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.beforeRecover\r\n                ) {\r\n                    const executionResult = subscriber.beforeRecover({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(\r\n                            databaseEntity ?? identifier,\r\n                        ),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_INSERT\" event.\r\n     * After insert event is executed after entity is being persisted to the database for the first time.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterInsertEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.afterInsertListeners.length) {\r\n            metadata.afterInsertListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.afterInsert\r\n                ) {\r\n                    const executionResult = subscriber.afterInsert({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        entityId: metadata.getEntityIdMixedMap(identifier),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_QUERY\" event.\r\n     */\r\n    broadcastBeforeQueryEvent(\r\n        result: BroadcasterResult,\r\n        query: string,\r\n        parameters: undefined | any[],\r\n    ): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.beforeQuery) {\r\n                    const executionResult = subscriber.beforeQuery({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        query: query,\r\n                        parameters: parameters,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_QUERY\" event.\r\n     */\r\n    broadcastAfterQueryEvent(\r\n        result: BroadcasterResult,\r\n        query: string,\r\n        parameters: undefined | any[],\r\n        success: boolean,\r\n        executionTime: undefined | number,\r\n        rawResults: undefined | any,\r\n        error: undefined | any,\r\n    ): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.afterQuery) {\r\n                    const executionResult = subscriber.afterQuery({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        query: query,\r\n                        parameters: parameters,\r\n                        success: success,\r\n                        executionTime: executionTime,\r\n                        rawResults: rawResults,\r\n                        error: error,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_TRANSACTION_START\" event.\r\n     */\r\n    broadcastBeforeTransactionStartEvent(result: BroadcasterResult): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.beforeTransactionStart) {\r\n                    const executionResult = subscriber.beforeTransactionStart({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_TRANSACTION_START\" event.\r\n     */\r\n    broadcastAfterTransactionStartEvent(result: BroadcasterResult): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.afterTransactionStart) {\r\n                    const executionResult = subscriber.afterTransactionStart({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\r\n     */\r\n    broadcastBeforeTransactionCommitEvent(result: BroadcasterResult): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.beforeTransactionCommit) {\r\n                    const executionResult = subscriber.beforeTransactionCommit({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\r\n     */\r\n    broadcastAfterTransactionCommitEvent(result: BroadcasterResult): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.afterTransactionCommit) {\r\n                    const executionResult = subscriber.afterTransactionCommit({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\r\n     */\r\n    broadcastBeforeTransactionRollbackEvent(result: BroadcasterResult): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.beforeTransactionRollback) {\r\n                    const executionResult =\r\n                        subscriber.beforeTransactionRollback({\r\n                            connection: this.queryRunner.connection,\r\n                            queryRunner: this.queryRunner,\r\n                            manager: this.queryRunner.manager,\r\n                        })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\r\n     */\r\n    broadcastAfterTransactionRollbackEvent(result: BroadcasterResult): void {\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (subscriber.afterTransactionRollback) {\r\n                    const executionResult = subscriber.afterTransactionRollback(\r\n                        {\r\n                            connection: this.queryRunner.connection,\r\n                            queryRunner: this.queryRunner,\r\n                            manager: this.queryRunner.manager,\r\n                        },\r\n                    )\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_UPDATE\" event.\r\n     * After update event is executed after entity is being updated in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterUpdateEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        updatedColumns?: ColumnMetadata[],\r\n        updatedRelations?: RelationMetadata[],\r\n    ): void {\r\n        if (entity && metadata.afterUpdateListeners.length) {\r\n            metadata.afterUpdateListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.afterUpdate\r\n                ) {\r\n                    const executionResult = subscriber.afterUpdate({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        updatedColumns: updatedColumns || [],\r\n                        updatedRelations: updatedRelations || [],\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_REMOVE\" event.\r\n     * After remove event is executed after entity is being removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterRemoveEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.afterRemoveListeners.length) {\r\n            metadata.afterRemoveListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.afterRemove\r\n                ) {\r\n                    const executionResult = subscriber.afterRemove({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(\r\n                            databaseEntity ?? identifier,\r\n                        ),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_SOFT_REMOVE\" event.\r\n     * After soft remove event is executed after entity is being soft removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterSoftRemoveEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.afterSoftRemoveListeners.length) {\r\n            metadata.afterSoftRemoveListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.afterSoftRemove\r\n                ) {\r\n                    const executionResult = subscriber.afterSoftRemove({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(\r\n                            databaseEntity ?? identifier,\r\n                        ),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_RECOVER\" event.\r\n     * After recover event is executed after entity is being recovered in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterRecoverEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entity?: ObjectLiteral,\r\n        databaseEntity?: ObjectLiteral,\r\n        identifier?: ObjectLiteral,\r\n    ): void {\r\n        if (entity && metadata.afterRecoverListeners.length) {\r\n            metadata.afterRecoverListeners.forEach((listener) => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity)\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\r\n                if (\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.afterRecover\r\n                ) {\r\n                    const executionResult = subscriber.afterRecover({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        metadata: metadata,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(\r\n                            databaseEntity ?? identifier,\r\n                        ),\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `broadcastLoadForAllEvent`\r\n     */\r\n    broadcastLoadEventsForAll(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entities: ObjectLiteral[],\r\n    ): void {\r\n        return this.broadcastLoadEvent(result, metadata, entities)\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\r\n     * After load event is executed after entity has been loaded from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastLoadEvent(\r\n        result: BroadcasterResult,\r\n        metadata: EntityMetadata,\r\n        entities: ObjectLiteral[],\r\n    ): void {\r\n        // Calculate which subscribers are fitting for the given entity type\r\n        const fittingSubscribers =\r\n            this.queryRunner.connection.subscribers.filter(\r\n                (subscriber) =>\r\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\r\n                    subscriber.afterLoad,\r\n            )\r\n\r\n        if (\r\n            metadata.relations.length ||\r\n            metadata.afterLoadListeners.length ||\r\n            fittingSubscribers.length\r\n        ) {\r\n            // todo: check why need this?\r\n            const nonPromiseEntities = entities.filter(\r\n                (entity) => !(entity instanceof Promise),\r\n            )\r\n\r\n            // collect load events for all children entities that were loaded with the main entity\r\n            if (metadata.relations.length) {\r\n                metadata.relations.forEach((relation) => {\r\n                    nonPromiseEntities.forEach((entity) => {\r\n                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\r\n                        if (\r\n                            relation.isLazy &&\r\n                            !entity.hasOwnProperty(relation.propertyName)\r\n                        )\r\n                            return\r\n\r\n                        const value = relation.getEntityValue(entity)\r\n                        if (ObjectUtils.isObject(value))\r\n                            this.broadcastLoadEvent(\r\n                                result,\r\n                                relation.inverseEntityMetadata,\r\n                                Array.isArray(value) ? value : [value],\r\n                            )\r\n                    })\r\n                })\r\n            }\r\n\r\n            if (metadata.afterLoadListeners.length) {\r\n                metadata.afterLoadListeners.forEach((listener) => {\r\n                    nonPromiseEntities.forEach((entity) => {\r\n                        if (listener.isAllowed(entity)) {\r\n                            const executionResult = listener.execute(entity)\r\n                            if (executionResult instanceof Promise)\r\n                                result.promises.push(executionResult)\r\n                            result.count++\r\n                        }\r\n                    })\r\n                })\r\n            }\r\n\r\n            fittingSubscribers.forEach((subscriber) => {\r\n                nonPromiseEntities.forEach((entity) => {\r\n                    const executionResult = subscriber.afterLoad!(entity, {\r\n                        entity,\r\n                        metadata,\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                    })\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult)\r\n                    result.count++\r\n                })\r\n            })\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\r\n     * or listens our entity.\r\n     */\r\n    protected isAllowedSubscriber(\r\n        subscriber: EntitySubscriberInterface<any>,\r\n        target: Function | string,\r\n    ): boolean {\r\n        return (\r\n            !subscriber.listenTo ||\r\n            !subscriber.listenTo() ||\r\n            subscriber.listenTo() === Object ||\r\n            subscriber.listenTo() === target ||\r\n            subscriber.listenTo().isPrototypeOf(target)\r\n        )\r\n    }\r\n}\r\n"],"sourceRoot":".."}