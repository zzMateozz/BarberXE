{"version":3,"sources":["../../src/decorator/entity/Entity.ts"],"names":[],"mappings":";;AAqBA,wBAyBC;AA9CD,2CAAsD;AAGtD,wDAAoD;AAcpD;;;GAGG;AACH,SAAgB,MAAM,CAClB,aAAsC,EACtC,YAA4B;IAE5B,MAAM,OAAO,GACT,CAAC,yBAAW,CAAC,QAAQ,CAAC,aAAa,CAAC;QAChC,CAAC,CAAE,aAA+B;QAClC,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,CAAA;IAC7B,MAAM,IAAI,GACN,OAAO,aAAa,KAAK,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAA;IAEpE,OAAO,UAAU,MAAM;QACnB,IAAA,gCAAsB,GAAE,CAAC,MAAM,CAAC,IAAI,CAAC;YACjC,MAAM,EAAE,MAAM;YACd,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS;YACtD,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;YACnD,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;YACzD,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;YACnD,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,YAAY,EAAE,OAAO,CAAC,YAAY;YAClC,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS;SACpC,CAAC,CAAA;IAC3B,CAAC,CAAA;AACL,CAAC","file":"Entity.js","sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\r\nimport { TableMetadataArgs } from \"../../metadata-args/TableMetadataArgs\"\r\nimport { EntityOptions } from \"../options/EntityOptions\"\r\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\r\n\r\n/**\r\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\r\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\r\n */\r\nexport function Entity(options?: EntityOptions): ClassDecorator\r\n\r\n/**\r\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\r\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\r\n */\r\nexport function Entity(name?: string, options?: EntityOptions): ClassDecorator\r\n\r\n/**\r\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\r\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\r\n */\r\nexport function Entity(\r\n    nameOrOptions?: string | EntityOptions,\r\n    maybeOptions?: EntityOptions,\r\n): ClassDecorator {\r\n    const options =\r\n        (ObjectUtils.isObject(nameOrOptions)\r\n            ? (nameOrOptions as EntityOptions)\r\n            : maybeOptions) || {}\r\n    const name =\r\n        typeof nameOrOptions === \"string\" ? nameOrOptions : options.name\r\n\r\n    return function (target) {\r\n        getMetadataArgsStorage().tables.push({\r\n            target: target,\r\n            name: name,\r\n            type: \"regular\",\r\n            orderBy: options.orderBy ? options.orderBy : undefined,\r\n            engine: options.engine ? options.engine : undefined,\r\n            database: options.database ? options.database : undefined,\r\n            schema: options.schema ? options.schema : undefined,\r\n            synchronize: options.synchronize,\r\n            withoutRowid: options.withoutRowid,\r\n            comment: options.comment ? options.comment : undefined,\r\n        } as TableMetadataArgs)\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}