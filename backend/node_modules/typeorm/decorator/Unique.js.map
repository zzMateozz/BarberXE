{"version":3,"sources":["../../src/decorator/Unique.ts"],"names":[],"mappings":";;AA0CA,wBA+DC;AAzGD,wCAAmD;AAGnD,qDAAiD;AAoCjD;;GAEG;AACH,SAAgB,MAAM,CAClB,qBAImB,EACnB,oBAGmB,EACnB,YAA4B;IAE5B,MAAM,IAAI,GACN,OAAO,qBAAqB,KAAK,QAAQ;QACrC,CAAC,CAAC,qBAAqB;QACvB,CAAC,CAAC,SAAS,CAAA;IACnB,MAAM,MAAM,GACR,OAAO,qBAAqB,KAAK,QAAQ;QACrC,CAAC,CAGE,oBAAoB;QACvB,CAAC,CAAE,qBAAkC,CAAA;IAC7C,IAAI,OAAO,GACP,yBAAW,CAAC,QAAQ,CAAC,qBAAqB,CAAC;QAC3C,CAAC,KAAK,CAAC,OAAO,CAAC,qBAAqB,CAAC;QACjC,CAAC,CAAE,qBAAuC;QAC1C,CAAC,CAAC,YAAY,CAAA;IACtB,IAAI,CAAC,OAAO;QACR,OAAO;YACH,yBAAW,CAAC,QAAQ,CAAC,qBAAqB,CAAC;gBAC3C,CAAC,KAAK,CAAC,OAAO,CAAC,oBAAoB,CAAC;gBAChC,CAAC,CAAE,oBAAsC;gBACzC,CAAC,CAAC,YAAY,CAAA;IAE1B,OAAO,UACH,WAA8B,EAC9B,YAA8B;QAE9B,IAAI,OAAO,GAAG,MAAM,CAAA;QAEpB,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;YAC7B,QAAQ,OAAO,YAAY,EAAE,CAAC;gBAC1B,KAAK,QAAQ;oBACT,OAAO,GAAG,CAAC,YAAY,CAAC,CAAA;oBACxB,MAAK;gBAET,KAAK,QAAQ;oBACT,OAAO,GAAG,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAA;oBACnC,MAAK;YACb,CAAC;QACL,CAAC;QAED,MAAM,IAAI,GAAuB;YAC7B,MAAM,EAAE,YAAY;gBAChB,CAAC,CAAC,WAAW,CAAC,WAAW;gBACzB,CAAC,CAAE,WAAwB;YAC/B,IAAI,EAAE,IAAI;YACV,OAAO;YACP,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS;SACvD,CAAA;QACD,IAAA,gCAAsB,GAAE,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC/C,CAAC,CAAA;AACL,CAAC","file":"Unique.js","sourcesContent":["import { getMetadataArgsStorage } from \"../globals\"\r\nimport { UniqueMetadataArgs } from \"../metadata-args/UniqueMetadataArgs\"\r\nimport { UniqueOptions } from \"./options/UniqueOptions\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\n\r\n/**\r\n * Composite unique constraint must be set on entity classes and must specify entity's fields to be unique.\r\n */\r\nexport function Unique(\r\n    name: string,\r\n    fields: string[],\r\n    options?: UniqueOptions,\r\n): ClassDecorator & PropertyDecorator\r\n\r\n/**\r\n * Composite unique constraint must be set on entity classes and must specify entity's fields to be unique.\r\n */\r\nexport function Unique(\r\n    fields: string[],\r\n    options?: UniqueOptions,\r\n): ClassDecorator & PropertyDecorator\r\n\r\n/**\r\n * Composite unique constraint must be set on entity classes and must specify entity's fields to be unique.\r\n */\r\nexport function Unique(\r\n    fields: (object?: any) => any[] | { [key: string]: number },\r\n    options?: UniqueOptions,\r\n): ClassDecorator & PropertyDecorator\r\n\r\n/**\r\n * Composite unique constraint must be set on entity classes and must specify entity's fields to be unique.\r\n */\r\nexport function Unique(\r\n    name: string,\r\n    fields: (object?: any) => any[] | { [key: string]: number },\r\n    options?: UniqueOptions,\r\n): ClassDecorator & PropertyDecorator\r\n\r\n/**\r\n * Composite unique constraint must be set on entity classes and must specify entity's fields to be unique.\r\n */\r\nexport function Unique(\r\n    nameOrFieldsOrOptions?:\r\n        | string\r\n        | string[]\r\n        | ((object: any) => any[] | { [key: string]: number })\r\n        | UniqueOptions,\r\n    maybeFieldsOrOptions?:\r\n        | ((object?: any) => any[] | { [key: string]: number })\r\n        | string[]\r\n        | UniqueOptions,\r\n    maybeOptions?: UniqueOptions,\r\n): ClassDecorator & PropertyDecorator {\r\n    const name =\r\n        typeof nameOrFieldsOrOptions === \"string\"\r\n            ? nameOrFieldsOrOptions\r\n            : undefined\r\n    const fields =\r\n        typeof nameOrFieldsOrOptions === \"string\"\r\n            ? <\r\n                  | ((object?: any) => any[] | { [key: string]: number })\r\n                  | string[]\r\n              >maybeFieldsOrOptions\r\n            : (nameOrFieldsOrOptions as string[])\r\n    let options =\r\n        ObjectUtils.isObject(nameOrFieldsOrOptions) &&\r\n        !Array.isArray(nameOrFieldsOrOptions)\r\n            ? (nameOrFieldsOrOptions as UniqueOptions)\r\n            : maybeOptions\r\n    if (!options)\r\n        options =\r\n            ObjectUtils.isObject(nameOrFieldsOrOptions) &&\r\n            !Array.isArray(maybeFieldsOrOptions)\r\n                ? (maybeFieldsOrOptions as UniqueOptions)\r\n                : maybeOptions\r\n\r\n    return function (\r\n        clsOrObject: Function | Object,\r\n        propertyName?: string | symbol,\r\n    ) {\r\n        let columns = fields\r\n\r\n        if (propertyName !== undefined) {\r\n            switch (typeof propertyName) {\r\n                case \"string\":\r\n                    columns = [propertyName]\r\n                    break\r\n\r\n                case \"symbol\":\r\n                    columns = [propertyName.toString()]\r\n                    break\r\n            }\r\n        }\r\n\r\n        const args: UniqueMetadataArgs = {\r\n            target: propertyName\r\n                ? clsOrObject.constructor\r\n                : (clsOrObject as Function),\r\n            name: name,\r\n            columns,\r\n            deferrable: options ? options.deferrable : undefined,\r\n        }\r\n        getMetadataArgsStorage().uniques.push(args)\r\n    }\r\n}\r\n"],"sourceRoot":".."}