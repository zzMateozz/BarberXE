{"version":3,"sources":["../../src/decorator/columns/Column.ts"],"names":[],"mappings":"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","file":"Column.js","sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\r\nimport {\r\n    ColumnType,\r\n    SimpleColumnType,\r\n    SpatialColumnType,\r\n    WithLengthColumnType,\r\n    WithPrecisionColumnType,\r\n    WithWidthColumnType,\r\n} from \"../../driver/types/ColumnTypes\"\r\nimport { ColumnMetadataArgs } from \"../../metadata-args/ColumnMetadataArgs\"\r\nimport { ColumnCommonOptions } from \"../options/ColumnCommonOptions\"\r\nimport { SpatialColumnOptions } from \"../options/SpatialColumnOptions\"\r\nimport { ColumnWithLengthOptions } from \"../options/ColumnWithLengthOptions\"\r\nimport { ColumnNumericOptions } from \"../options/ColumnNumericOptions\"\r\nimport { ColumnEnumOptions } from \"../options/ColumnEnumOptions\"\r\nimport { ColumnEmbeddedOptions } from \"../options/ColumnEmbeddedOptions\"\r\nimport { EmbeddedMetadataArgs } from \"../../metadata-args/EmbeddedMetadataArgs\"\r\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\"\r\nimport { ColumnHstoreOptions } from \"../options/ColumnHstoreOptions\"\r\nimport { ColumnWithWidthOptions } from \"../options/ColumnWithWidthOptions\"\r\nimport { GeneratedMetadataArgs } from \"../../metadata-args/GeneratedMetadataArgs\"\r\nimport { ColumnOptions } from \"../options/ColumnOptions\"\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column. Only properties decorated with this\r\n * decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(options: ColumnOptions): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: SimpleColumnType,\r\n    options?: ColumnCommonOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: SpatialColumnType,\r\n    options?: ColumnCommonOptions & SpatialColumnOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: WithLengthColumnType,\r\n    options?: ColumnCommonOptions & ColumnWithLengthOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: WithWidthColumnType,\r\n    options?: ColumnCommonOptions & ColumnWithWidthOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: WithPrecisionColumnType,\r\n    options?: ColumnCommonOptions & ColumnNumericOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: \"enum\",\r\n    options?: ColumnCommonOptions & ColumnEnumOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: \"simple-enum\",\r\n    options?: ColumnCommonOptions & ColumnEnumOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: \"set\",\r\n    options?: ColumnCommonOptions & ColumnEnumOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    type: \"hstore\",\r\n    options?: ColumnCommonOptions & ColumnHstoreOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n *\r\n * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the\r\n * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the\r\n * embedded will be mapped to it from the single table.\r\n */\r\nexport function Column(\r\n    type: (type?: any) => Function,\r\n    options?: ColumnEmbeddedOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n */\r\nexport function Column(\r\n    typeOrOptions?:\r\n        | ((type?: any) => Function)\r\n        | ColumnType\r\n        | (ColumnOptions & ColumnEmbeddedOptions),\r\n    options?: ColumnOptions & ColumnEmbeddedOptions,\r\n): PropertyDecorator {\r\n    return function (object: Object, propertyName: string) {\r\n        // normalize parameters\r\n        let type: ColumnType | undefined\r\n        if (\r\n            typeof typeOrOptions === \"string\" ||\r\n            typeof typeOrOptions === \"function\"\r\n        ) {\r\n            type = <ColumnType>typeOrOptions\r\n        } else if (typeOrOptions) {\r\n            options = <ColumnOptions>typeOrOptions\r\n            type = typeOrOptions.type\r\n        }\r\n        if (!options) options = {} as ColumnOptions\r\n\r\n        // if type is not given explicitly then try to guess it\r\n        const reflectMetadataType =\r\n            Reflect && (Reflect as any).getMetadata\r\n                ? (Reflect as any).getMetadata(\r\n                      \"design:type\",\r\n                      object,\r\n                      propertyName,\r\n                  )\r\n                : undefined\r\n        if (!type && reflectMetadataType)\r\n            // if type is not given explicitly then try to guess it\r\n            type = reflectMetadataType\r\n\r\n        // check if there is no type in column options then set type from first function argument, or guessed one\r\n        if (!options.type && type) options.type = type\r\n\r\n        // specify HSTORE type if column is HSTORE\r\n        if (options.type === \"hstore\" && !options.hstoreType)\r\n            options.hstoreType =\r\n                reflectMetadataType === Object ? \"object\" : \"string\"\r\n\r\n        if (typeof typeOrOptions === \"function\") {\r\n            // register an embedded\r\n            getMetadataArgsStorage().embeddeds.push({\r\n                target: object.constructor,\r\n                propertyName: propertyName,\r\n                isArray:\r\n                    reflectMetadataType === Array || options.array === true,\r\n                prefix:\r\n                    options.prefix !== undefined ? options.prefix : undefined,\r\n                type: typeOrOptions as (type?: any) => Function,\r\n            } as EmbeddedMetadataArgs)\r\n        } else {\r\n            // register a regular column\r\n\r\n            // if we still don't have a type then we need to give error to user that type is required\r\n            if (!options.type)\r\n                throw new ColumnTypeUndefinedError(object, propertyName)\r\n\r\n            // create unique\r\n            if (options.unique === true)\r\n                getMetadataArgsStorage().uniques.push({\r\n                    target: object.constructor,\r\n                    columns: [propertyName],\r\n                })\r\n\r\n            getMetadataArgsStorage().columns.push({\r\n                target: object.constructor,\r\n                propertyName: propertyName,\r\n                mode: \"regular\",\r\n                options: options,\r\n            } as ColumnMetadataArgs)\r\n\r\n            if (options.generated) {\r\n                getMetadataArgsStorage().generations.push({\r\n                    target: object.constructor,\r\n                    propertyName: propertyName,\r\n                    strategy:\r\n                        typeof options.generated === \"string\"\r\n                            ? options.generated\r\n                            : \"increment\",\r\n                } as GeneratedMetadataArgs)\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}