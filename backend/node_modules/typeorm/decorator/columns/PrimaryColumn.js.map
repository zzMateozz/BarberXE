{"version":3,"sources":["../../src/decorator/columns/PrimaryColumn.ts"],"names":[],"mappings":";;AAoCA,sCA+DC;AAnGD,2CAAsD;AACtD,mFAA+E;AAC/E,uGAAmG;AA6BnG;;;;GAIG;AACH,SAAgB,aAAa,CACzB,aAAiD,EACjD,OAA8B;IAE9B,OAAO,UAAU,MAAc,EAAE,YAAoB;QACjD,uBAAuB;QACvB,IAAI,IAA4B,CAAA;QAChC,IACI,OAAO,aAAa,KAAK,QAAQ;YACjC,aAAa,KAAK,MAAM;YACxB,aAAa,KAAK,OAAO;YACzB,aAAa,KAAK,MAAM,EAC1B,CAAC;YACC,IAAI,GAAG,aAA2B,CAAA;QACtC,CAAC;aAAM,CAAC;YACJ,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAwB,aAAa,CAAC,CAAA;QACpE,CAAC;QACD,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAA0B,CAAA;QAElD,uDAAuD;QACvD,MAAM,mBAAmB,GACrB,OAAO,IAAK,OAAe,CAAC,WAAW;YACnC,CAAC,CAAE,OAAe,CAAC,WAAW,CACxB,aAAa,EACb,MAAM,EACN,YAAY,CACf;YACH,CAAC,CAAC,SAAS,CAAA;QACnB,IAAI,CAAC,IAAI,IAAI,mBAAmB;YAAE,IAAI,GAAG,mBAAmB,CAAA;QAE5D,yGAAyG;QACzG,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,IAAI;YAAE,OAAO,CAAC,IAAI,GAAG,IAAI,CAAA;QAE9C,yFAAyF;QACzF,IAAI,CAAC,OAAO,CAAC,IAAI;YACb,MAAM,IAAI,mDAAwB,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA;QAE5D,wFAAwF;QACxF,IAAI,OAAO,CAAC,QAAQ;YAChB,MAAM,IAAI,uEAAkC,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA;QAEtE,6CAA6C;QAC7C,OAAO,CAAC,OAAO,GAAG,IAAI,CAAA;QAEtB,4CAA4C;QAC5C,IAAA,gCAAsB,GAAE,CAAC,OAAO,CAAC,IAAI,CAAC;YAClC,MAAM,EAAE,MAAM,CAAC,WAAW;YAC1B,YAAY,EAAE,YAAY;YAC1B,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,OAAO;SACG,CAAC,CAAA;QAExB,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;YACpB,IAAA,gCAAsB,GAAE,CAAC,WAAW,CAAC,IAAI,CAAC;gBACtC,MAAM,EAAE,MAAM,CAAC,WAAW;gBAC1B,YAAY,EAAE,YAAY;gBAC1B,QAAQ,EACJ,OAAO,OAAO,CAAC,SAAS,KAAK,QAAQ;oBACjC,CAAC,CAAC,OAAO,CAAC,SAAS;oBACnB,CAAC,CAAC,WAAW;aACC,CAAC,CAAA;QAC/B,CAAC;IACL,CAAC,CAAA;AACL,CAAC","file":"PrimaryColumn.js","sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\r\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\"\r\nimport { PrimaryColumnCannotBeNullableError } from \"../../error/PrimaryColumnCannotBeNullableError\"\r\nimport { ColumnMetadataArgs } from \"../../metadata-args/ColumnMetadataArgs\"\r\nimport { GeneratedMetadataArgs } from \"../../metadata-args/GeneratedMetadataArgs\"\r\nimport { ColumnOptions } from \"../options/ColumnOptions\"\r\nimport { ColumnType } from \"../../driver/types/ColumnTypes\"\r\n\r\n/**\r\n * Describes all primary key column's options.\r\n * If specified, the nullable field must be set to false.\r\n */\r\nexport type PrimaryColumnOptions = ColumnOptions & { nullable?: false }\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n * Primary columns also creates a PRIMARY KEY for this column in a db.\r\n */\r\nexport function PrimaryColumn(options?: PrimaryColumnOptions): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n * Primary columns also creates a PRIMARY KEY for this column in a db.\r\n */\r\nexport function PrimaryColumn(\r\n    type?: ColumnType,\r\n    options?: PrimaryColumnOptions,\r\n): PropertyDecorator\r\n\r\n/**\r\n * Column decorator is used to mark a specific class property as a table column.\r\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\r\n * Primary columns also creates a PRIMARY KEY for this column in a db.\r\n */\r\nexport function PrimaryColumn(\r\n    typeOrOptions?: ColumnType | PrimaryColumnOptions,\r\n    options?: PrimaryColumnOptions,\r\n): PropertyDecorator {\r\n    return function (object: Object, propertyName: string) {\r\n        // normalize parameters\r\n        let type: ColumnType | undefined\r\n        if (\r\n            typeof typeOrOptions === \"string\" ||\r\n            typeOrOptions === String ||\r\n            typeOrOptions === Boolean ||\r\n            typeOrOptions === Number\r\n        ) {\r\n            type = typeOrOptions as ColumnType\r\n        } else {\r\n            options = Object.assign({}, <PrimaryColumnOptions>typeOrOptions)\r\n        }\r\n        if (!options) options = {} as PrimaryColumnOptions\r\n\r\n        // if type is not given explicitly then try to guess it\r\n        const reflectMetadataType =\r\n            Reflect && (Reflect as any).getMetadata\r\n                ? (Reflect as any).getMetadata(\r\n                      \"design:type\",\r\n                      object,\r\n                      propertyName,\r\n                  )\r\n                : undefined\r\n        if (!type && reflectMetadataType) type = reflectMetadataType\r\n\r\n        // check if there is no type in column options then set type from first function argument, or guessed one\r\n        if (!options.type && type) options.type = type\r\n\r\n        // if we still don't have a type then we need to give error to user that type is required\r\n        if (!options.type)\r\n            throw new ColumnTypeUndefinedError(object, propertyName)\r\n\r\n        // check if column is not nullable, because we cannot allow a primary key to be nullable\r\n        if (options.nullable)\r\n            throw new PrimaryColumnCannotBeNullableError(object, propertyName)\r\n\r\n        // explicitly set a primary to column options\r\n        options.primary = true\r\n\r\n        // create and register a new column metadata\r\n        getMetadataArgsStorage().columns.push({\r\n            target: object.constructor,\r\n            propertyName: propertyName,\r\n            mode: \"regular\",\r\n            options: options,\r\n        } as ColumnMetadataArgs)\r\n\r\n        if (options.generated) {\r\n            getMetadataArgsStorage().generations.push({\r\n                target: object.constructor,\r\n                propertyName: propertyName,\r\n                strategy:\r\n                    typeof options.generated === \"string\"\r\n                        ? options.generated\r\n                        : \"increment\",\r\n            } as GeneratedMetadataArgs)\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}