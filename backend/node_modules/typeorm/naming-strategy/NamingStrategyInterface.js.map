{"version":3,"sources":["../../src/naming-strategy/NamingStrategyInterface.ts"],"names":[],"mappings":"","file":"NamingStrategyInterface.js","sourcesContent":["import { Table } from \"../schema-builder/table/Table\"\r\nimport { View } from \"../schema-builder/view/View\"\r\n\r\n/**\r\n * Naming strategy defines how auto-generated names for such things like table name, or table column gonna be\r\n * generated.\r\n */\r\nexport interface NamingStrategyInterface {\r\n    /**\r\n     * Naming strategy name.\r\n     */\r\n    name?: string\r\n\r\n    /**\r\n     * Normalizes table name.\r\n     *\r\n     * @param targetName Name of the target entity that can be used to generate a table name.\r\n     * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity(\"name\")\r\n     */\r\n    tableName(targetName: string, userSpecifiedName: string | undefined): string\r\n\r\n    /**\r\n     * Creates a table name for a junction table of a closure table.\r\n     *\r\n     * @param originalClosureTableName Name of the closure table which owns this junction table.\r\n     */\r\n    closureJunctionTableName(originalClosureTableName: string): string\r\n\r\n    /**\r\n     * Gets the table's column name from the given property name.\r\n     */\r\n    columnName(\r\n        propertyName: string,\r\n        customName: string | undefined,\r\n        embeddedPrefixes: string[],\r\n    ): string\r\n\r\n    /**\r\n     * Gets the table's relation name from the given property name.\r\n     */\r\n    relationName(propertyName: string): string\r\n\r\n    /**\r\n     * Gets the table's primary key name from the given table name and column names.\r\n     */\r\n    primaryKeyName(tableOrName: Table | string, columnNames: string[]): string\r\n\r\n    /**\r\n     * Gets the table's unique constraint name from the given table name and column names.\r\n     */\r\n    uniqueConstraintName(\r\n        tableOrName: Table | string,\r\n        columnNames: string[],\r\n    ): string\r\n\r\n    /**\r\n     * Gets the relation constraint (UNIQUE or UNIQUE INDEX) name from the given table name, column names\r\n     * and WHERE condition, if UNIQUE INDEX used.\r\n     */\r\n    relationConstraintName(\r\n        tableOrName: Table | string,\r\n        columnNames: string[],\r\n        where?: string,\r\n    ): string\r\n\r\n    /**\r\n     * Gets the table's default constraint name from the given table name and column name.\r\n     */\r\n    defaultConstraintName(\r\n        tableOrName: Table | string,\r\n        columnName: string,\r\n    ): string\r\n\r\n    /**\r\n     * Gets the name of the foreign key.\r\n     */\r\n    foreignKeyName(\r\n        tableOrName: Table | string,\r\n        columnNames: string[],\r\n        referencedTablePath?: string,\r\n        referencedColumnNames?: string[],\r\n    ): string\r\n\r\n    /**\r\n     * Gets the name of the index - simple and compose index.\r\n     */\r\n    indexName(\r\n        tableOrName: Table | View | string,\r\n        columns: string[],\r\n        where?: string,\r\n    ): string\r\n\r\n    /**\r\n     * Gets the name of the check constraint.\r\n     *\r\n     * \"isEnum\" parameter is used to indicate if this check constraint used\r\n     * to handle \"simple-enum\" type for databases that are not supporting \"enum\"\r\n     * type out of the box. If \"true\", constraint is ignored during CHECK constraints\r\n     * synchronization.\r\n     */\r\n    checkConstraintName(\r\n        tableOrName: Table | string,\r\n        expression: string,\r\n        isEnum?: boolean,\r\n    ): string\r\n\r\n    /**\r\n     * Gets the name of the exclusion constraint.\r\n     */\r\n    exclusionConstraintName(\r\n        tableOrName: Table | string,\r\n        expression: string,\r\n    ): string\r\n\r\n    /**\r\n     * Gets the name of the join column used in the one-to-one and many-to-one relations.\r\n     */\r\n    joinColumnName(relationName: string, referencedColumnName: string): string\r\n\r\n    /**\r\n     * Gets the name of the join table used in the many-to-many relations.\r\n     */\r\n    joinTableName(\r\n        firstTableName: string,\r\n        secondTableName: string,\r\n        firstPropertyName: string,\r\n        secondPropertyName: string,\r\n    ): string\r\n\r\n    /**\r\n     * Columns in join tables can have duplicate names in case of self-referencing.\r\n     * This method provide a resolution for such column names.\r\n     */\r\n    joinTableColumnDuplicationPrefix(columnName: string, index: number): string\r\n\r\n    /**\r\n     * Gets the name of the column used for columns in the junction tables.\r\n     *\r\n     * The reverse?:boolean parameter denotes if the joinTableColumnName is called for the junctionColumn (false)\r\n     * or the inverseJunctionColumns (true)\r\n     */\r\n    joinTableColumnName(\r\n        tableName: string,\r\n        propertyName: string,\r\n        columnName?: string,\r\n    ): string\r\n\r\n    /**\r\n     * Gets the name of the column used for columns in the junction tables from the invers side of the relationship.\r\n     */\r\n    joinTableInverseColumnName(\r\n        tableName: string,\r\n        propertyName: string,\r\n        columnName?: string,\r\n    ): string\r\n\r\n    /**\r\n     * Adds globally set prefix to the table name.\r\n     * This method is executed no matter if prefix was set or not.\r\n     * Table name is either user's given table name, either name generated from entity target.\r\n     * Note that table name comes here already normalized by #tableName method.\r\n     */\r\n    prefixTableName(prefix: string, tableName: string): string\r\n\r\n    /**\r\n     * Column names for nested sets.\r\n     */\r\n    nestedSetColumnNames: { left: string; right: string }\r\n\r\n    /**\r\n     * Column name for materialized paths.\r\n     */\r\n    materializedPathColumnName: string\r\n}\r\n"],"sourceRoot":".."}