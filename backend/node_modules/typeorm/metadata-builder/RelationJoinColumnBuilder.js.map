{"version":3,"sources":["../../src/metadata-builder/RelationJoinColumnBuilder.ts"],"names":[],"mappings":"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","file":"RelationJoinColumnBuilder.js","sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\r\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\"\r\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\r\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\r\nimport { JoinColumnMetadataArgs } from \"../metadata-args/JoinColumnMetadataArgs\"\r\nimport { DataSource } from \"../data-source/DataSource\"\r\nimport { TypeORMError } from \"../error\"\r\nimport { DriverUtils } from \"../driver/DriverUtils\"\r\n\r\n/**\r\n * Builds join column for the many-to-one and one-to-one owner relations.\r\n *\r\n * Cases it should cover:\r\n * 1. when join column is set with custom name and without referenced column name\r\n * we need automatically set referenced column name - primary ids by default\r\n * @JoinColumn({ name: \"custom_name\" })\r\n *\r\n * 2. when join column is set with only referenced column name\r\n * we need automatically set join column name - relation name + referenced column name\r\n * @JoinColumn({ referencedColumnName: \"title\" })\r\n *\r\n * 3. when join column is set without both referenced column name and join column name\r\n * we need to automatically set both of them\r\n * @JoinColumn()\r\n *\r\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\r\n * we need to create join column for it with proper referenced column name and join column name\r\n *\r\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\r\n * both options are required\r\n * @JoinColumn([\r\n *      { name: \"category_title\", referencedColumnName: \"type\" },\r\n *      { name: \"category_title\", referencedColumnName: \"name\" },\r\n * ])\r\n *\r\n * Since for many-to-one relations having JoinColumn decorator is not required,\r\n * we need to go through each many-to-one relation without join column decorator set\r\n * and create join column metadata args for them.\r\n */\r\nexport class RelationJoinColumnBuilder {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private connection: DataSource) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\r\n     */\r\n    build(\r\n        joinColumns: JoinColumnMetadataArgs[],\r\n        relation: RelationMetadata,\r\n    ): {\r\n        foreignKey: ForeignKeyMetadata | undefined\r\n        columns: ColumnMetadata[]\r\n        uniqueConstraint: UniqueMetadata | undefined\r\n    } {\r\n        const referencedColumns = this.collectReferencedColumns(\r\n            joinColumns,\r\n            relation,\r\n        )\r\n        const columns = this.collectColumns(\r\n            joinColumns,\r\n            relation,\r\n            referencedColumns,\r\n        )\r\n        if (!referencedColumns.length || !relation.createForeignKeyConstraints)\r\n            return {\r\n                foreignKey: undefined,\r\n                columns,\r\n                uniqueConstraint: undefined,\r\n            } // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\r\n\r\n        const foreignKey = new ForeignKeyMetadata({\r\n            name: joinColumns[0]?.foreignKeyConstraintName,\r\n            entityMetadata: relation.entityMetadata,\r\n            referencedEntityMetadata: relation.inverseEntityMetadata,\r\n            namingStrategy: this.connection.namingStrategy,\r\n            columns,\r\n            referencedColumns,\r\n            onDelete: relation.onDelete,\r\n            onUpdate: relation.onUpdate,\r\n            deferrable: relation.deferrable,\r\n        })\r\n\r\n        // SQL requires UNIQUE/PK constraints on columns referenced by a FK\r\n        // Skip creating the unique constraint for the referenced columns if\r\n        // they are already contained in the PK of the referenced entity\r\n        if (\r\n            columns.every((column) => column.isPrimary) ||\r\n            !relation.isOneToOne\r\n        ) {\r\n            return { foreignKey, columns, uniqueConstraint: undefined }\r\n        }\r\n\r\n        const uniqueConstraint = new UniqueMetadata({\r\n            entityMetadata: relation.entityMetadata,\r\n            columns: foreignKey.columns,\r\n            args: {\r\n                name: this.connection.namingStrategy.relationConstraintName(\r\n                    relation.entityMetadata.tableName,\r\n                    foreignKey.columns.map((column) => column.databaseName),\r\n                ),\r\n                target: relation.entityMetadata.target,\r\n            },\r\n        })\r\n        uniqueConstraint.build(this.connection.namingStrategy)\r\n\r\n        return { foreignKey, columns, uniqueConstraint }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Collects referenced columns from the given join column args.\r\n     */\r\n    protected collectReferencedColumns(\r\n        joinColumns: JoinColumnMetadataArgs[],\r\n        relation: RelationMetadata,\r\n    ): ColumnMetadata[] {\r\n        const hasAnyReferencedColumnName = joinColumns.find(\r\n            (joinColumnArgs) => !!joinColumnArgs.referencedColumnName,\r\n        )\r\n        const manyToOneWithoutJoinColumn =\r\n            joinColumns.length === 0 && relation.isManyToOne\r\n        const hasJoinColumnWithoutAnyReferencedColumnName =\r\n            joinColumns.length > 0 && !hasAnyReferencedColumnName\r\n\r\n        if (\r\n            manyToOneWithoutJoinColumn ||\r\n            hasJoinColumnWithoutAnyReferencedColumnName\r\n        ) {\r\n            // covers case3 and case1\r\n            return relation.inverseEntityMetadata.primaryColumns\r\n        } else {\r\n            // cases with referenced columns defined\r\n            return joinColumns.map((joinColumn) => {\r\n                const referencedColumn =\r\n                    relation.inverseEntityMetadata.ownColumns.find(\r\n                        (column) =>\r\n                            column.propertyName ===\r\n                            joinColumn.referencedColumnName,\r\n                    ) // todo: can we also search in relations?\r\n                if (!referencedColumn)\r\n                    throw new TypeORMError(\r\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`,\r\n                    )\r\n\r\n                return referencedColumn\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collects columns from the given join column args.\r\n     */\r\n    private collectColumns(\r\n        joinColumns: JoinColumnMetadataArgs[],\r\n        relation: RelationMetadata,\r\n        referencedColumns: ColumnMetadata[],\r\n    ): ColumnMetadata[] {\r\n        return referencedColumns.map((referencedColumn) => {\r\n            // in the case if relation has join column with only name set we need this check\r\n            const joinColumnMetadataArg = joinColumns.find((joinColumn) => {\r\n                return (\r\n                    (!joinColumn.referencedColumnName ||\r\n                        joinColumn.referencedColumnName ===\r\n                            referencedColumn.propertyName) &&\r\n                    !!joinColumn.name\r\n                )\r\n            })\r\n            const joinColumnName = joinColumnMetadataArg\r\n                ? joinColumnMetadataArg.name\r\n                : this.connection.namingStrategy.joinColumnName(\r\n                      relation.propertyName,\r\n                      referencedColumn.propertyName,\r\n                  )\r\n\r\n            const relationalColumns = relation.embeddedMetadata\r\n                ? relation.embeddedMetadata.columns\r\n                : relation.entityMetadata.ownColumns\r\n            let relationalColumn = relationalColumns.find(\r\n                (column) =>\r\n                    column.databaseNameWithoutPrefixes === joinColumnName,\r\n            )\r\n            if (!relationalColumn) {\r\n                relationalColumn = new ColumnMetadata({\r\n                    connection: this.connection,\r\n                    entityMetadata: relation.entityMetadata,\r\n                    embeddedMetadata: relation.embeddedMetadata,\r\n                    args: {\r\n                        target: \"\",\r\n                        mode: \"virtual\",\r\n                        propertyName: relation.propertyName,\r\n                        options: {\r\n                            name: joinColumnName,\r\n                            type: referencedColumn.type,\r\n                            length:\r\n                                !referencedColumn.length &&\r\n                                (DriverUtils.isMySQLFamily(\r\n                                    this.connection.driver,\r\n                                ) ||\r\n                                    this.connection.driver.options.type ===\r\n                                        \"aurora-mysql\") &&\r\n                                // some versions of mariadb support the column type and should not try to provide the length property\r\n                                this.connection.driver.normalizeType(\r\n                                    referencedColumn,\r\n                                ) !== \"uuid\" &&\r\n                                (referencedColumn.generationStrategy ===\r\n                                    \"uuid\" ||\r\n                                    referencedColumn.type === \"uuid\")\r\n                                    ? \"36\"\r\n                                    : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\r\n                            width: referencedColumn.width,\r\n                            charset: referencedColumn.charset,\r\n                            collation: referencedColumn.collation,\r\n                            precision: referencedColumn.precision,\r\n                            scale: referencedColumn.scale,\r\n                            zerofill: referencedColumn.zerofill,\r\n                            unsigned: referencedColumn.unsigned,\r\n                            comment: referencedColumn.comment,\r\n                            enum: referencedColumn.enum,\r\n                            enumName: referencedColumn.enumName,\r\n                            primary: relation.isPrimary,\r\n                            nullable: relation.isNullable,\r\n                        },\r\n                    },\r\n                })\r\n                relation.entityMetadata.registerColumn(relationalColumn)\r\n            }\r\n            relationalColumn.referencedColumn = referencedColumn // its important to set it here because we need to set referenced column for user defined join column\r\n            relationalColumn.type = referencedColumn.type // also since types of relational column and join column must be equal we override user defined column type\r\n            relationalColumn.relationMetadata = relation\r\n            relationalColumn.build(this.connection)\r\n            return relationalColumn\r\n        })\r\n    }\r\n}\r\n"],"sourceRoot":".."}