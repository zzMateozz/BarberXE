{"version":3,"sources":["../../src/data-source/DataSource.ts"],"names":[],"mappings":"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","file":"DataSource.js","sourcesContent":["import { Driver } from \"../driver/Driver\"\r\nimport { registerQueryBuilders } from \"../query-builder\"\r\nimport { Repository } from \"../repository/Repository\"\r\nimport { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"\r\nimport { EntityTarget } from \"../common/EntityTarget\"\r\nimport { ObjectType } from \"../common/ObjectType\"\r\nimport { EntityManager } from \"../entity-manager/EntityManager\"\r\nimport { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\"\r\nimport {\r\n    CannotConnectAlreadyConnectedError,\r\n    CannotExecuteNotConnectedError,\r\n    EntityMetadataNotFoundError,\r\n    QueryRunnerProviderAlreadyReleasedError,\r\n    TypeORMError,\r\n} from \"../error\"\r\nimport { TreeRepository } from \"../repository/TreeRepository\"\r\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\r\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\r\nimport { Logger } from \"../logger/Logger\"\r\nimport { MigrationInterface } from \"../migration/MigrationInterface\"\r\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\"\r\nimport { Migration } from \"../migration/Migration\"\r\nimport { MongoRepository } from \"../repository/MongoRepository\"\r\nimport { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"\r\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\"\r\nimport { DataSourceOptions } from \"./DataSourceOptions\"\r\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\"\r\nimport { DriverFactory } from \"../driver/DriverFactory\"\r\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\"\r\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\r\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\r\nimport { LoggerFactory } from \"../logger/LoggerFactory\"\r\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\"\r\nimport { QueryResultCache } from \"../cache/QueryResultCache\"\r\nimport { SqljsEntityManager } from \"../entity-manager/SqljsEntityManager\"\r\nimport { RelationLoader } from \"../query-builder/RelationLoader\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\nimport { IsolationLevel } from \"../driver/types/IsolationLevel\"\r\nimport { ReplicationMode } from \"../driver/types/ReplicationMode\"\r\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\"\r\nimport { DriverUtils } from \"../driver/DriverUtils\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\r\n\r\nregisterQueryBuilders()\r\n\r\n/**\r\n * DataSource is a pre-defined connection configuration to a specific database.\r\n * You can have multiple data sources connected (with multiple connections in it),\r\n * connected to multiple databases in your application.\r\n *\r\n * Before, it was called `Connection`, but now `Connection` is deprecated\r\n * because `Connection` isn't the best name for what it's actually is.\r\n */\r\nexport class DataSource {\r\n    readonly \"@instanceof\" = Symbol.for(\"DataSource\")\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Readonly Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Connection name.\r\n     *\r\n     * @deprecated we don't need names anymore since we are going to drop all related methods relying on this property.\r\n     */\r\n    readonly name: string\r\n\r\n    /**\r\n     * Connection options.\r\n     */\r\n    readonly options: DataSourceOptions\r\n\r\n    /**\r\n     * Indicates if DataSource is initialized or not.\r\n     */\r\n    readonly isInitialized: boolean\r\n\r\n    /**\r\n     * Database driver used by this connection.\r\n     */\r\n    driver: Driver\r\n\r\n    /**\r\n     * EntityManager of this connection.\r\n     */\r\n    readonly manager: EntityManager\r\n\r\n    /**\r\n     * Naming strategy used in the connection.\r\n     */\r\n    namingStrategy: NamingStrategyInterface\r\n\r\n    /**\r\n     * Name for the metadata table\r\n     */\r\n    readonly metadataTableName: string\r\n\r\n    /**\r\n     * Logger used to log orm events.\r\n     */\r\n    logger: Logger\r\n\r\n    /**\r\n     * Migration instances that are registered for this connection.\r\n     */\r\n    readonly migrations: MigrationInterface[] = []\r\n\r\n    /**\r\n     * Entity subscriber instances that are registered for this connection.\r\n     */\r\n    readonly subscribers: EntitySubscriberInterface<any>[] = []\r\n\r\n    /**\r\n     * All entity metadatas that are registered for this connection.\r\n     */\r\n    readonly entityMetadatas: EntityMetadata[] = []\r\n\r\n    /**\r\n     * All entity metadatas that are registered for this connection.\r\n     * This is a copy of #.entityMetadatas property -> used for more performant searches.\r\n     */\r\n    readonly entityMetadatasMap = new Map<EntityTarget<any>, EntityMetadata>()\r\n\r\n    /**\r\n     * Used to work with query result cache.\r\n     */\r\n    queryResultCache?: QueryResultCache\r\n\r\n    /**\r\n     * Used to load relations and work with lazy relations.\r\n     */\r\n    readonly relationLoader: RelationLoader\r\n\r\n    readonly relationIdLoader: RelationIdLoader\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(options: DataSourceOptions) {\r\n        registerQueryBuilders()\r\n        this.name = options.name || \"default\"\r\n        this.options = options\r\n        this.logger = new LoggerFactory().create(\r\n            this.options.logger,\r\n            this.options.logging,\r\n        )\r\n        this.driver = new DriverFactory().create(this)\r\n        this.manager = this.createEntityManager()\r\n        this.namingStrategy =\r\n            options.namingStrategy || new DefaultNamingStrategy()\r\n        this.metadataTableName = options.metadataTableName || \"typeorm_metadata\"\r\n        this.queryResultCache = options.cache\r\n            ? new QueryResultCacheFactory(this).create()\r\n            : undefined\r\n        this.relationLoader = new RelationLoader(this)\r\n        this.relationIdLoader = new RelationIdLoader(this)\r\n        this.isInitialized = false\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Accessors\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     Indicates if DataSource is initialized or not.\r\n     *\r\n     * @deprecated use .isInitialized instead\r\n     */\r\n    get isConnected() {\r\n        return this.isInitialized\r\n    }\r\n\r\n    /**\r\n     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\r\n     * with any entity in this connection.\r\n     *\r\n     * Available only in mongodb connections.\r\n     */\r\n    get mongoManager(): MongoEntityManager {\r\n        if (!InstanceChecker.isMongoEntityManager(this.manager))\r\n            throw new TypeORMError(\r\n                `MongoEntityManager is only available for MongoDB databases.`,\r\n            )\r\n\r\n        return this.manager as MongoEntityManager\r\n    }\r\n\r\n    /**\r\n     * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\r\n     *\r\n     * Available only in connection with the sqljs driver.\r\n     */\r\n    get sqljsManager(): SqljsEntityManager {\r\n        if (!InstanceChecker.isSqljsEntityManager(this.manager))\r\n            throw new TypeORMError(\r\n                `SqljsEntityManager is only available for Sqljs databases.`,\r\n            )\r\n\r\n        return this.manager\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n    /**\r\n     * Updates current connection options with provided options.\r\n     */\r\n    setOptions(options: Partial<DataSourceOptions>): this {\r\n        Object.assign(this.options, options)\r\n\r\n        if (options.logger || options.logging) {\r\n            this.logger = new LoggerFactory().create(\r\n                options.logger || this.options.logger,\r\n                options.logging || this.options.logging,\r\n            )\r\n        }\r\n\r\n        if (options.namingStrategy) {\r\n            this.namingStrategy = options.namingStrategy\r\n        }\r\n\r\n        if (options.cache) {\r\n            this.queryResultCache = new QueryResultCacheFactory(this).create()\r\n        }\r\n\r\n        // todo: we must update the database in the driver as well, if it was set by setOptions method\r\n        //  in the future we need to refactor the code and remove \"database\" from the driver, and instead\r\n        //  use database (and options) from a single place - data source.\r\n        if (options.database) {\r\n            this.driver.database = DriverUtils.buildDriverOptions(\r\n                this.options,\r\n            ).database\r\n        }\r\n\r\n        // todo: need to take a look if we need to update schema and other \"poor\" properties\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Performs connection to the database.\r\n     * This method should be called once on application bootstrap.\r\n     * This method not necessarily creates database connection (depend on database type),\r\n     * but it also can setup a connection pool with database to use.\r\n     */\r\n    async initialize(): Promise<this> {\r\n        if (this.isInitialized)\r\n            throw new CannotConnectAlreadyConnectedError(this.name)\r\n\r\n        // connect to the database via its driver\r\n        await this.driver.connect()\r\n\r\n        // connect to the cache-specific database if cache is enabled\r\n        if (this.queryResultCache) await this.queryResultCache.connect()\r\n\r\n        // set connected status for the current connection\r\n        ObjectUtils.assign(this, { isInitialized: true })\r\n\r\n        try {\r\n            // build all metadatas registered in the current connection\r\n            await this.buildMetadatas()\r\n\r\n            await this.driver.afterConnect()\r\n\r\n            // if option is set - drop schema once connection is done\r\n            if (this.options.dropSchema) await this.dropDatabase()\r\n\r\n            // if option is set - automatically synchronize a schema\r\n            if (this.options.migrationsRun)\r\n                await this.runMigrations({\r\n                    transaction: this.options.migrationsTransactionMode,\r\n                })\r\n\r\n            // if option is set - automatically synchronize a schema\r\n            if (this.options.synchronize) await this.synchronize()\r\n        } catch (error) {\r\n            // if for some reason build metadata fail (for example validation error during entity metadata check)\r\n            // connection needs to be closed\r\n            await this.destroy()\r\n            throw error\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Performs connection to the database.\r\n     * This method should be called once on application bootstrap.\r\n     * This method not necessarily creates database connection (depend on database type),\r\n     * but it also can setup a connection pool with database to use.\r\n     *\r\n     * @deprecated use .initialize method instead\r\n     */\r\n    async connect(): Promise<this> {\r\n        return this.initialize()\r\n    }\r\n\r\n    /**\r\n     * Closes connection with the database.\r\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\r\n     */\r\n    async destroy(): Promise<void> {\r\n        if (!this.isInitialized)\r\n            throw new CannotExecuteNotConnectedError(this.name)\r\n\r\n        await this.driver.disconnect()\r\n\r\n        // disconnect from the cache-specific database if cache was enabled\r\n        if (this.queryResultCache) await this.queryResultCache.disconnect()\r\n\r\n        ObjectUtils.assign(this, { isInitialized: false })\r\n    }\r\n\r\n    /**\r\n     * Closes connection with the database.\r\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\r\n     *\r\n     * @deprecated use .destroy method instead\r\n     */\r\n    async close(): Promise<void> {\r\n        return this.destroy()\r\n    }\r\n\r\n    /**\r\n     * Creates database schema for all entities registered in this connection.\r\n     * Can be used only after connection to the database is established.\r\n     *\r\n     * @param dropBeforeSync If set to true then it drops the database with all its tables and data\r\n     */\r\n    async synchronize(dropBeforeSync: boolean = false): Promise<void> {\r\n        if (!this.isInitialized)\r\n            throw new CannotExecuteNotConnectedError(this.name)\r\n\r\n        if (dropBeforeSync) await this.dropDatabase()\r\n\r\n        const schemaBuilder = this.driver.createSchemaBuilder()\r\n        await schemaBuilder.build()\r\n    }\r\n\r\n    /**\r\n     * Drops the database and all its data.\r\n     * Be careful with this method on production since this method will erase all your database tables and their data.\r\n     * Can be used only after connection to the database is established.\r\n     */\r\n    // TODO rename\r\n    async dropDatabase(): Promise<void> {\r\n        const queryRunner = this.createQueryRunner()\r\n        try {\r\n            if (\r\n                this.driver.options.type === \"mssql\" ||\r\n                DriverUtils.isMySQLFamily(this.driver) ||\r\n                this.driver.options.type === \"aurora-mysql\" ||\r\n                DriverUtils.isSQLiteFamily(this.driver)\r\n            ) {\r\n                const databases: string[] = []\r\n                this.entityMetadatas.forEach((metadata) => {\r\n                    if (\r\n                        metadata.database &&\r\n                        databases.indexOf(metadata.database) === -1\r\n                    )\r\n                        databases.push(metadata.database)\r\n                })\r\n                if (databases.length === 0 && this.driver.database) {\r\n                    databases.push(this.driver.database)\r\n                }\r\n\r\n                if (databases.length === 0) {\r\n                    await queryRunner.clearDatabase()\r\n                } else {\r\n                    for (const database of databases) {\r\n                        await queryRunner.clearDatabase(database)\r\n                    }\r\n                }\r\n            } else {\r\n                await queryRunner.clearDatabase()\r\n            }\r\n        } finally {\r\n            await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs all pending migrations.\r\n     * Can be used only after connection to the database is established.\r\n     */\r\n    async runMigrations(options?: {\r\n        transaction?: \"all\" | \"none\" | \"each\"\r\n        fake?: boolean\r\n    }): Promise<Migration[]> {\r\n        if (!this.isInitialized)\r\n            throw new CannotExecuteNotConnectedError(this.name)\r\n\r\n        const migrationExecutor = new MigrationExecutor(this)\r\n        migrationExecutor.transaction =\r\n            options?.transaction ||\r\n            this.options?.migrationsTransactionMode ||\r\n            \"all\"\r\n        migrationExecutor.fake = (options && options.fake) || false\r\n\r\n        const successMigrations =\r\n            await migrationExecutor.executePendingMigrations()\r\n        return successMigrations\r\n    }\r\n\r\n    /**\r\n     * Reverts last executed migration.\r\n     * Can be used only after connection to the database is established.\r\n     */\r\n    async undoLastMigration(options?: {\r\n        transaction?: \"all\" | \"none\" | \"each\"\r\n        fake?: boolean\r\n    }): Promise<void> {\r\n        if (!this.isInitialized)\r\n            throw new CannotExecuteNotConnectedError(this.name)\r\n\r\n        const migrationExecutor = new MigrationExecutor(this)\r\n        migrationExecutor.transaction =\r\n            (options && options.transaction) || \"all\"\r\n        migrationExecutor.fake = (options && options.fake) || false\r\n\r\n        await migrationExecutor.undoLastMigration()\r\n    }\r\n\r\n    /**\r\n     * Lists all migrations and whether they have been run.\r\n     * Returns true if there are pending migrations\r\n     */\r\n    async showMigrations(): Promise<boolean> {\r\n        if (!this.isInitialized) {\r\n            throw new CannotExecuteNotConnectedError(this.name)\r\n        }\r\n        const migrationExecutor = new MigrationExecutor(this)\r\n        return await migrationExecutor.showMigrations()\r\n    }\r\n\r\n    /**\r\n     * Checks if entity metadata exist for the given entity class, target name or table name.\r\n     */\r\n    hasMetadata(target: EntityTarget<any>): boolean {\r\n        return !!this.findMetadata(target)\r\n    }\r\n\r\n    /**\r\n     * Gets entity metadata for the given entity class or schema name.\r\n     */\r\n    getMetadata(target: EntityTarget<any>): EntityMetadata {\r\n        const metadata = this.findMetadata(target)\r\n        if (!metadata) throw new EntityMetadataNotFoundError(target)\r\n\r\n        return metadata\r\n    }\r\n\r\n    /**\r\n     * Gets repository for the given entity.\r\n     */\r\n    getRepository<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n    ): Repository<Entity> {\r\n        return this.manager.getRepository(target)\r\n    }\r\n\r\n    /**\r\n     * Gets tree repository for the given entity class or name.\r\n     * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\r\n     */\r\n    getTreeRepository<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n    ): TreeRepository<Entity> {\r\n        return this.manager.getTreeRepository(target)\r\n    }\r\n\r\n    /**\r\n     * Gets mongodb-specific repository for the given entity class or name.\r\n     * Works only if connection is mongodb-specific.\r\n     */\r\n    getMongoRepository<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n    ): MongoRepository<Entity> {\r\n        if (!(this.driver.options.type === \"mongodb\"))\r\n            throw new TypeORMError(\r\n                `You can use getMongoRepository only for MongoDB connections.`,\r\n            )\r\n\r\n        return this.manager.getRepository(target) as any\r\n    }\r\n\r\n    /**\r\n     * Gets custom entity repository marked with @EntityRepository decorator.\r\n     *\r\n     * @deprecated use Repository.extend function to create a custom repository\r\n     */\r\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\r\n        return this.manager.getCustomRepository(customRepository)\r\n    }\r\n\r\n    /**\r\n     * Wraps given function execution (and all operations made there) into a transaction.\r\n     * All database operations must be executed using provided entity manager.\r\n     */\r\n    async transaction<T>(\r\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\r\n    ): Promise<T>\r\n    async transaction<T>(\r\n        isolationLevel: IsolationLevel,\r\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\r\n    ): Promise<T>\r\n    async transaction<T>(\r\n        isolationOrRunInTransaction:\r\n            | IsolationLevel\r\n            | ((entityManager: EntityManager) => Promise<T>),\r\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>,\r\n    ): Promise<any> {\r\n        return this.manager.transaction(\r\n            isolationOrRunInTransaction as any,\r\n            runInTransactionParam as any,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Executes raw SQL query and returns raw database results.\r\n     * \r\n     * @see [Official docs](https://typeorm.io/data-source-api) for examples.\r\n     */\r\n    async query<T = any>(\r\n        query: string,\r\n        parameters?: any[],\r\n        queryRunner?: QueryRunner,\r\n    ): Promise<T> {\r\n        if (InstanceChecker.isMongoEntityManager(this.manager))\r\n            throw new TypeORMError(`Queries aren't supported by MongoDB.`)\r\n\r\n        if (queryRunner && queryRunner.isReleased)\r\n            throw new QueryRunnerProviderAlreadyReleasedError()\r\n\r\n        const usedQueryRunner = queryRunner || this.createQueryRunner()\r\n\r\n        try {\r\n            return await usedQueryRunner.query(query, parameters) // await is needed here because we are using finally\r\n        } finally {\r\n            if (!queryRunner) await usedQueryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new query builder that can be used to build a SQL query.\r\n     */\r\n    createQueryBuilder<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        alias: string,\r\n        queryRunner?: QueryRunner,\r\n    ): SelectQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates a new query builder that can be used to build a SQL query.\r\n     */\r\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>\r\n\r\n    /**\r\n     * Creates a new query builder that can be used to build a SQL query.\r\n     */\r\n    createQueryBuilder<Entity extends ObjectLiteral>(\r\n        entityOrRunner?: EntityTarget<Entity> | QueryRunner,\r\n        alias?: string,\r\n        queryRunner?: QueryRunner,\r\n    ): SelectQueryBuilder<Entity> {\r\n        if (InstanceChecker.isMongoEntityManager(this.manager))\r\n            throw new TypeORMError(`Query Builder is not supported by MongoDB.`)\r\n\r\n        if (alias) {\r\n            alias = DriverUtils.buildAlias(this.driver, undefined, alias)\r\n            const metadata = this.getMetadata(\r\n                entityOrRunner as EntityTarget<Entity>,\r\n            )\r\n            return new SelectQueryBuilder(this, queryRunner)\r\n                .select(alias)\r\n                .from(metadata.target, alias)\r\n        } else {\r\n            return new SelectQueryBuilder(\r\n                this,\r\n                entityOrRunner as QueryRunner | undefined,\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a query runner used for perform queries on a single database connection.\r\n     * Using query runners you can control your queries to execute using single database connection and\r\n     * manually control your database transaction.\r\n     *\r\n     * Mode is used in replication mode and indicates whatever you want to connect\r\n     * to master database or any of slave databases.\r\n     * If you perform writes you must use master database,\r\n     * if you perform reads you can use slave databases.\r\n     */\r\n    createQueryRunner(mode: ReplicationMode = \"master\"): QueryRunner {\r\n        const queryRunner = this.driver.createQueryRunner(mode)\r\n        const manager = this.createEntityManager(queryRunner)\r\n        Object.assign(queryRunner, { manager: manager })\r\n        return queryRunner\r\n    }\r\n\r\n    /**\r\n     * Gets entity metadata of the junction table (many-to-many table).\r\n     */\r\n    getManyToManyMetadata(\r\n        entityTarget: EntityTarget<any>,\r\n        relationPropertyPath: string,\r\n    ) {\r\n        const relationMetadata =\r\n            this.getMetadata(entityTarget).findRelationWithPropertyPath(\r\n                relationPropertyPath,\r\n            )\r\n        if (!relationMetadata)\r\n            throw new TypeORMError(\r\n                `Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`,\r\n            )\r\n        if (!relationMetadata.isManyToMany)\r\n            throw new TypeORMError(\r\n                `Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` +\r\n                    `You can use this method only on many-to-many relations.`,\r\n            )\r\n\r\n        return relationMetadata.junctionEntityMetadata\r\n    }\r\n\r\n    /**\r\n     * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\r\n     */\r\n    createEntityManager(queryRunner?: QueryRunner): EntityManager {\r\n        return new EntityManagerFactory().create(this, queryRunner)\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Finds exist entity metadata by the given entity class, target name or table name.\r\n     */\r\n    protected findMetadata(\r\n        target: EntityTarget<any>,\r\n    ): EntityMetadata | undefined {\r\n        const metadataFromMap = this.entityMetadatasMap.get(target)\r\n        if (metadataFromMap) return metadataFromMap\r\n\r\n        for (let [_, metadata] of this.entityMetadatasMap) {\r\n            if (\r\n                InstanceChecker.isEntitySchema(target) &&\r\n                metadata.name === target.options.name\r\n            ) {\r\n                return metadata\r\n            }\r\n            if (typeof target === \"string\") {\r\n                if (target.indexOf(\".\") !== -1) {\r\n                    if (metadata.tablePath === target) {\r\n                        return metadata\r\n                    }\r\n                } else {\r\n                    if (\r\n                        metadata.name === target ||\r\n                        metadata.tableName === target\r\n                    ) {\r\n                        return metadata\r\n                    }\r\n                }\r\n            }\r\n            if (\r\n                ObjectUtils.isObjectWithName(target) &&\r\n                typeof target.name === \"string\"\r\n            ) {\r\n                if (target.name.indexOf(\".\") !== -1) {\r\n                    if (metadata.tablePath === target.name) {\r\n                        return metadata\r\n                    }\r\n                } else {\r\n                    if (\r\n                        metadata.name === target.name ||\r\n                        metadata.tableName === target.name\r\n                    ) {\r\n                        return metadata\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined\r\n    }\r\n\r\n    /**\r\n     * Builds metadatas for all registered classes inside this connection.\r\n     */\r\n    protected async buildMetadatas(): Promise<void> {\r\n        const connectionMetadataBuilder = new ConnectionMetadataBuilder(this)\r\n        const entityMetadataValidator = new EntityMetadataValidator()\r\n\r\n        // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\r\n        const flattenedSubscribers = ObjectUtils.mixedListToArray(\r\n            this.options.subscribers || [],\r\n        )\r\n        const subscribers = await connectionMetadataBuilder.buildSubscribers(\r\n            flattenedSubscribers,\r\n        )\r\n        ObjectUtils.assign(this, { subscribers: subscribers })\r\n\r\n        // build entity metadatas\r\n        const flattenedEntities = ObjectUtils.mixedListToArray(\r\n            this.options.entities || [],\r\n        )\r\n        const entityMetadatas =\r\n            await connectionMetadataBuilder.buildEntityMetadatas(\r\n                flattenedEntities,\r\n            )\r\n        ObjectUtils.assign(this, {\r\n            entityMetadatas: entityMetadatas,\r\n            entityMetadatasMap: new Map(\r\n                entityMetadatas.map((metadata) => [metadata.target, metadata]),\r\n            ),\r\n        })\r\n\r\n        // create migration instances\r\n        const flattenedMigrations = ObjectUtils.mixedListToArray(\r\n            this.options.migrations || [],\r\n        )\r\n        const migrations = await connectionMetadataBuilder.buildMigrations(\r\n            flattenedMigrations,\r\n        )\r\n        ObjectUtils.assign(this, { migrations: migrations })\r\n\r\n        // validate all created entity metadatas to make sure user created entities are valid and correct\r\n        entityMetadataValidator.validateMany(\r\n            this.entityMetadatas.filter(\r\n                (metadata) => metadata.tableType !== \"view\",\r\n            ),\r\n            this.driver,\r\n        )\r\n\r\n        // set current data source to the entities\r\n        for (let entityMetadata of entityMetadatas) {\r\n            if (\r\n                InstanceChecker.isBaseEntityConstructor(entityMetadata.target)\r\n            ) {\r\n                entityMetadata.target.useDataSource(this)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the replication mode SELECT queries should use for this datasource by default\r\n     */\r\n    defaultReplicationModeForReads(): ReplicationMode {\r\n        if (\"replication\" in this.driver.options) {\r\n            const value = (\r\n                this.driver.options.replication as {\r\n                    defaultMode?: ReplicationMode\r\n                }\r\n            ).defaultMode\r\n            if (value) {\r\n                return value\r\n            }\r\n        }\r\n        return \"slave\"\r\n    }\r\n}\r\n"],"sourceRoot":".."}