{"version":3,"sources":["../../src/persistence/subject-builder/CascadesSubjectBuilder.ts"],"names":[],"mappings":"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","file":"CascadesSubjectBuilder.js","sourcesContent":["import { Subject } from \"../Subject\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\r\n\r\n/**\r\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\r\n * e.g. builds a cascade tree and creates a subjects for them.\r\n */\r\nexport class CascadesSubjectBuilder {\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(protected allSubjects: Subject[]) {}\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\r\n     */\r\n    build(\r\n        subject: Subject,\r\n        operationType: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\r\n    ) {\r\n        subject.metadata\r\n            .extractRelationValuesFromEntity(\r\n                subject.entity!,\r\n                subject.metadata.relations,\r\n            ) // todo: we can create EntityMetadata.cascadeRelations\r\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\r\n                // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\r\n                if (\r\n                    relationEntity === undefined ||\r\n                    relationEntity === null ||\r\n                    (!relation.isCascadeInsert &&\r\n                        !relation.isCascadeUpdate &&\r\n                        !relation.isCascadeSoftRemove &&\r\n                        !relation.isCascadeRecover)\r\n                )\r\n                    return\r\n\r\n                // if relation entity is just a relation id set (for example post.tag = 1)\r\n                // then we don't really need to check cascades since there is no object to insert or update\r\n                if (!ObjectUtils.isObject(relationEntity)) return\r\n\r\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\r\n                const alreadyExistRelationEntitySubject =\r\n                    this.findByPersistEntityLike(\r\n                        relationEntityMetadata.target,\r\n                        relationEntity,\r\n                    )\r\n                if (alreadyExistRelationEntitySubject) {\r\n                    if (\r\n                        alreadyExistRelationEntitySubject.canBeInserted ===\r\n                        false\r\n                    )\r\n                        // if its not marked for insertion yet\r\n                        alreadyExistRelationEntitySubject.canBeInserted =\r\n                            relation.isCascadeInsert === true &&\r\n                            operationType === \"save\"\r\n                    if (\r\n                        alreadyExistRelationEntitySubject.canBeUpdated === false\r\n                    )\r\n                        // if its not marked for update yet\r\n                        alreadyExistRelationEntitySubject.canBeUpdated =\r\n                            relation.isCascadeUpdate === true &&\r\n                            operationType === \"save\"\r\n                    if (\r\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved ===\r\n                        false\r\n                    )\r\n                        // if its not marked for removal yet\r\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved =\r\n                            relation.isCascadeSoftRemove === true &&\r\n                            operationType === \"soft-remove\"\r\n                    if (\r\n                        alreadyExistRelationEntitySubject.canBeRecovered ===\r\n                        false\r\n                    )\r\n                        // if its not marked for recovery yet\r\n                        alreadyExistRelationEntitySubject.canBeRecovered =\r\n                            relation.isCascadeRecover === true &&\r\n                            operationType === \"recover\"\r\n                    return\r\n                }\r\n\r\n                // mark subject with what we can do with it\r\n                // and add to the array of subjects to load only if there is no same entity there already\r\n                const relationEntitySubject = new Subject({\r\n                    metadata: relationEntityMetadata,\r\n                    parentSubject: subject,\r\n                    entity: relationEntity,\r\n                    canBeInserted:\r\n                        relation.isCascadeInsert === true &&\r\n                        operationType === \"save\",\r\n                    canBeUpdated:\r\n                        relation.isCascadeUpdate === true &&\r\n                        operationType === \"save\",\r\n                    canBeSoftRemoved:\r\n                        relation.isCascadeSoftRemove === true &&\r\n                        operationType === \"soft-remove\",\r\n                    canBeRecovered:\r\n                        relation.isCascadeRecover === true &&\r\n                        operationType === \"recover\",\r\n                })\r\n                this.allSubjects.push(relationEntitySubject)\r\n\r\n                // go recursively and find other entities we need to insert/update\r\n                this.build(relationEntitySubject, operationType)\r\n            })\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Protected Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Finds subject where entity like given subject's entity.\r\n     * Comparison made by entity id.\r\n     */\r\n    protected findByPersistEntityLike(\r\n        entityTarget: Function | string,\r\n        entity: ObjectLiteral,\r\n    ): Subject | undefined {\r\n        return this.allSubjects.find((subject) => {\r\n            if (!subject.entity) return false\r\n\r\n            if (subject.entity === entity) return true\r\n\r\n            return (\r\n                subject.metadata.target === entityTarget &&\r\n                subject.metadata.compareEntities(\r\n                    subject.entityWithFulfilledIds!,\r\n                    entity,\r\n                )\r\n            )\r\n        })\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}