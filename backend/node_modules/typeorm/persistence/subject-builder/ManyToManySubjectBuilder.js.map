{"version":3,"sources":["../../src/persistence/subject-builder/ManyToManySubjectBuilder.ts"],"names":[],"mappings":"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","file":"ManyToManySubjectBuilder.js","sourcesContent":["import { Subject } from \"../Subject\"\r\nimport { OrmUtils } from \"../../util/OrmUtils\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\r\n\r\n/**\r\n * Builds operations needs to be executed for many-to-many relations of the given subjects.\r\n *\r\n * by example: post contains owner many-to-many relation with categories in the property called \"categories\", e.g.\r\n *             @ManyToMany(type => Category, category => category.posts) categories: Category[]\r\n *             If user adds categories into the post and saves post we need to bind them.\r\n *             This operation requires updation of junction table.\r\n */\r\nexport class ManyToManySubjectBuilder {\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(protected subjects: Subject[]) {}\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds operations for any changes in the many-to-many relations of the subjects.\r\n     */\r\n    build(): void {\r\n        this.subjects.forEach((subject) => {\r\n            // if subject doesn't have entity then no need to find something that should be inserted or removed\r\n            if (!subject.entity) return\r\n\r\n            // go through all persistence enabled many-to-many relations and build subject operations for them\r\n            subject.metadata.manyToManyRelations.forEach((relation) => {\r\n                // skip relations for which persistence is disabled\r\n                if (relation.persistenceEnabled === false) return\r\n\r\n                this.buildForSubjectRelation(subject, relation)\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.\r\n     */\r\n    buildForAllRemoval(subject: Subject) {\r\n        // if subject does not have a database entity then it means it does not exist in the database\r\n        // if it does not exist in the database then we don't have anything for deletion\r\n        if (!subject.databaseEntity) return\r\n\r\n        // go through all persistence enabled many-to-many relations and build subject operations for them\r\n        subject.metadata.manyToManyRelations.forEach((relation) => {\r\n            // skip relations for which persistence is disabled\r\n            if (relation.persistenceEnabled === false) return\r\n\r\n            // get all related entities (actually related entity relation ids) bind to this subject entity\r\n            // by example: returns category ids of the post we are currently working with (subject.entity is post)\r\n            const relatedEntityRelationIdsInDatabase: ObjectLiteral[] =\r\n                relation.getEntityValue(subject.databaseEntity!)\r\n\r\n            // go through all related entities and create a new junction subject for each row in junction table\r\n            relatedEntityRelationIdsInDatabase.forEach((relationId) => {\r\n                const junctionSubject = new Subject({\r\n                    metadata: relation.junctionEntityMetadata!,\r\n                    parentSubject: subject,\r\n                    mustBeRemoved: true,\r\n                    identifier: this.buildJunctionIdentifier(\r\n                        subject,\r\n                        relation,\r\n                        relationId,\r\n                    ),\r\n                })\r\n\r\n                // we use unshift because we need to perform those operations before post deletion is performed\r\n                // but post deletion was already added as an subject\r\n                // this is temporary solution, later we need to implement proper sorting of subjects before their removal\r\n                this.subjects.push(junctionSubject)\r\n            })\r\n        })\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Protected Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds operations for a given subject and relation.\r\n     *\r\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\r\n     */\r\n    protected buildForSubjectRelation(\r\n        subject: Subject,\r\n        relation: RelationMetadata,\r\n    ) {\r\n        // load from db all relation ids of inverse entities that are \"bind\" to the subject's entity\r\n        // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\r\n        let databaseRelatedEntityIds: ObjectLiteral[] = []\r\n\r\n        // if subject don't have database entity it means all related entities in persisted subject are new and must be bind\r\n        // and we don't need to remove something that is not exist\r\n        if (subject.databaseEntity) {\r\n            const databaseRelatedEntityValue = relation.getEntityValue(\r\n                subject.databaseEntity,\r\n            )\r\n            if (databaseRelatedEntityValue) {\r\n                databaseRelatedEntityIds = databaseRelatedEntityValue.map(\r\n                    (e: any) =>\r\n                        relation.inverseEntityMetadata.getEntityIdMap(e),\r\n                )\r\n            }\r\n        }\r\n\r\n        // extract entity's relation value\r\n        // by example: categories inside our post (subject.entity is post)\r\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(\r\n            subject.entity!,\r\n        )\r\n        if (relatedEntities === null)\r\n            // if value set to null its equal if we set it to empty array - all items must be removed from the database\r\n            relatedEntities = []\r\n        if (!Array.isArray(relatedEntities)) return\r\n\r\n        // from all related entities find only those which aren't found in the db - for them we will create operation subjects\r\n        relatedEntities.forEach((relatedEntity) => {\r\n            // by example: relatedEntity is category from categories saved with post\r\n\r\n            // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet\r\n\r\n            // extract only relation id from the related entities, since we only need it for comparison\r\n            // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\r\n            let relatedEntityRelationIdMap =\r\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\r\n\r\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\r\n            const relatedEntitySubject = this.subjects.find((subject) => {\r\n                return subject.entity === relatedEntity\r\n            })\r\n\r\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\r\n            if (relatedEntitySubject)\r\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier\r\n\r\n            // if related entity relation id map is empty it means related entity is newly persisted\r\n            if (!relatedEntityRelationIdMap) {\r\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\r\n                // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\r\n                // in this persistence because he didn't pass this entity for save or he did not set cascades\r\n                // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\r\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\r\n                // if (!relatedEntitySubject)\r\n                //     throw new TypeORMError(`Many-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\r\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\r\n                //         `Please setup cascade insertion or save entities before binding it.`);\r\n                if (!relatedEntitySubject) return\r\n            }\r\n\r\n            // try to find related entity in the database\r\n            // by example: find post's category in the database post's categories\r\n            const relatedEntityExistInDatabase = databaseRelatedEntityIds.find(\r\n                (databaseRelatedEntityRelationId) => {\r\n                    return OrmUtils.compareIds(\r\n                        databaseRelatedEntityRelationId,\r\n                        relatedEntityRelationIdMap,\r\n                    )\r\n                },\r\n            )\r\n\r\n            // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything\r\n            if (relatedEntityExistInDatabase) return\r\n\r\n            const ownerValue = relation.isOwning\r\n                ? subject\r\n                : relatedEntitySubject || relatedEntity // by example: ownerEntityMap is post from subject here\r\n            const inverseValue = relation.isOwning\r\n                ? relatedEntitySubject || relatedEntity\r\n                : subject // by example: inverseEntityMap is category from categories array here\r\n\r\n            // create a new subject for insert operation of junction rows\r\n            const junctionSubject = new Subject({\r\n                metadata: relation.junctionEntityMetadata!,\r\n                parentSubject: subject,\r\n                canBeInserted: true,\r\n            })\r\n            this.subjects.push(junctionSubject)\r\n\r\n            relation.junctionEntityMetadata!.ownerColumns.forEach((column) => {\r\n                junctionSubject.changeMaps.push({\r\n                    column: column,\r\n                    value: ownerValue,\r\n                    // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),\r\n                })\r\n            })\r\n\r\n            relation.junctionEntityMetadata!.inverseColumns.forEach(\r\n                (column) => {\r\n                    junctionSubject.changeMaps.push({\r\n                        column: column,\r\n                        value: inverseValue,\r\n                        // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),\r\n                    })\r\n                },\r\n            )\r\n        })\r\n\r\n        // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\r\n        const changedInverseEntityRelationIds: ObjectLiteral[] = []\r\n        relatedEntities.forEach((relatedEntity) => {\r\n            // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\r\n            let relatedEntityRelationIdMap =\r\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\r\n\r\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\r\n            const relatedEntitySubject = this.subjects.find((subject) => {\r\n                return subject.entity === relatedEntity\r\n            })\r\n\r\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\r\n            if (relatedEntitySubject)\r\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier\r\n\r\n            if (\r\n                relatedEntityRelationIdMap !== undefined &&\r\n                relatedEntityRelationIdMap !== null\r\n            )\r\n                changedInverseEntityRelationIds.push(relatedEntityRelationIdMap)\r\n        })\r\n\r\n        // now from all entities in the persisted entity find only those which aren't found in the db\r\n        const removedJunctionEntityIds = databaseRelatedEntityIds.filter(\r\n            (existRelationId) => {\r\n                return !changedInverseEntityRelationIds.find(\r\n                    (changedRelationId) => {\r\n                        return OrmUtils.compareIds(\r\n                            changedRelationId,\r\n                            existRelationId,\r\n                        )\r\n                    },\r\n                )\r\n            },\r\n        )\r\n\r\n        // finally create a new junction remove operations for missing related entities\r\n        removedJunctionEntityIds.forEach((removedEntityRelationId) => {\r\n            const junctionSubject = new Subject({\r\n                metadata: relation.junctionEntityMetadata!,\r\n                parentSubject: subject,\r\n                mustBeRemoved: true,\r\n                identifier: this.buildJunctionIdentifier(\r\n                    subject,\r\n                    relation,\r\n                    removedEntityRelationId,\r\n                ),\r\n            })\r\n            this.subjects.push(junctionSubject)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Creates identifiers for junction table.\r\n     * Example: { postId: 1, categoryId: 2 }\r\n     */\r\n    protected buildJunctionIdentifier(\r\n        subject: Subject,\r\n        relation: RelationMetadata,\r\n        relationId: ObjectLiteral,\r\n    ) {\r\n        const ownerEntityMap = relation.isOwning ? subject.entity! : relationId\r\n        const inverseEntityMap = relation.isOwning\r\n            ? relationId\r\n            : subject.entity!\r\n\r\n        const identifier: ObjectLiteral = {}\r\n        relation.junctionEntityMetadata!.ownerColumns.forEach((column) => {\r\n            OrmUtils.mergeDeep(\r\n                identifier,\r\n                column.createValueMap(\r\n                    column.referencedColumn!.getEntityValue(ownerEntityMap),\r\n                ),\r\n            )\r\n        })\r\n        relation.junctionEntityMetadata!.inverseColumns.forEach((column) => {\r\n            OrmUtils.mergeDeep(\r\n                identifier,\r\n                column.createValueMap(\r\n                    column.referencedColumn!.getEntityValue(inverseEntityMap),\r\n                ),\r\n            )\r\n        })\r\n        return identifier\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}