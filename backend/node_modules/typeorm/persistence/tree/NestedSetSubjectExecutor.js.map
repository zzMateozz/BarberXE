{"version":3,"sources":["../../src/persistence/tree/NestedSetSubjectExecutor.ts"],"names":[],"mappings":"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","file":"NestedSetSubjectExecutor.js","sourcesContent":["import { Subject } from \"../Subject\"\r\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\r\nimport { OrmUtils } from \"../../util/OrmUtils\"\r\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\r\n\r\nclass NestedSetIds {\r\n    left: number\r\n    right: number\r\n}\r\n\r\n/**\r\n * Executes subject operations for nested set tree entities.\r\n */\r\nexport class NestedSetSubjectExecutor {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected queryRunner: QueryRunner) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Executes operations when subject is being inserted.\r\n     */\r\n    async insert(subject: Subject): Promise<void> {\r\n        const escape = (alias: string) =>\r\n            this.queryRunner.connection.driver.escape(alias)\r\n        const tableName = this.getTableName(subject.metadata.tablePath)\r\n        const leftColumnName = escape(\r\n            subject.metadata.nestedSetLeftColumn!.databaseName,\r\n        )\r\n        const rightColumnName = escape(\r\n            subject.metadata.nestedSetRightColumn!.databaseName,\r\n        )\r\n\r\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\r\n            subject.entity!,\r\n        ) // if entity was attached via parent\r\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\r\n            // if entity was attached via children\r\n            parent = subject.parentSubject.insertedValueSet\r\n                ? subject.parentSubject.insertedValueSet\r\n                : subject.parentSubject.entity\r\n        const parentId = subject.metadata.getEntityIdMap(parent)\r\n\r\n        let parentNsRight: number | undefined = undefined\r\n        if (parentId) {\r\n            parentNsRight = await this.queryRunner.manager\r\n                .createQueryBuilder()\r\n                .select(\r\n                    subject.metadata.targetName +\r\n                        \".\" +\r\n                        subject.metadata.nestedSetRightColumn!.propertyPath,\r\n                    \"right\",\r\n                )\r\n                .from(subject.metadata.target, subject.metadata.targetName)\r\n                .whereInIds(parentId)\r\n                .getRawOne()\r\n                .then((result) => {\r\n                    const value: any = result ? result[\"right\"] : undefined\r\n                    // CockroachDB returns numeric types as string\r\n                    return typeof value === \"string\" ? parseInt(value) : value\r\n                })\r\n        }\r\n\r\n        if (parentNsRight !== undefined) {\r\n            await this.queryRunner.query(\r\n                `UPDATE ${tableName} SET ` +\r\n                    `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\r\n                    `${rightColumnName} = ${rightColumnName} + 2 ` +\r\n                    `WHERE ${rightColumnName} >= ${parentNsRight}`,\r\n            )\r\n\r\n            OrmUtils.mergeDeep(\r\n                subject.insertedValueSet,\r\n                subject.metadata.nestedSetLeftColumn!.createValueMap(\r\n                    parentNsRight,\r\n                ),\r\n                subject.metadata.nestedSetRightColumn!.createValueMap(\r\n                    parentNsRight + 1,\r\n                ),\r\n            )\r\n        } else {\r\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\r\n\r\n            // Validate if a root entity already exits and throw an exception\r\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\r\n\r\n            OrmUtils.mergeDeep(\r\n                subject.insertedValueSet,\r\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\r\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes operations when subject is being updated.\r\n     */\r\n    async update(subject: Subject): Promise<void> {\r\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\r\n            subject.entity!,\r\n        ) // if entity was attached via parent\r\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\r\n            // if entity was attached via children\r\n            parent = subject.parentSubject.entity\r\n\r\n        let entity = subject.databaseEntity // if entity was attached via parent\r\n        if (!entity && parent)\r\n            // if entity was attached via children\r\n            entity = subject.metadata\r\n                .treeChildrenRelation!.getEntityValue(parent)\r\n                .find((child: any) => {\r\n                    return Object.entries(subject.identifier!).every(\r\n                        ([key, value]) => child[key] === value,\r\n                    )\r\n                })\r\n\r\n        // Exit if the parent or the entity where never set\r\n        if (entity === undefined || parent === undefined) {\r\n            return\r\n        }\r\n\r\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\r\n            entity!,\r\n        )\r\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\r\n        const parentId = subject.metadata.getEntityIdMap(parent)\r\n\r\n        // Exit if the new and old parents are the same\r\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\r\n            return\r\n        }\r\n\r\n        if (parent) {\r\n            const escape = (alias: string) =>\r\n                this.queryRunner.connection.driver.escape(alias)\r\n            const tableName = this.getTableName(subject.metadata.tablePath)\r\n            const leftColumnName = escape(\r\n                subject.metadata.nestedSetLeftColumn!.databaseName,\r\n            )\r\n            const rightColumnName = escape(\r\n                subject.metadata.nestedSetRightColumn!.databaseName,\r\n            )\r\n\r\n            const entityId = subject.metadata.getEntityIdMap(entity)\r\n\r\n            let entityNs: NestedSetIds | undefined = undefined\r\n            if (entityId) {\r\n                entityNs = (\r\n                    await this.getNestedSetIds(subject.metadata, entityId)\r\n                )[0]\r\n            }\r\n\r\n            let parentNs: NestedSetIds | undefined = undefined\r\n            if (parentId) {\r\n                parentNs = (\r\n                    await this.getNestedSetIds(subject.metadata, parentId)\r\n                )[0]\r\n            }\r\n\r\n            if (entityNs !== undefined && parentNs !== undefined) {\r\n                const isMovingUp = parentNs.left > entityNs.left\r\n                const treeSize = entityNs.right - entityNs.left + 1\r\n\r\n                let entitySize: number\r\n                if (isMovingUp) {\r\n                    entitySize = parentNs.left - entityNs.right\r\n                } else {\r\n                    entitySize = parentNs.right - entityNs.left\r\n                }\r\n\r\n                // Moved entity logic\r\n                const updateLeftSide =\r\n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\r\n                    `${leftColumnName} < ${entityNs.right} ` +\r\n                    `THEN ${leftColumnName} + ${entitySize} `\r\n\r\n                const updateRightSide =\r\n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\r\n                    `${rightColumnName} <= ${entityNs.right} ` +\r\n                    `THEN ${rightColumnName} + ${entitySize} `\r\n\r\n                // Update the surrounding entities\r\n                if (isMovingUp) {\r\n                    await this.queryRunner.query(\r\n                        `UPDATE ${tableName} ` +\r\n                            `SET ${leftColumnName} = CASE ` +\r\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\r\n                            `${leftColumnName} <= ${parentNs.left} ` +\r\n                            `THEN ${leftColumnName} - ${treeSize} ` +\r\n                            updateLeftSide +\r\n                            `ELSE ${leftColumnName} ` +\r\n                            `END, ` +\r\n                            `${rightColumnName} = CASE ` +\r\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\r\n                            `${rightColumnName} < ${parentNs.left} ` +\r\n                            `THEN ${rightColumnName} - ${treeSize} ` +\r\n                            updateRightSide +\r\n                            `ELSE ${rightColumnName} ` +\r\n                            `END`,\r\n                    )\r\n                } else {\r\n                    await this.queryRunner.query(\r\n                        `UPDATE ${tableName} ` +\r\n                            `SET ${leftColumnName} = CASE ` +\r\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\r\n                            `${leftColumnName} > ${parentNs.right} ` +\r\n                            `THEN ${leftColumnName} + ${treeSize} ` +\r\n                            updateLeftSide +\r\n                            `ELSE ${leftColumnName} ` +\r\n                            `END, ` +\r\n                            `${rightColumnName} = CASE ` +\r\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\r\n                            `${rightColumnName} >= ${parentNs.right} ` +\r\n                            `THEN ${rightColumnName} + ${treeSize} ` +\r\n                            updateRightSide +\r\n                            `ELSE ${rightColumnName} ` +\r\n                            `END`,\r\n                    )\r\n                }\r\n            }\r\n        } else {\r\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\r\n\r\n            // Validate if a root entity already exits and throw an exception\r\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes operations when subject is being removed.\r\n     */\r\n    async remove(subjects: Subject | Subject[]): Promise<void> {\r\n        if (!Array.isArray(subjects)) subjects = [subjects]\r\n\r\n        const metadata = subjects[0].metadata\r\n\r\n        const escape = (alias: string) =>\r\n            this.queryRunner.connection.driver.escape(alias)\r\n        const tableName = this.getTableName(metadata.tablePath)\r\n        const leftColumnName = escape(\r\n            metadata.nestedSetLeftColumn!.databaseName,\r\n        )\r\n        const rightColumnName = escape(\r\n            metadata.nestedSetRightColumn!.databaseName,\r\n        )\r\n\r\n        let entitiesIds: ObjectLiteral[] = []\r\n        for (const subject of subjects) {\r\n            const entityId = metadata.getEntityIdMap(subject.entity)\r\n\r\n            if (entityId) {\r\n                entitiesIds.push(entityId)\r\n            }\r\n        }\r\n\r\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds)\r\n\r\n        for (const entity of entitiesNs) {\r\n            const treeSize = entity.right - entity.left + 1\r\n\r\n            await this.queryRunner.query(\r\n                `UPDATE ${tableName} ` +\r\n                    `SET ${leftColumnName} = CASE ` +\r\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\r\n                    `ELSE ${leftColumnName} ` +\r\n                    `END, ` +\r\n                    `${rightColumnName} = CASE ` +\r\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\r\n                    `ELSE ${rightColumnName} ` +\r\n                    `END`,\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the nested set ids for a given entity\r\n     */\r\n    protected getNestedSetIds(\r\n        metadata: EntityMetadata,\r\n        ids: ObjectLiteral | ObjectLiteral[],\r\n    ): Promise<NestedSetIds[]> {\r\n        const select = {\r\n            left: `${metadata.targetName}.${\r\n                metadata.nestedSetLeftColumn!.propertyPath\r\n            }`,\r\n            right: `${metadata.targetName}.${\r\n                metadata.nestedSetRightColumn!.propertyPath\r\n            }`,\r\n        }\r\n\r\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder()\r\n\r\n        Object.entries(select).forEach(([key, value]) => {\r\n            queryBuilder.addSelect(value, key)\r\n        })\r\n\r\n        return queryBuilder\r\n            .from(metadata.target, metadata.targetName)\r\n            .whereInIds(ids)\r\n            .orderBy(select.right, \"DESC\")\r\n            .getRawMany()\r\n            .then((results) => {\r\n                const data: NestedSetIds[] = []\r\n\r\n                for (const result of results) {\r\n                    const entry: any = {}\r\n                    for (const key of Object.keys(select)) {\r\n                        const value = result ? result[key] : undefined\r\n\r\n                        // CockroachDB returns numeric types as string\r\n                        entry[key] =\r\n                            typeof value === \"string\" ? parseInt(value) : value\r\n                    }\r\n                    data.push(entry)\r\n                }\r\n\r\n                return data\r\n            })\r\n    }\r\n\r\n    private async isUniqueRootEntity(\r\n        subject: Subject,\r\n        parent: any,\r\n    ): Promise<boolean> {\r\n        const escape = (alias: string) =>\r\n            this.queryRunner.connection.driver.escape(alias)\r\n        const tableName = this.getTableName(subject.metadata.tablePath)\r\n        const parameters: any[] = []\r\n        const whereCondition = subject.metadata\r\n            .treeParentRelation!.joinColumns.map((column) => {\r\n                const columnName = escape(column.databaseName)\r\n                const parameter = column.getEntityValue(parent)\r\n\r\n                if (parameter == null) {\r\n                    return `${columnName} IS NULL`\r\n                }\r\n\r\n                parameters.push(parameter)\r\n                const parameterName =\r\n                    this.queryRunner.connection.driver.createParameter(\r\n                        \"entity_\" + column.databaseName,\r\n                        parameters.length - 1,\r\n                    )\r\n                return `${columnName} = ${parameterName}`\r\n            })\r\n            .join(\" AND \")\r\n\r\n        const countAlias = \"count\"\r\n        const result = await this.queryRunner.query(\r\n            `SELECT COUNT(1) AS ${escape(\r\n                countAlias,\r\n            )} FROM ${tableName} WHERE ${whereCondition}`,\r\n            parameters,\r\n            true,\r\n        )\r\n\r\n        return parseInt(result.records[0][countAlias]) === 0\r\n    }\r\n\r\n    /**\r\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\r\n     * schema name, otherwise returns escaped table name.\r\n     */\r\n    protected getTableName(tablePath: string): string {\r\n        return tablePath\r\n            .split(\".\")\r\n            .map((i) => {\r\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\r\n                return i === \"\"\r\n                    ? i\r\n                    : this.queryRunner.connection.driver.escape(i)\r\n            })\r\n            .join(\".\")\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}