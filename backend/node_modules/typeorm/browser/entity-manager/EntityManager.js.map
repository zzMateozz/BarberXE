{"version":3,"sources":["../browser/src/entity-manager/EntityManager.ts"],"names":[],"mappings":"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","file":"EntityManager.js","sourcesContent":["import { DataSource } from \"../data-source/DataSource\"\r\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\r\nimport { EntityTarget } from \"../common/EntityTarget\"\r\nimport { ObjectType } from \"../common/ObjectType\"\r\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\"\r\nimport { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\"\r\nimport { FindOneOptions } from \"../find-options/FindOneOptions\"\r\nimport { DeepPartial } from \"../common/DeepPartial\"\r\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\r\nimport { SaveOptions } from \"../repository/SaveOptions\"\r\nimport { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\"\r\nimport { MongoRepository } from \"../repository/MongoRepository\"\r\nimport { TreeRepository } from \"../repository/TreeRepository\"\r\nimport { Repository } from \"../repository/Repository\"\r\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\r\nimport { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\"\r\nimport { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\"\r\nimport {\r\n    CustomRepositoryCannotInheritRepositoryError,\r\n    CustomRepositoryNotFoundError,\r\n    TreeRepositoryNotSupportedError,\r\n    TypeORMError,\r\n} from \"../error\"\r\nimport { AbstractRepository } from \"../repository/AbstractRepository\"\r\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\r\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\r\nimport { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\"\r\nimport { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\"\r\nimport { ObjectId } from \"../driver/mongodb/typings\"\r\nimport { InsertResult } from \"../query-builder/result/InsertResult\"\r\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\r\nimport { DeleteResult } from \"../query-builder/result/DeleteResult\"\r\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\r\nimport { IsolationLevel } from \"../driver/types/IsolationLevel\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\nimport { getMetadataArgsStorage } from \"../globals\"\r\nimport { UpsertOptions } from \"../repository/UpsertOptions\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { PickKeysByType } from \"../common/PickKeysByType\"\r\n\r\n/**\r\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\r\n * whatever entity type are you passing.\r\n */\r\nexport class EntityManager {\r\n    readonly \"@instanceof\" = Symbol.for(\"EntityManager\")\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Connection used by this entity manager.\r\n     */\r\n    readonly connection: DataSource\r\n\r\n    /**\r\n     * Custom query runner to be used for operations in this entity manager.\r\n     * Used only in non-global entity manager.\r\n     */\r\n    readonly queryRunner?: QueryRunner\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Once created and then reused by repositories.\r\n     * Created as a future replacement for the #repositories to provide a bit more perf optimization.\r\n     */\r\n    protected repositories = new Map<EntityTarget<any>, Repository<any>>()\r\n\r\n    /**\r\n     * Once created and then reused by repositories.\r\n     */\r\n    protected treeRepositories: TreeRepository<any>[] = []\r\n\r\n    /**\r\n     * Plain to object transformer used in create and merge operations.\r\n     */\r\n    protected plainObjectToEntityTransformer =\r\n        new PlainObjectToNewEntityTransformer()\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(connection: DataSource, queryRunner?: QueryRunner) {\r\n        this.connection = connection\r\n        if (queryRunner) {\r\n            this.queryRunner = queryRunner\r\n            // dynamic: this.queryRunner = manager;\r\n            ObjectUtils.assign(this.queryRunner, { manager: this })\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Wraps given function execution (and all operations made there) in a transaction.\r\n     * All database operations must be executed using provided entity manager.\r\n     */\r\n    async transaction<T>(\r\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\r\n    ): Promise<T>\r\n\r\n    /**\r\n     * Wraps given function execution (and all operations made there) in a transaction.\r\n     * All database operations must be executed using provided entity manager.\r\n     */\r\n    async transaction<T>(\r\n        isolationLevel: IsolationLevel,\r\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\r\n    ): Promise<T>\r\n\r\n    /**\r\n     * Wraps given function execution (and all operations made there) in a transaction.\r\n     * All database operations must be executed using provided entity manager.\r\n     */\r\n    async transaction<T>(\r\n        isolationOrRunInTransaction:\r\n            | IsolationLevel\r\n            | ((entityManager: EntityManager) => Promise<T>),\r\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>,\r\n    ): Promise<T> {\r\n        const isolation =\r\n            typeof isolationOrRunInTransaction === \"string\"\r\n                ? isolationOrRunInTransaction\r\n                : undefined\r\n        const runInTransaction =\r\n            typeof isolationOrRunInTransaction === \"function\"\r\n                ? isolationOrRunInTransaction\r\n                : runInTransactionParam\r\n\r\n        if (!runInTransaction) {\r\n            throw new TypeORMError(\r\n                `Transaction method requires callback in second parameter if isolation level is supplied.`,\r\n            )\r\n        }\r\n\r\n        if (this.queryRunner && this.queryRunner.isReleased)\r\n            throw new QueryRunnerProviderAlreadyReleasedError()\r\n\r\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\r\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\r\n        const queryRunner =\r\n            this.queryRunner || this.connection.createQueryRunner()\r\n\r\n        try {\r\n            await queryRunner.startTransaction(isolation)\r\n            const result = await runInTransaction(queryRunner.manager)\r\n            await queryRunner.commitTransaction()\r\n            return result\r\n        } catch (err) {\r\n            try {\r\n                // we throw original error even if rollback thrown an error\r\n                await queryRunner.rollbackTransaction()\r\n            } catch (rollbackError) {}\r\n            throw err\r\n        } finally {\r\n            if (!this.queryRunner)\r\n                // if we used a new query runner provider then release it\r\n                await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes raw SQL query and returns raw database results.\r\n     * \r\n     * @see [Official docs](https://typeorm.io/entity-manager-api) for examples.\r\n     */\r\n    async query<T = any>(query: string, parameters?: any[]): Promise<T> {\r\n        return this.connection.query(query, parameters, this.queryRunner)\r\n    }\r\n\r\n    /**\r\n     * Creates a new query builder that can be used to build a SQL query.\r\n     */\r\n    createQueryBuilder<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        alias: string,\r\n        queryRunner?: QueryRunner,\r\n    ): SelectQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates a new query builder that can be used to build a SQL query.\r\n     */\r\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>\r\n\r\n    /**\r\n     * Creates a new query builder that can be used to build a SQL query.\r\n     */\r\n    createQueryBuilder<Entity extends ObjectLiteral>(\r\n        entityClass?: EntityTarget<Entity> | QueryRunner,\r\n        alias?: string,\r\n        queryRunner?: QueryRunner,\r\n    ): SelectQueryBuilder<Entity> {\r\n        if (alias) {\r\n            return this.connection.createQueryBuilder(\r\n                entityClass as EntityTarget<Entity>,\r\n                alias,\r\n                queryRunner || this.queryRunner,\r\n            )\r\n        } else {\r\n            return this.connection.createQueryBuilder(\r\n                (entityClass as QueryRunner | undefined) ||\r\n                    queryRunner ||\r\n                    this.queryRunner,\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has an id.\r\n     */\r\n    hasId(entity: any): boolean\r\n\r\n    /**\r\n     * Checks if entity of given schema name has an id.\r\n     */\r\n    hasId(target: Function | string, entity: any): boolean\r\n\r\n    /**\r\n     * Checks if entity has an id by its Function type or schema name.\r\n     */\r\n    hasId(targetOrEntity: any | Function | string, maybeEntity?: any): boolean {\r\n        const target =\r\n            arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor\r\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity\r\n        const metadata = this.connection.getMetadata(target)\r\n        return metadata.hasId(entity)\r\n    }\r\n\r\n    /**\r\n     * Gets entity mixed id.\r\n     */\r\n    getId(entity: any): any\r\n\r\n    /**\r\n     * Gets entity mixed id.\r\n     */\r\n    getId(target: EntityTarget<any>, entity: any): any\r\n\r\n    /**\r\n     * Gets entity mixed id.\r\n     */\r\n    getId(targetOrEntity: any | EntityTarget<any>, maybeEntity?: any): any {\r\n        const target =\r\n            arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor\r\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity\r\n        const metadata = this.connection.getMetadata(target)\r\n        return metadata.getEntityIdMixedMap(entity)\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\r\n     * Note that it copies only properties that present in entity schema.\r\n     */\r\n    create<Entity, EntityLike extends DeepPartial<Entity>>(\r\n        entityClass: EntityTarget<Entity>,\r\n        plainObject?: EntityLike,\r\n    ): Entity\r\n\r\n    /**\r\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\r\n     * Note that it copies only properties that present in entity schema.\r\n     */\r\n    create<Entity, EntityLike extends DeepPartial<Entity>>(\r\n        entityClass: EntityTarget<Entity>,\r\n        plainObjects?: EntityLike[],\r\n    ): Entity[]\r\n\r\n    /**\r\n     * Creates a new entity instance or instances.\r\n     * Can copy properties from the given object into new entities.\r\n     */\r\n    create<Entity, EntityLike extends DeepPartial<Entity>>(\r\n        entityClass: EntityTarget<Entity>,\r\n        plainObjectOrObjects?: EntityLike | EntityLike[],\r\n    ): Entity | Entity[] {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n\r\n        if (!plainObjectOrObjects) return metadata.create(this.queryRunner)\r\n\r\n        if (Array.isArray(plainObjectOrObjects))\r\n            return (plainObjectOrObjects as EntityLike[]).map(\r\n                (plainEntityLike) => this.create(entityClass, plainEntityLike),\r\n            )\r\n\r\n        const mergeIntoEntity = metadata.create(this.queryRunner)\r\n        this.plainObjectToEntityTransformer.transform(\r\n            mergeIntoEntity,\r\n            plainObjectOrObjects,\r\n            metadata,\r\n            true,\r\n        )\r\n        return mergeIntoEntity\r\n    }\r\n\r\n    /**\r\n     * Merges two entities into one new entity.\r\n     */\r\n    merge<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        mergeIntoEntity: Entity,\r\n        ...entityLikes: DeepPartial<Entity>[]\r\n    ): Entity {\r\n        // todo: throw exception if entity manager is released\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        entityLikes.forEach((object) =>\r\n            this.plainObjectToEntityTransformer.transform(\r\n                mergeIntoEntity,\r\n                object,\r\n                metadata,\r\n            ),\r\n        )\r\n        return mergeIntoEntity\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\r\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\r\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\r\n     * replaced from the new object.\r\n     */\r\n    async preload<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        entityLike: DeepPartial<Entity>,\r\n    ): Promise<Entity | undefined> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        const plainObjectToDatabaseEntityTransformer =\r\n            new PlainObjectToDatabaseEntityTransformer(this.connection.manager)\r\n        const transformedEntity =\r\n            await plainObjectToDatabaseEntityTransformer.transform(\r\n                entityLike,\r\n                metadata,\r\n            )\r\n        if (transformedEntity)\r\n            return this.merge(\r\n                entityClass as any,\r\n                transformedEntity as Entity,\r\n                entityLike,\r\n            )\r\n\r\n        return undefined\r\n    }\r\n\r\n    /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n    save<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>\r\n\r\n    /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n    save<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>\r\n\r\n    /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n    save<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entities: T[],\r\n        options: SaveOptions & { reload: false },\r\n    ): Promise<T[]>\r\n\r\n    /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n    save<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entities: T[],\r\n        options?: SaveOptions,\r\n    ): Promise<(T & Entity)[]>\r\n\r\n    /**\r\n     * Saves a given entity in the database.\r\n     * If entity does not exist in the database then inserts, otherwise updates.\r\n     */\r\n    save<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entity: T,\r\n        options: SaveOptions & { reload: false },\r\n    ): Promise<T>\r\n\r\n    /**\r\n     * Saves a given entity in the database.\r\n     * If entity does not exist in the database then inserts, otherwise updates.\r\n     */\r\n    save<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entity: T,\r\n        options?: SaveOptions,\r\n    ): Promise<T & Entity>\r\n\r\n    /**\r\n     * Saves a given entity in the database.\r\n     */\r\n    save<Entity extends ObjectLiteral, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: (T | T[]) | EntityTarget<Entity>,\r\n        maybeEntityOrOptions?: T | T[],\r\n        maybeOptions?: SaveOptions,\r\n    ): Promise<T | T[]> {\r\n        // normalize mixed parameters\r\n        let target =\r\n            arguments.length > 1 &&\r\n            (typeof targetOrEntity === \"function\" ||\r\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\r\n                typeof targetOrEntity === \"string\")\r\n                ? (targetOrEntity as Function | string)\r\n                : undefined\r\n        const entity: T | T[] = target\r\n            ? (maybeEntityOrOptions as T | T[])\r\n            : (targetOrEntity as T | T[])\r\n        const options = target\r\n            ? maybeOptions\r\n            : (maybeEntityOrOptions as SaveOptions)\r\n\r\n        if (InstanceChecker.isEntitySchema(target)) target = target.options.name\r\n\r\n        // if user passed empty array of entities then we don't need to do anything\r\n        if (Array.isArray(entity) && entity.length === 0)\r\n            return Promise.resolve(entity)\r\n\r\n        // execute save operation\r\n        return new EntityPersistExecutor(\r\n            this.connection,\r\n            this.queryRunner,\r\n            \"save\",\r\n            target,\r\n            entity,\r\n            options,\r\n        )\r\n            .execute()\r\n            .then(() => entity)\r\n    }\r\n\r\n    /**\r\n     * Removes a given entity from the database.\r\n     */\r\n    remove<Entity>(entity: Entity, options?: RemoveOptions): Promise<Entity>\r\n\r\n    /**\r\n     * Removes a given entity from the database.\r\n     */\r\n    remove<Entity>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entity: Entity,\r\n        options?: RemoveOptions,\r\n    ): Promise<Entity>\r\n\r\n    /**\r\n     * Removes a given entity from the database.\r\n     */\r\n    remove<Entity>(entity: Entity[], options?: RemoveOptions): Promise<Entity>\r\n\r\n    /**\r\n     * Removes a given entity from the database.\r\n     */\r\n    remove<Entity>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entity: Entity[],\r\n        options?: RemoveOptions,\r\n    ): Promise<Entity[]>\r\n\r\n    /**\r\n     * Removes a given entity from the database.\r\n     */\r\n    remove<Entity extends ObjectLiteral>(\r\n        targetOrEntity: (Entity | Entity[]) | EntityTarget<Entity>,\r\n        maybeEntityOrOptions?: Entity | Entity[],\r\n        maybeOptions?: RemoveOptions,\r\n    ): Promise<Entity | Entity[]> {\r\n        // normalize mixed parameters\r\n        const target =\r\n            arguments.length > 1 &&\r\n            (typeof targetOrEntity === \"function\" ||\r\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\r\n                typeof targetOrEntity === \"string\")\r\n                ? (targetOrEntity as Function | string)\r\n                : undefined\r\n        const entity: Entity | Entity[] = target\r\n            ? (maybeEntityOrOptions as Entity | Entity[])\r\n            : (targetOrEntity as Entity | Entity[])\r\n        const options = target\r\n            ? maybeOptions\r\n            : (maybeEntityOrOptions as SaveOptions)\r\n\r\n        // if user passed empty array of entities then we don't need to do anything\r\n        if (Array.isArray(entity) && entity.length === 0)\r\n            return Promise.resolve(entity)\r\n\r\n        // execute save operation\r\n        return new EntityPersistExecutor(\r\n            this.connection,\r\n            this.queryRunner,\r\n            \"remove\",\r\n            target,\r\n            entity,\r\n            options,\r\n        )\r\n            .execute()\r\n            .then(() => entity)\r\n    }\r\n\r\n    /**\r\n     * Records the delete date of all given entities.\r\n     */\r\n    softRemove<Entity>(\r\n        entities: Entity[],\r\n        options?: SaveOptions,\r\n    ): Promise<Entity[]>\r\n\r\n    /**\r\n     * Records the delete date of a given entity.\r\n     */\r\n    softRemove<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>\r\n\r\n    /**\r\n     * Records the delete date of all given entities.\r\n     */\r\n    softRemove<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entities: T[],\r\n        options?: SaveOptions,\r\n    ): Promise<T[]>\r\n\r\n    /**\r\n     * Records the delete date of a given entity.\r\n     */\r\n    softRemove<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entity: T,\r\n        options?: SaveOptions,\r\n    ): Promise<T>\r\n\r\n    /**\r\n     * Records the delete date of one or many given entities.\r\n     */\r\n    softRemove<Entity extends ObjectLiteral, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: (T | T[]) | EntityTarget<Entity>,\r\n        maybeEntityOrOptions?: T | T[],\r\n        maybeOptions?: SaveOptions,\r\n    ): Promise<T | T[]> {\r\n        // normalize mixed parameters\r\n        let target =\r\n            arguments.length > 1 &&\r\n            (typeof targetOrEntity === \"function\" ||\r\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\r\n                typeof targetOrEntity === \"string\")\r\n                ? (targetOrEntity as Function | string)\r\n                : undefined\r\n        const entity: T | T[] = target\r\n            ? (maybeEntityOrOptions as T | T[])\r\n            : (targetOrEntity as T | T[])\r\n        const options = target\r\n            ? maybeOptions\r\n            : (maybeEntityOrOptions as SaveOptions)\r\n\r\n        if (InstanceChecker.isEntitySchema(target)) target = target.options.name\r\n\r\n        // if user passed empty array of entities then we don't need to do anything\r\n        if (Array.isArray(entity) && entity.length === 0)\r\n            return Promise.resolve(entity)\r\n\r\n        // execute soft-remove operation\r\n        return new EntityPersistExecutor(\r\n            this.connection,\r\n            this.queryRunner,\r\n            \"soft-remove\",\r\n            target,\r\n            entity,\r\n            options,\r\n        )\r\n            .execute()\r\n            .then(() => entity)\r\n    }\r\n\r\n    /**\r\n     * Recovers all given entities.\r\n     */\r\n    recover<Entity>(\r\n        entities: Entity[],\r\n        options?: SaveOptions,\r\n    ): Promise<Entity[]>\r\n\r\n    /**\r\n     * Recovers a given entity.\r\n     */\r\n    recover<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>\r\n\r\n    /**\r\n     * Recovers all given entities.\r\n     */\r\n    recover<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entities: T[],\r\n        options?: SaveOptions,\r\n    ): Promise<T[]>\r\n\r\n    /**\r\n     * Recovers a given entity.\r\n     */\r\n    recover<Entity, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        entity: T,\r\n        options?: SaveOptions,\r\n    ): Promise<T>\r\n\r\n    /**\r\n     * Recovers one or many given entities.\r\n     */\r\n    recover<Entity extends ObjectLiteral, T extends DeepPartial<Entity>>(\r\n        targetOrEntity: (T | T[]) | EntityTarget<Entity>,\r\n        maybeEntityOrOptions?: T | T[],\r\n        maybeOptions?: SaveOptions,\r\n    ): Promise<T | T[]> {\r\n        // normalize mixed parameters\r\n        let target =\r\n            arguments.length > 1 &&\r\n            (typeof targetOrEntity === \"function\" ||\r\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\r\n                typeof targetOrEntity === \"string\")\r\n                ? (targetOrEntity as Function | string)\r\n                : undefined\r\n        const entity: T | T[] = target\r\n            ? (maybeEntityOrOptions as T | T[])\r\n            : (targetOrEntity as T | T[])\r\n        const options = target\r\n            ? maybeOptions\r\n            : (maybeEntityOrOptions as SaveOptions)\r\n\r\n        if (InstanceChecker.isEntitySchema(target)) target = target.options.name\r\n\r\n        // if user passed empty array of entities then we don't need to do anything\r\n        if (Array.isArray(entity) && entity.length === 0)\r\n            return Promise.resolve(entity)\r\n\r\n        // execute recover operation\r\n        return new EntityPersistExecutor(\r\n            this.connection,\r\n            this.queryRunner,\r\n            \"recover\",\r\n            target,\r\n            entity,\r\n            options,\r\n        )\r\n            .execute()\r\n            .then(() => entity)\r\n    }\r\n\r\n    /**\r\n     * Inserts a given entity into the database.\r\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\r\n     * Executes fast and efficient INSERT query.\r\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\r\n     * You can execute bulk inserts using this method.\r\n     */\r\n    async insert<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n        entity:\r\n            | QueryDeepPartialEntity<Entity>\r\n            | QueryDeepPartialEntity<Entity>[],\r\n    ): Promise<InsertResult> {\r\n        return this.createQueryBuilder()\r\n            .insert()\r\n            .into(target)\r\n            .values(entity)\r\n            .execute()\r\n    }\r\n\r\n    async upsert<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n        entityOrEntities:\r\n            | QueryDeepPartialEntity<Entity>\r\n            | QueryDeepPartialEntity<Entity>[],\r\n        conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\r\n    ): Promise<InsertResult> {\r\n        const metadata = this.connection.getMetadata(target)\r\n\r\n        let options: UpsertOptions<Entity>\r\n\r\n        if (Array.isArray(conflictPathsOrOptions)) {\r\n            options = {\r\n                conflictPaths: conflictPathsOrOptions,\r\n            }\r\n        } else {\r\n            options = conflictPathsOrOptions\r\n        }\r\n\r\n        let entities: QueryDeepPartialEntity<Entity>[]\r\n\r\n        if (!Array.isArray(entityOrEntities)) {\r\n            entities = [entityOrEntities]\r\n        } else {\r\n            entities = entityOrEntities\r\n        }\r\n\r\n        const conflictColumns = metadata.mapPropertyPathsToColumns(\r\n            Array.isArray(options.conflictPaths)\r\n                ? options.conflictPaths\r\n                : Object.keys(options.conflictPaths),\r\n        )\r\n\r\n        const overwriteColumns = metadata.columns.filter(\r\n            (col) =>\r\n                !conflictColumns.includes(col) &&\r\n                entities.some(\r\n                    (entity) =>\r\n                        typeof col.getEntityValue(entity) !== \"undefined\",\r\n                ),\r\n        )\r\n\r\n        return this.createQueryBuilder()\r\n            .insert()\r\n            .into(target)\r\n            .values(entities)\r\n            .orUpdate(\r\n                [...conflictColumns, ...overwriteColumns].map(\r\n                    (col) => col.databaseName,\r\n                ),\r\n                conflictColumns.map((col) => col.databaseName),\r\n                {\r\n                    skipUpdateIfNoValuesChanged:\r\n                        options.skipUpdateIfNoValuesChanged,\r\n                    indexPredicate: options.indexPredicate,\r\n                    upsertType:\r\n                        options.upsertType ||\r\n                        this.connection.driver.supportedUpsertTypes[0],\r\n                },\r\n            )\r\n            .execute()\r\n    }\r\n\r\n    /**\r\n     * Updates entity partially. Entity can be found by a given condition(s).\r\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\r\n     * Executes fast and efficient UPDATE query.\r\n     * Does not check if entity exist in the database.\r\n     * Condition(s) cannot be empty.\r\n     */\r\n    update<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n        criteria:\r\n            | string\r\n            | string[]\r\n            | number\r\n            | number[]\r\n            | Date\r\n            | Date[]\r\n            | ObjectId\r\n            | ObjectId[]\r\n            | any,\r\n        partialEntity: QueryDeepPartialEntity<Entity>,\r\n    ): Promise<UpdateResult> {\r\n        // if user passed empty criteria or empty list of criterias, then throw an error\r\n        if (\r\n            criteria === undefined ||\r\n            criteria === null ||\r\n            criteria === \"\" ||\r\n            (Array.isArray(criteria) && criteria.length === 0)\r\n        ) {\r\n            return Promise.reject(\r\n                new TypeORMError(\r\n                    `Empty criteria(s) are not allowed for the update method.`,\r\n                ),\r\n            )\r\n        }\r\n\r\n        if (\r\n            typeof criteria === \"string\" ||\r\n            typeof criteria === \"number\" ||\r\n            criteria instanceof Date ||\r\n            Array.isArray(criteria)\r\n        ) {\r\n            return this.createQueryBuilder()\r\n                .update(target)\r\n                .set(partialEntity)\r\n                .whereInIds(criteria)\r\n                .execute()\r\n        } else {\r\n            return this.createQueryBuilder()\r\n                .update(target)\r\n                .set(partialEntity)\r\n                .where(criteria)\r\n                .execute()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes entities by a given condition(s).\r\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\r\n     * Executes fast and efficient DELETE query.\r\n     * Does not check if entity exist in the database.\r\n     * Condition(s) cannot be empty.\r\n     */\r\n    delete<Entity extends ObjectLiteral>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        criteria:\r\n            | string\r\n            | string[]\r\n            | number\r\n            | number[]\r\n            | Date\r\n            | Date[]\r\n            | ObjectId\r\n            | ObjectId[]\r\n            | any,\r\n    ): Promise<DeleteResult> {\r\n        // if user passed empty criteria or empty list of criterias, then throw an error\r\n        if (\r\n            criteria === undefined ||\r\n            criteria === null ||\r\n            criteria === \"\" ||\r\n            (Array.isArray(criteria) && criteria.length === 0)\r\n        ) {\r\n            return Promise.reject(\r\n                new TypeORMError(\r\n                    `Empty criteria(s) are not allowed for the delete method.`,\r\n                ),\r\n            )\r\n        }\r\n\r\n        if (\r\n            typeof criteria === \"string\" ||\r\n            typeof criteria === \"number\" ||\r\n            criteria instanceof Date ||\r\n            Array.isArray(criteria)\r\n        ) {\r\n            return this.createQueryBuilder()\r\n                .delete()\r\n                .from(targetOrEntity)\r\n                .whereInIds(criteria)\r\n                .execute()\r\n        } else {\r\n            return this.createQueryBuilder()\r\n                .delete()\r\n                .from(targetOrEntity)\r\n                .where(criteria)\r\n                .execute()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Records the delete date of entities by a given condition(s).\r\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\r\n     * Executes fast and efficient DELETE query.\r\n     * Does not check if entity exist in the database.\r\n     * Condition(s) cannot be empty.\r\n     */\r\n    softDelete<Entity extends ObjectLiteral>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        criteria:\r\n            | string\r\n            | string[]\r\n            | number\r\n            | number[]\r\n            | Date\r\n            | Date[]\r\n            | ObjectId\r\n            | ObjectId[]\r\n            | any,\r\n    ): Promise<UpdateResult> {\r\n        // if user passed empty criteria or empty list of criterias, then throw an error\r\n        if (\r\n            criteria === undefined ||\r\n            criteria === null ||\r\n            criteria === \"\" ||\r\n            (Array.isArray(criteria) && criteria.length === 0)\r\n        ) {\r\n            return Promise.reject(\r\n                new TypeORMError(\r\n                    `Empty criteria(s) are not allowed for the delete method.`,\r\n                ),\r\n            )\r\n        }\r\n\r\n        if (\r\n            typeof criteria === \"string\" ||\r\n            typeof criteria === \"number\" ||\r\n            criteria instanceof Date ||\r\n            Array.isArray(criteria)\r\n        ) {\r\n            return this.createQueryBuilder()\r\n                .softDelete()\r\n                .from(targetOrEntity)\r\n                .whereInIds(criteria)\r\n                .execute()\r\n        } else {\r\n            return this.createQueryBuilder()\r\n                .softDelete()\r\n                .from(targetOrEntity)\r\n                .where(criteria)\r\n                .execute()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restores entities by a given condition(s).\r\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\r\n     * Executes fast and efficient DELETE query.\r\n     * Does not check if entity exist in the database.\r\n     * Condition(s) cannot be empty.\r\n     */\r\n    restore<Entity extends ObjectLiteral>(\r\n        targetOrEntity: EntityTarget<Entity>,\r\n        criteria:\r\n            | string\r\n            | string[]\r\n            | number\r\n            | number[]\r\n            | Date\r\n            | Date[]\r\n            | ObjectId\r\n            | ObjectId[]\r\n            | any,\r\n    ): Promise<UpdateResult> {\r\n        // if user passed empty criteria or empty list of criterias, then throw an error\r\n        if (\r\n            criteria === undefined ||\r\n            criteria === null ||\r\n            criteria === \"\" ||\r\n            (Array.isArray(criteria) && criteria.length === 0)\r\n        ) {\r\n            return Promise.reject(\r\n                new TypeORMError(\r\n                    `Empty criteria(s) are not allowed for the delete method.`,\r\n                ),\r\n            )\r\n        }\r\n\r\n        if (\r\n            typeof criteria === \"string\" ||\r\n            typeof criteria === \"number\" ||\r\n            criteria instanceof Date ||\r\n            Array.isArray(criteria)\r\n        ) {\r\n            return this.createQueryBuilder()\r\n                .restore()\r\n                .from(targetOrEntity)\r\n                .whereInIds(criteria)\r\n                .execute()\r\n        } else {\r\n            return this.createQueryBuilder()\r\n                .restore()\r\n                .from(targetOrEntity)\r\n                .where(criteria)\r\n                .execute()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether any entity exists with the given options.\r\n     */\r\n    exists<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        options?: FindManyOptions<Entity>,\r\n    ): Promise<boolean> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder(\r\n            entityClass,\r\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\r\n                metadata.name,\r\n        )\r\n            .setFindOptions(options || {})\r\n            .getExists()\r\n    }\r\n\r\n    /**\r\n     * Checks whether any entity exists with the given conditions.\r\n     */\r\n    async existsBy<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<boolean> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder(entityClass, metadata.name)\r\n            .setFindOptions({ where })\r\n            .getExists()\r\n    }\r\n\r\n    /**\r\n     * Counts entities that match given options.\r\n     * Useful for pagination.\r\n     */\r\n    count<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        options?: FindManyOptions<Entity>,\r\n    ): Promise<number> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder(\r\n            entityClass,\r\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\r\n                metadata.name,\r\n        )\r\n            .setFindOptions(options || {})\r\n            .getCount()\r\n    }\r\n\r\n    /**\r\n     * Counts entities that match given conditions.\r\n     * Useful for pagination.\r\n     */\r\n    countBy<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<number> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder(entityClass, metadata.name)\r\n            .setFindOptions({ where })\r\n            .getCount()\r\n    }\r\n\r\n    /**\r\n     * Return the SUM of a column\r\n     */\r\n    sum<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        columnName: PickKeysByType<Entity, number>,\r\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<number | null> {\r\n        return this.callAggregateFun(entityClass, \"SUM\", columnName, where)\r\n    }\r\n\r\n    /**\r\n     * Return the AVG of a column\r\n     */\r\n    average<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        columnName: PickKeysByType<Entity, number>,\r\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<number | null> {\r\n        return this.callAggregateFun(entityClass, \"AVG\", columnName, where)\r\n    }\r\n\r\n    /**\r\n     * Return the MIN of a column\r\n     */\r\n    minimum<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        columnName: PickKeysByType<Entity, number>,\r\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<number | null> {\r\n        return this.callAggregateFun(entityClass, \"MIN\", columnName, where)\r\n    }\r\n\r\n    /**\r\n     * Return the MAX of a column\r\n     */\r\n    maximum<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        columnName: PickKeysByType<Entity, number>,\r\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<number | null> {\r\n        return this.callAggregateFun(entityClass, \"MAX\", columnName, where)\r\n    }\r\n\r\n    private async callAggregateFun<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        fnName: \"SUM\" | \"AVG\" | \"MIN\" | \"MAX\",\r\n        columnName: PickKeysByType<Entity, number>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[] = {},\r\n    ): Promise<number | null> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        const column = metadata.columns.find(\r\n            (item) => item.propertyPath === columnName,\r\n        )\r\n        if (!column) {\r\n            throw new TypeORMError(\r\n                `Column \"${columnName}\" was not found in table \"${metadata.name}\"`,\r\n            )\r\n        }\r\n\r\n        const result = await this.createQueryBuilder(entityClass, metadata.name)\r\n            .setFindOptions({ where })\r\n            .select(\r\n                `${fnName}(${this.connection.driver.escape(\r\n                    column.databaseName,\r\n                )})`,\r\n                fnName,\r\n            )\r\n            .getRawOne()\r\n        return result[fnName] === null ? null : parseFloat(result[fnName])\r\n    }\r\n\r\n    /**\r\n     * Finds entities that match given find options.\r\n     */\r\n    async find<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        options?: FindManyOptions<Entity>,\r\n    ): Promise<Entity[]> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder<Entity>(\r\n            entityClass as any,\r\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\r\n                metadata.name,\r\n        )\r\n            .setFindOptions(options || {})\r\n            .getMany()\r\n    }\r\n\r\n    /**\r\n     * Finds entities that match given find options.\r\n     */\r\n    async findBy<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<Entity[]> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder<Entity>(\r\n            entityClass as any,\r\n            metadata.name,\r\n        )\r\n            .setFindOptions({ where: where })\r\n            .getMany()\r\n    }\r\n\r\n    /**\r\n     * Finds entities that match given find options.\r\n     * Also counts all entities that match given conditions,\r\n     * but ignores pagination settings (from and take options).\r\n     */\r\n    findAndCount<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        options?: FindManyOptions<Entity>,\r\n    ): Promise<[Entity[], number]> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder<Entity>(\r\n            entityClass as any,\r\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\r\n                metadata.name,\r\n        )\r\n            .setFindOptions(options || {})\r\n            .getManyAndCount()\r\n    }\r\n\r\n    /**\r\n     * Finds entities that match given WHERE conditions.\r\n     * Also counts all entities that match given conditions,\r\n     * but ignores pagination settings (from and take options).\r\n     */\r\n    findAndCountBy<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<[Entity[], number]> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder<Entity>(\r\n            entityClass as any,\r\n            metadata.name,\r\n        )\r\n            .setFindOptions({ where })\r\n            .getManyAndCount()\r\n    }\r\n\r\n    /**\r\n     * Finds entities with ids.\r\n     * Optionally find options or conditions can be applied.\r\n     *\r\n     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\r\n     *\r\n     * .findBy({\r\n     *     id: In([1, 2, 3])\r\n     * })\r\n     */\r\n    async findByIds<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        ids: any[],\r\n    ): Promise<Entity[]> {\r\n        // if no ids passed, no need to execute a query - just return an empty array of values\r\n        if (!ids.length) return Promise.resolve([])\r\n\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        return this.createQueryBuilder<Entity>(\r\n            entityClass as any,\r\n            metadata.name,\r\n        )\r\n            .andWhereInIds(ids)\r\n            .getMany()\r\n    }\r\n\r\n    /**\r\n     * Finds first entity by a given find options.\r\n     * If entity was not found in the database - returns null.\r\n     */\r\n    async findOne<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        options: FindOneOptions<Entity>,\r\n    ): Promise<Entity | null> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n\r\n        // prepare alias for built query\r\n        let alias: string = metadata.name\r\n        if (options && options.join) {\r\n            alias = options.join.alias\r\n        }\r\n\r\n        if (!options.where) {\r\n            throw new Error(\r\n                `You must provide selection conditions in order to find a single row.`,\r\n            )\r\n        }\r\n\r\n        // create query builder and apply find options\r\n        return this.createQueryBuilder<Entity>(entityClass, alias)\r\n            .setFindOptions({\r\n                ...options,\r\n                take: 1,\r\n            })\r\n            .getOne()\r\n    }\r\n\r\n    /**\r\n     * Finds first entity that matches given where condition.\r\n     * If entity was not found in the database - returns null.\r\n     */\r\n    async findOneBy<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<Entity | null> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n\r\n        // create query builder and apply find options\r\n        return this.createQueryBuilder<Entity>(entityClass, metadata.name)\r\n            .setFindOptions({\r\n                where,\r\n                take: 1,\r\n            })\r\n            .getOne()\r\n    }\r\n\r\n    /**\r\n     * Finds first entity that matches given id.\r\n     * If entity was not found in the database - returns null.\r\n     *\r\n     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\r\n     *\r\n     * .findOneBy({\r\n     *     id: 1 // where \"id\" is your primary column name\r\n     * })\r\n     */\r\n    async findOneById<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        id: number | string | Date | ObjectId,\r\n    ): Promise<Entity | null> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n\r\n        // create query builder and apply find options\r\n        return this.createQueryBuilder<Entity>(entityClass, metadata.name)\r\n            .setFindOptions({\r\n                take: 1,\r\n            })\r\n            .whereInIds(metadata.ensureEntityIdMap(id))\r\n            .getOne()\r\n    }\r\n\r\n    /**\r\n     * Finds first entity by a given find options.\r\n     * If entity was not found in the database - rejects with error.\r\n     */\r\n    async findOneOrFail<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        options: FindOneOptions<Entity>,\r\n    ): Promise<Entity> {\r\n        return this.findOne<Entity>(entityClass as any, options).then(\r\n            (value) => {\r\n                if (value === null) {\r\n                    return Promise.reject(\r\n                        new EntityNotFoundError(entityClass, options),\r\n                    )\r\n                }\r\n                return Promise.resolve(value)\r\n            },\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Finds first entity that matches given where condition.\r\n     * If entity was not found in the database - rejects with error.\r\n     */\r\n    async findOneByOrFail<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\r\n    ): Promise<Entity> {\r\n        return this.findOneBy<Entity>(entityClass as any, where).then(\r\n            (value) => {\r\n                if (value === null) {\r\n                    return Promise.reject(\r\n                        new EntityNotFoundError(entityClass, where),\r\n                    )\r\n                }\r\n                return Promise.resolve(value)\r\n            },\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Clears all the data from the given table (truncates/drops it).\r\n     *\r\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\r\n     * @see https://stackoverflow.com/a/5972738/925151\r\n     */\r\n    async clear<Entity>(entityClass: EntityTarget<Entity>): Promise<void> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        const queryRunner =\r\n            this.queryRunner || this.connection.createQueryRunner()\r\n        try {\r\n            return await queryRunner.clearTable(metadata.tablePath) // await is needed here because we are using finally\r\n        } finally {\r\n            if (!this.queryRunner) await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increments some column by provided value of the entities matched given conditions.\r\n     */\r\n    async increment<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        conditions: any,\r\n        propertyPath: string,\r\n        value: number | string,\r\n    ): Promise<UpdateResult> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        const column = metadata.findColumnWithPropertyPath(propertyPath)\r\n        if (!column)\r\n            throw new TypeORMError(\r\n                `Column ${propertyPath} was not found in ${metadata.targetName} entity.`,\r\n            )\r\n\r\n        if (isNaN(Number(value)))\r\n            throw new TypeORMError(`Value \"${value}\" is not a number.`)\r\n\r\n        // convert possible embedded path \"social.likes\" into object { social: { like: () => value } }\r\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\r\n            .split(\".\")\r\n            .reduceRight(\r\n                (value, key) => ({ [key]: value } as any),\r\n                () =>\r\n                    this.connection.driver.escape(column.databaseName) +\r\n                    \" + \" +\r\n                    value,\r\n            )\r\n\r\n        return this.createQueryBuilder<Entity>(entityClass as any, \"entity\")\r\n            .update(entityClass)\r\n            .set(values)\r\n            .where(conditions)\r\n            .execute()\r\n    }\r\n\r\n    /**\r\n     * Decrements some column by provided value of the entities matched given conditions.\r\n     */\r\n    async decrement<Entity extends ObjectLiteral>(\r\n        entityClass: EntityTarget<Entity>,\r\n        conditions: any,\r\n        propertyPath: string,\r\n        value: number | string,\r\n    ): Promise<UpdateResult> {\r\n        const metadata = this.connection.getMetadata(entityClass)\r\n        const column = metadata.findColumnWithPropertyPath(propertyPath)\r\n        if (!column)\r\n            throw new TypeORMError(\r\n                `Column ${propertyPath} was not found in ${metadata.targetName} entity.`,\r\n            )\r\n\r\n        if (isNaN(Number(value)))\r\n            throw new TypeORMError(`Value \"${value}\" is not a number.`)\r\n\r\n        // convert possible embedded path \"social.likes\" into object { social: { like: () => value } }\r\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\r\n            .split(\".\")\r\n            .reduceRight(\r\n                (value, key) => ({ [key]: value } as any),\r\n                () =>\r\n                    this.connection.driver.escape(column.databaseName) +\r\n                    \" - \" +\r\n                    value,\r\n            )\r\n\r\n        return this.createQueryBuilder<Entity>(entityClass as any, \"entity\")\r\n            .update(entityClass)\r\n            .set(values)\r\n            .where(conditions)\r\n            .execute()\r\n    }\r\n\r\n    /**\r\n     * Gets repository for the given entity class or name.\r\n     * If single database connection mode is used, then repository is obtained from the\r\n     * repository aggregator, where each repository is individually created for this entity manager.\r\n     * When single database connection is not used, repository is being obtained from the connection.\r\n     */\r\n    getRepository<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n    ): Repository<Entity> {\r\n        // find already created repository instance and return it if found\r\n        const repoFromMap = this.repositories.get(target)\r\n        if (repoFromMap) return repoFromMap\r\n\r\n        // if repository was not found then create it, store its instance and return it\r\n        if (this.connection.driver.options.type === \"mongodb\") {\r\n            const newRepository = new MongoRepository(\r\n                target,\r\n                this,\r\n                this.queryRunner,\r\n            )\r\n            this.repositories.set(target, newRepository)\r\n            return newRepository\r\n        } else {\r\n            const newRepository = new Repository<any>(\r\n                target,\r\n                this,\r\n                this.queryRunner,\r\n            )\r\n            this.repositories.set(target, newRepository)\r\n            return newRepository\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets tree repository for the given entity class or name.\r\n     * If single database connection mode is used, then repository is obtained from the\r\n     * repository aggregator, where each repository is individually created for this entity manager.\r\n     * When single database connection is not used, repository is being obtained from the connection.\r\n     */\r\n    getTreeRepository<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n    ): TreeRepository<Entity> {\r\n        // tree tables aren't supported by some drivers (mongodb)\r\n        if (this.connection.driver.treeSupport === false)\r\n            throw new TreeRepositoryNotSupportedError(this.connection.driver)\r\n\r\n        // find already created repository instance and return it if found\r\n        const repository = this.treeRepositories.find(\r\n            (repository) => repository.target === target,\r\n        )\r\n        if (repository) return repository\r\n\r\n        // check if repository is real tree repository\r\n        const newRepository = new TreeRepository(target, this, this.queryRunner)\r\n        this.treeRepositories.push(newRepository)\r\n        return newRepository\r\n    }\r\n\r\n    /**\r\n     * Gets mongodb repository for the given entity class.\r\n     */\r\n    getMongoRepository<Entity extends ObjectLiteral>(\r\n        target: EntityTarget<Entity>,\r\n    ): MongoRepository<Entity> {\r\n        return this.connection.getMongoRepository<Entity>(target)\r\n    }\r\n\r\n    /**\r\n     * Creates a new repository instance out of a given Repository and\r\n     * sets current EntityManager instance to it. Used to work with custom repositories\r\n     * in transactions.\r\n     */\r\n    withRepository<Entity extends ObjectLiteral, R extends Repository<any>>(\r\n        repository: R & Repository<Entity>,\r\n    ): R {\r\n        const repositoryConstructor =\r\n            repository.constructor as typeof Repository\r\n        const { target, manager, queryRunner, ...otherRepositoryProperties } =\r\n            repository\r\n        return Object.assign(\r\n            new repositoryConstructor(repository.target, this) as R,\r\n            {\r\n                ...otherRepositoryProperties,\r\n            },\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Gets custom entity repository marked with @EntityRepository decorator.\r\n     *\r\n     * @deprecated use Repository.extend to create custom repositories\r\n     */\r\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\r\n        const entityRepositoryMetadataArgs =\r\n            getMetadataArgsStorage().entityRepositories.find((repository) => {\r\n                return (\r\n                    repository.target ===\r\n                    (typeof customRepository === \"function\"\r\n                        ? customRepository\r\n                        : (customRepository as any).constructor)\r\n                )\r\n            })\r\n        if (!entityRepositoryMetadataArgs)\r\n            throw new CustomRepositoryNotFoundError(customRepository)\r\n\r\n        const entityMetadata = entityRepositoryMetadataArgs.entity\r\n            ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity)\r\n            : undefined\r\n        const entityRepositoryInstance =\r\n            new (entityRepositoryMetadataArgs.target as any)(\r\n                this,\r\n                entityMetadata,\r\n            )\r\n\r\n        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\r\n        // however we need these properties for internal work of the class\r\n        if (entityRepositoryInstance instanceof AbstractRepository) {\r\n            if (!(entityRepositoryInstance as any)[\"manager\"])\r\n                (entityRepositoryInstance as any)[\"manager\"] = this\r\n        } else {\r\n            if (!entityMetadata)\r\n                throw new CustomRepositoryCannotInheritRepositoryError(\r\n                    customRepository,\r\n                )\r\n            ;(entityRepositoryInstance as any)[\"manager\"] = this\r\n            ;(entityRepositoryInstance as any)[\"metadata\"] = entityMetadata\r\n        }\r\n\r\n        return entityRepositoryInstance\r\n    }\r\n\r\n    /**\r\n     * Releases all resources used by entity manager.\r\n     * This is used when entity manager is created with a single query runner,\r\n     * and this single query runner needs to be released after job with entity manager is done.\r\n     */\r\n    async release(): Promise<void> {\r\n        if (!this.queryRunner) throw new NoNeedToReleaseEntityManagerError()\r\n\r\n        return this.queryRunner.release()\r\n    }\r\n}\r\n"],"sourceRoot":".."}