{"version":3,"sources":["../browser/src/query-builder/QueryBuilder.ts"],"names":[],"mappings":"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","file":"QueryBuilder.js","sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\r\nimport { DataSource } from \"../data-source/DataSource\"\r\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\r\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\r\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\r\nimport { UpdateQueryBuilder } from \"./UpdateQueryBuilder\"\r\nimport { DeleteQueryBuilder } from \"./DeleteQueryBuilder\"\r\nimport { SoftDeleteQueryBuilder } from \"./SoftDeleteQueryBuilder\"\r\nimport { InsertQueryBuilder } from \"./InsertQueryBuilder\"\r\nimport { RelationQueryBuilder } from \"./RelationQueryBuilder\"\r\nimport { EntityTarget } from \"../common/EntityTarget\"\r\nimport { Alias } from \"./Alias\"\r\nimport { Brackets } from \"./Brackets\"\r\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\r\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\r\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\r\nimport { FindOperator } from \"../find-options/FindOperator\"\r\nimport { In } from \"../find-options/operator/In\"\r\nimport { TypeORMError } from \"../error\"\r\nimport { WhereClause, WhereClauseCondition } from \"./WhereClause\"\r\nimport { NotBrackets } from \"./NotBrackets\"\r\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\r\nimport { ReturningType } from \"../driver/Driver\"\r\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { escapeRegExp } from \"../util/escapeRegExp\"\r\n\r\n// todo: completely cover query builder with tests\r\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\r\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\r\n// todo: fix problem with long aliases eg getMaxIdentifierLength\r\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\r\n// todo: implement joinAlways in relations and relationId\r\n// todo: finish partial selection\r\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\r\n// todo: implement @Select decorator\r\n// todo: add select and map functions\r\n\r\n// todo: implement relation/entity loading and setting them into properties within a separate query\r\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\r\n// .loadAndMap(\"post.categories\", Category, qb => ...)\r\n\r\n/**\r\n * Allows to build complex sql queries in a fashion way and execute those queries.\r\n */\r\nexport abstract class QueryBuilder<Entity extends ObjectLiteral> {\r\n    readonly \"@instanceof\" = Symbol.for(\"QueryBuilder\")\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Connection on which QueryBuilder was created.\r\n     */\r\n    readonly connection: DataSource\r\n\r\n    /**\r\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\r\n     */\r\n    readonly expressionMap: QueryExpressionMap\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Query runner used to execute query builder query.\r\n     */\r\n    protected queryRunner?: QueryRunner\r\n\r\n    /**\r\n     * If QueryBuilder was created in a subquery mode then its parent QueryBuilder (who created subquery) will be stored here.\r\n     */\r\n    protected parentQueryBuilder: QueryBuilder<any>\r\n\r\n    /**\r\n     * Memo to help keep place of current parameter index for `createParameter`\r\n     */\r\n    private parameterIndex = 0\r\n\r\n    /**\r\n     * Contains all registered query builder classes.\r\n     */\r\n    private static queryBuilderRegistry: Record<string, any> = {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\r\n     */\r\n    constructor(queryBuilder: QueryBuilder<any>)\r\n\r\n    /**\r\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\r\n     */\r\n    constructor(connection: DataSource, queryRunner?: QueryRunner)\r\n\r\n    /**\r\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\r\n     */\r\n    constructor(\r\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\r\n        queryRunner?: QueryRunner,\r\n    ) {\r\n        if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {\r\n            this.connection = connectionOrQueryBuilder\r\n            this.queryRunner = queryRunner\r\n            this.expressionMap = new QueryExpressionMap(this.connection)\r\n        } else {\r\n            this.connection = connectionOrQueryBuilder.connection\r\n            this.queryRunner = connectionOrQueryBuilder.queryRunner\r\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone()\r\n        }\r\n    }\r\n\r\n    static registerQueryBuilderClass(name: string, factory: any) {\r\n        QueryBuilder.queryBuilderRegistry[name] = factory\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Abstract Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets generated SQL query without parameters being replaced.\r\n     */\r\n    abstract getQuery(): string\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Accessors\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the main alias string used in this query builder.\r\n     */\r\n    get alias(): string {\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new TypeORMError(`Main alias is not set`) // todo: better exception\r\n\r\n        return this.expressionMap.mainAlias.name\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates SELECT query.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(): SelectQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(\r\n        selection: string,\r\n        selectionAliasName?: string,\r\n    ): SelectQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string[]): SelectQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(\r\n        selection?: string | string[],\r\n        selectionAliasName?: string,\r\n    ): SelectQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"select\"\r\n        if (Array.isArray(selection)) {\r\n            this.expressionMap.selects = selection.map((selection) => ({\r\n                selection: selection,\r\n            }))\r\n        } else if (selection) {\r\n            this.expressionMap.selects = [\r\n                { selection: selection, aliasName: selectionAliasName },\r\n            ]\r\n        }\r\n\r\n        if (InstanceChecker.isSelectQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"SelectQueryBuilder\"](this)\r\n    }\r\n\r\n    /**\r\n     * Creates INSERT query.\r\n     */\r\n    insert(): InsertQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"insert\"\r\n\r\n        if (InstanceChecker.isInsertQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"InsertQueryBuilder\"](this)\r\n    }\r\n\r\n    /**\r\n     * Creates UPDATE query and applies given update values.\r\n     */\r\n    update(): UpdateQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates UPDATE query and applies given update values.\r\n     */\r\n    update(\r\n        updateSet: QueryDeepPartialEntity<Entity>,\r\n    ): UpdateQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates UPDATE query for the given entity and applies given update values.\r\n     */\r\n    update<Entity extends ObjectLiteral>(\r\n        entity: EntityTarget<Entity>,\r\n        updateSet?: QueryDeepPartialEntity<Entity>,\r\n    ): UpdateQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates UPDATE query for the given table name and applies given update values.\r\n     */\r\n    update(\r\n        tableName: string,\r\n        updateSet?: QueryDeepPartialEntity<Entity>,\r\n    ): UpdateQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Creates UPDATE query and applies given update values.\r\n     */\r\n    update(\r\n        entityOrTableNameUpdateSet?: EntityTarget<any> | ObjectLiteral,\r\n        maybeUpdateSet?: ObjectLiteral,\r\n    ): UpdateQueryBuilder<any> {\r\n        const updateSet = maybeUpdateSet\r\n            ? maybeUpdateSet\r\n            : (entityOrTableNameUpdateSet as ObjectLiteral | undefined)\r\n        entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(\r\n            entityOrTableNameUpdateSet,\r\n        )\r\n            ? entityOrTableNameUpdateSet.options.name\r\n            : entityOrTableNameUpdateSet\r\n\r\n        if (\r\n            typeof entityOrTableNameUpdateSet === \"function\" ||\r\n            typeof entityOrTableNameUpdateSet === \"string\"\r\n        ) {\r\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet)\r\n            this.expressionMap.setMainAlias(mainAlias)\r\n        }\r\n\r\n        this.expressionMap.queryType = \"update\"\r\n        this.expressionMap.valuesSet = updateSet\r\n\r\n        if (InstanceChecker.isUpdateQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"UpdateQueryBuilder\"](this)\r\n    }\r\n\r\n    /**\r\n     * Creates DELETE query.\r\n     */\r\n    delete(): DeleteQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"delete\"\r\n\r\n        if (InstanceChecker.isDeleteQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"DeleteQueryBuilder\"](this)\r\n    }\r\n\r\n    softDelete(): SoftDeleteQueryBuilder<any> {\r\n        this.expressionMap.queryType = \"soft-delete\"\r\n\r\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this)\r\n    }\r\n\r\n    restore(): SoftDeleteQueryBuilder<any> {\r\n        this.expressionMap.queryType = \"restore\"\r\n\r\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this)\r\n    }\r\n\r\n    /**\r\n     * Sets entity's relation with which this query builder gonna work.\r\n     */\r\n    relation(propertyPath: string): RelationQueryBuilder<Entity>\r\n\r\n    /**\r\n     * Sets entity's relation with which this query builder gonna work.\r\n     */\r\n    relation<T extends ObjectLiteral>(\r\n        entityTarget: EntityTarget<T>,\r\n        propertyPath: string,\r\n    ): RelationQueryBuilder<T>\r\n\r\n    /**\r\n     * Sets entity's relation with which this query builder gonna work.\r\n     */\r\n    relation(\r\n        entityTargetOrPropertyPath: Function | string,\r\n        maybePropertyPath?: string,\r\n    ): RelationQueryBuilder<Entity> {\r\n        const entityTarget =\r\n            arguments.length === 2 ? entityTargetOrPropertyPath : undefined\r\n        const propertyPath =\r\n            arguments.length === 2\r\n                ? (maybePropertyPath as string)\r\n                : (entityTargetOrPropertyPath as string)\r\n\r\n        this.expressionMap.queryType = \"relation\"\r\n        this.expressionMap.relationPropertyPath = propertyPath\r\n\r\n        if (entityTarget) {\r\n            const mainAlias = this.createFromAlias(entityTarget)\r\n            this.expressionMap.setMainAlias(mainAlias)\r\n        }\r\n\r\n        if (InstanceChecker.isRelationQueryBuilder(this)) return this as any\r\n\r\n        return QueryBuilder.queryBuilderRegistry[\"RelationQueryBuilder\"](this)\r\n    }\r\n\r\n    /**\r\n     * Checks if given relation exists in the entity.\r\n     * Returns true if relation exists, false otherwise.\r\n     *\r\n     * todo: move this method to manager? or create a shortcut?\r\n     */\r\n    hasRelation<T>(target: EntityTarget<T>, relation: string): boolean\r\n\r\n    /**\r\n     * Checks if given relations exist in the entity.\r\n     * Returns true if relation exists, false otherwise.\r\n     *\r\n     * todo: move this method to manager? or create a shortcut?\r\n     */\r\n    hasRelation<T>(target: EntityTarget<T>, relation: string[]): boolean\r\n\r\n    /**\r\n     * Checks if given relation or relations exist in the entity.\r\n     * Returns true if relation exists, false otherwise.\r\n     *\r\n     * todo: move this method to manager? or create a shortcut?\r\n     */\r\n    hasRelation<T>(\r\n        target: EntityTarget<T>,\r\n        relation: string | string[],\r\n    ): boolean {\r\n        const entityMetadata = this.connection.getMetadata(target)\r\n        const relations = Array.isArray(relation) ? relation : [relation]\r\n        return relations.every((relation) => {\r\n            return !!entityMetadata.findRelationWithPropertyPath(relation)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check the existence of a parameter for this query builder.\r\n     */\r\n    hasParameter(key: string): boolean {\r\n        return (\r\n            this.parentQueryBuilder?.hasParameter(key) ||\r\n            key in this.expressionMap.parameters\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Sets parameter name and its value.\r\n     *\r\n     * The key for this parameter may contain numbers, letters, underscores, or periods.\r\n     */\r\n    setParameter(key: string, value: any): this {\r\n        if (typeof value === \"function\") {\r\n            throw new TypeORMError(\r\n                `Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`,\r\n            )\r\n        }\r\n\r\n        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\r\n            throw new TypeORMError(\r\n                \"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\",\r\n            )\r\n        }\r\n\r\n        if (this.parentQueryBuilder) {\r\n            this.parentQueryBuilder.setParameter(key, value)\r\n        }\r\n\r\n        this.expressionMap.parameters[key] = value\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds all parameters from the given object.\r\n     */\r\n    setParameters(parameters: ObjectLiteral): this {\r\n        for (const [key, value] of Object.entries(parameters)) {\r\n            this.setParameter(key, value)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    protected createParameter(value: any): string {\r\n        let parameterName\r\n\r\n        do {\r\n            parameterName = `orm_param_${this.parameterIndex++}`\r\n        } while (this.hasParameter(parameterName))\r\n\r\n        this.setParameter(parameterName, value)\r\n\r\n        return `:${parameterName}`\r\n    }\r\n\r\n    /**\r\n     * Adds native parameters from the given object.\r\n     *\r\n     * @deprecated Use `setParameters` instead\r\n     */\r\n    setNativeParameters(parameters: ObjectLiteral): this {\r\n        // set parent query builder parameters as well in sub-query mode\r\n        if (this.parentQueryBuilder) {\r\n            this.parentQueryBuilder.setNativeParameters(parameters)\r\n        }\r\n\r\n        Object.keys(parameters).forEach((key) => {\r\n            this.expressionMap.nativeParameters[key] = parameters[key]\r\n        })\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Gets all parameters.\r\n     */\r\n    getParameters(): ObjectLiteral {\r\n        const parameters: ObjectLiteral = Object.assign(\r\n            {},\r\n            this.expressionMap.parameters,\r\n        )\r\n\r\n        // add discriminator column parameter if it exist\r\n        if (\r\n            this.expressionMap.mainAlias &&\r\n            this.expressionMap.mainAlias.hasMetadata\r\n        ) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata\r\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\r\n                const values = metadata.childEntityMetadatas\r\n                    .filter(\r\n                        (childMetadata) => childMetadata.discriminatorColumn,\r\n                    )\r\n                    .map((childMetadata) => childMetadata.discriminatorValue)\r\n                values.push(metadata.discriminatorValue)\r\n                parameters[\"discriminatorColumnValues\"] = values\r\n            }\r\n        }\r\n\r\n        return parameters\r\n    }\r\n\r\n    /**\r\n     * Prints sql to stdout using console.log.\r\n     */\r\n    printSql(): this {\r\n        // TODO rename to logSql()\r\n        const [query, parameters] = this.getQueryAndParameters()\r\n        this.connection.logger.logQuery(query, parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Gets generated sql that will be executed.\r\n     * Parameters in the query are escaped for the currently used driver.\r\n     */\r\n    getSql(): string {\r\n        return this.getQueryAndParameters()[0]\r\n    }\r\n\r\n    /**\r\n     * Gets query to be executed with all parameters used in it.\r\n     */\r\n    getQueryAndParameters(): [string, any[]] {\r\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\r\n        const query = this.getQuery()\r\n        const parameters = this.getParameters()\r\n        return this.connection.driver.escapeQueryWithParameters(\r\n            query,\r\n            parameters,\r\n            this.expressionMap.nativeParameters,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Executes sql generated by query builder and returns raw database results.\r\n     */\r\n    async execute(): Promise<any> {\r\n        const [sql, parameters] = this.getQueryAndParameters()\r\n        const queryRunner = this.obtainQueryRunner()\r\n        try {\r\n            return await queryRunner.query(sql, parameters) // await is needed here because we are using finally\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) {\r\n                // means we created our own query runner\r\n                await queryRunner.release()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a completely new query builder.\r\n     * Uses same query runner as current QueryBuilder.\r\n     */\r\n    createQueryBuilder(queryRunner?: QueryRunner): this {\r\n        return new (this.constructor as any)(\r\n            this.connection,\r\n            queryRunner ?? this.queryRunner,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Clones query builder as it is.\r\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\r\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\r\n     * where queryBuilder is cloned QueryBuilder.\r\n     */\r\n    clone(): this {\r\n        return new (this.constructor as any)(this)\r\n    }\r\n\r\n    /**\r\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\r\n     * such as finding a specific query in the database server's logs, or for categorization using\r\n     * an APM product.\r\n     */\r\n    comment(comment: string): this {\r\n        this.expressionMap.comment = comment\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Disables escaping.\r\n     */\r\n    disableEscaping(): this {\r\n        this.expressionMap.disableEscaping = false\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Escapes table name, column name or alias name using current database's escaping character.\r\n     */\r\n    escape(name: string): string {\r\n        if (!this.expressionMap.disableEscaping) return name\r\n        return this.connection.driver.escape(name)\r\n    }\r\n\r\n    /**\r\n     * Sets or overrides query builder's QueryRunner.\r\n     */\r\n    setQueryRunner(queryRunner: QueryRunner): this {\r\n        this.queryRunner = queryRunner\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Indicates if listeners and subscribers must be called before and after query execution.\r\n     * Enabled by default.\r\n     */\r\n    callListeners(enabled: boolean): this {\r\n        this.expressionMap.callListeners = enabled\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * If set to true the query will be wrapped into a transaction.\r\n     */\r\n    useTransaction(enabled: boolean): this {\r\n        this.expressionMap.useTransaction = enabled\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds CTE to query\r\n     */\r\n    addCommonTableExpression(\r\n        queryBuilder: QueryBuilder<any> | string,\r\n        alias: string,\r\n        options?: QueryBuilderCteOptions,\r\n    ): this {\r\n        this.expressionMap.commonTableExpressions.push({\r\n            queryBuilder,\r\n            alias,\r\n            options: options || {},\r\n        })\r\n        return this\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets escaped table name with schema name if SqlServer driver used with custom\r\n     * schema name, otherwise returns escaped table name.\r\n     */\r\n    protected getTableName(tablePath: string): string {\r\n        return tablePath\r\n            .split(\".\")\r\n            .map((i) => {\r\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\r\n                if (i === \"\") return i\r\n                return this.escape(i)\r\n            })\r\n            .join(\".\")\r\n    }\r\n\r\n    /**\r\n     * Gets name of the table where insert should be performed.\r\n     */\r\n    protected getMainTableName(): string {\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new TypeORMError(\r\n                `Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`,\r\n            )\r\n\r\n        if (this.expressionMap.mainAlias.hasMetadata)\r\n            return this.expressionMap.mainAlias.metadata.tablePath\r\n\r\n        return this.expressionMap.mainAlias.tablePath!\r\n    }\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    protected createFromAlias(\r\n        entityTarget:\r\n            | EntityTarget<any>\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        aliasName?: string,\r\n    ): Alias {\r\n        // if table has a metadata then find it to properly escape its properties\r\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\r\n        if (this.connection.hasMetadata(entityTarget)) {\r\n            const metadata = this.connection.getMetadata(entityTarget)\r\n\r\n            return this.expressionMap.createAlias({\r\n                type: \"from\",\r\n                name: aliasName,\r\n                metadata: this.connection.getMetadata(entityTarget),\r\n                tablePath: metadata.tablePath,\r\n            })\r\n        } else {\r\n            if (typeof entityTarget === \"string\") {\r\n                const isSubquery =\r\n                    entityTarget.substr(0, 1) === \"(\" &&\r\n                    entityTarget.substr(-1) === \")\"\r\n\r\n                return this.expressionMap.createAlias({\r\n                    type: \"from\",\r\n                    name: aliasName,\r\n                    tablePath: !isSubquery\r\n                        ? (entityTarget as string)\r\n                        : undefined,\r\n                    subQuery: isSubquery ? entityTarget : undefined,\r\n                })\r\n            }\r\n\r\n            const subQueryBuilder: SelectQueryBuilder<any> = (\r\n                entityTarget as any\r\n            )((this as any as SelectQueryBuilder<any>).subQuery())\r\n            this.setParameters(subQueryBuilder.getParameters())\r\n            const subquery = subQueryBuilder.getQuery()\r\n\r\n            return this.expressionMap.createAlias({\r\n                type: \"from\",\r\n                name: aliasName,\r\n                subQuery: subquery,\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated this way of replace property names is too slow.\r\n     *  Instead, we'll replace property names at the end - once query is build.\r\n     */\r\n    protected replacePropertyNames(statement: string) {\r\n        return statement\r\n    }\r\n\r\n    /**\r\n     * Replaces all entity's propertyName to name in the given SQL string.\r\n     */\r\n    protected replacePropertyNamesForTheWholeQuery(statement: string) {\r\n        const replacements: { [key: string]: { [key: string]: string } } = {}\r\n\r\n        for (const alias of this.expressionMap.aliases) {\r\n            if (!alias.hasMetadata) continue\r\n            const replaceAliasNamePrefix =\r\n                this.expressionMap.aliasNamePrefixingEnabled && alias.name\r\n                    ? `${alias.name}.`\r\n                    : \"\"\r\n\r\n            if (!replacements[replaceAliasNamePrefix]) {\r\n                replacements[replaceAliasNamePrefix] = {}\r\n            }\r\n\r\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\r\n            // To do this we iterate and overwrite in the order of relevance.\r\n            // Least to Most Relevant:\r\n            // * Relation Property Path to first join column key\r\n            // * Relation Property Path + Column Path\r\n            // * Column Database Name\r\n            // * Column Property Name\r\n            // * Column Property Path\r\n\r\n            for (const relation of alias.metadata.relations) {\r\n                if (relation.joinColumns.length > 0)\r\n                    replacements[replaceAliasNamePrefix][\r\n                        relation.propertyPath\r\n                    ] = relation.joinColumns[0].databaseName\r\n            }\r\n\r\n            for (const relation of alias.metadata.relations) {\r\n                const allColumns = [\r\n                    ...relation.joinColumns,\r\n                    ...relation.inverseJoinColumns,\r\n                ]\r\n                for (const joinColumn of allColumns) {\r\n                    const propertyKey = `${relation.propertyPath}.${\r\n                        joinColumn.referencedColumn!.propertyPath\r\n                    }`\r\n                    replacements[replaceAliasNamePrefix][propertyKey] =\r\n                        joinColumn.databaseName\r\n                }\r\n            }\r\n\r\n            for (const column of alias.metadata.columns) {\r\n                replacements[replaceAliasNamePrefix][column.databaseName] =\r\n                    column.databaseName\r\n            }\r\n\r\n            for (const column of alias.metadata.columns) {\r\n                replacements[replaceAliasNamePrefix][column.propertyName] =\r\n                    column.databaseName\r\n            }\r\n\r\n            for (const column of alias.metadata.columns) {\r\n                replacements[replaceAliasNamePrefix][column.propertyPath] =\r\n                    column.databaseName\r\n            }\r\n        }\r\n\r\n        const replacementKeys = Object.keys(replacements)\r\n        const replaceAliasNamePrefixes = replacementKeys\r\n            .map((key) => escapeRegExp(key))\r\n            .join(\"|\")\r\n\r\n        if (replacementKeys.length > 0) {\r\n            statement = statement.replace(\r\n                new RegExp(\r\n                    // Avoid a lookbehind here since it's not well supported\r\n                    `([ =(]|^.{0})` + // any of ' =(' or start of line\r\n                        // followed by our prefix, e.g. 'tablename.' or ''\r\n                        `${\r\n                            replaceAliasNamePrefixes\r\n                                ? \"(\" + replaceAliasNamePrefixes + \")\"\r\n                                : \"\"\r\n                        }([^ =(),]+)` + // a possible property name: sequence of anything but ' =(),'\r\n                        // terminated by ' =),' or end of line\r\n                        `(?=[ =),]|.{0}$)`,\r\n                    \"gm\",\r\n                ),\r\n                (...matches) => {\r\n                    let match: string, pre: string, p: string\r\n                    if (replaceAliasNamePrefixes) {\r\n                        match = matches[0]\r\n                        pre = matches[1]\r\n                        p = matches[3]\r\n\r\n                        if (replacements[matches[2]][p]) {\r\n                            return `${pre}${this.escape(\r\n                                matches[2].substring(0, matches[2].length - 1),\r\n                            )}.${this.escape(replacements[matches[2]][p])}`\r\n                        }\r\n                    } else {\r\n                        match = matches[0]\r\n                        pre = matches[1]\r\n                        p = matches[2]\r\n\r\n                        if (replacements[\"\"][p]) {\r\n                            return `${pre}${this.escape(replacements[\"\"][p])}`\r\n                        }\r\n                    }\r\n                    return match\r\n                },\r\n            )\r\n        }\r\n\r\n        return statement\r\n    }\r\n\r\n    protected createComment(): string {\r\n        if (!this.expressionMap.comment) {\r\n            return \"\"\r\n        }\r\n\r\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\r\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\r\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\r\n        // as-is and it should be valid.\r\n\r\n        return `/* ${this.expressionMap.comment.replace(/\\*\\//g, \"\")} */ `\r\n    }\r\n\r\n    /**\r\n     * Time travel queries for CockroachDB\r\n     */\r\n    protected createTimeTravelQuery(): string {\r\n        if (\r\n            this.expressionMap.queryType === \"select\" &&\r\n            this.expressionMap.timeTravel\r\n        ) {\r\n            return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`\r\n        }\r\n\r\n        return \"\"\r\n    }\r\n\r\n    /**\r\n     * Creates \"WHERE\" expression.\r\n     */\r\n    protected createWhereExpression() {\r\n        const conditionsArray = []\r\n\r\n        const whereExpression = this.createWhereClausesExpression(\r\n            this.expressionMap.wheres,\r\n        )\r\n\r\n        if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\r\n            conditionsArray.push(this.replacePropertyNames(whereExpression))\r\n        }\r\n\r\n        if (this.expressionMap.mainAlias!.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata\r\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\r\n            if (\r\n                this.expressionMap.queryType === \"select\" &&\r\n                !this.expressionMap.withDeleted &&\r\n                metadata.deleteDateColumn\r\n            ) {\r\n                const column = this.expressionMap.aliasNamePrefixingEnabled\r\n                    ? this.expressionMap.mainAlias!.name +\r\n                      \".\" +\r\n                      metadata.deleteDateColumn.propertyName\r\n                    : metadata.deleteDateColumn.propertyName\r\n\r\n                const condition = `${this.replacePropertyNames(column)} IS NULL`\r\n                conditionsArray.push(condition)\r\n            }\r\n\r\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\r\n                const column = this.expressionMap.aliasNamePrefixingEnabled\r\n                    ? this.expressionMap.mainAlias!.name +\r\n                      \".\" +\r\n                      metadata.discriminatorColumn.databaseName\r\n                    : metadata.discriminatorColumn.databaseName\r\n\r\n                const condition = `${this.replacePropertyNames(\r\n                    column,\r\n                )} IN (:...discriminatorColumnValues)`\r\n                conditionsArray.push(condition)\r\n            }\r\n        }\r\n\r\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\r\n            const condition = this.replacePropertyNames(\r\n                this.expressionMap.extraAppendedAndWhereCondition,\r\n            )\r\n            conditionsArray.push(condition)\r\n        }\r\n\r\n        let condition = \"\"\r\n\r\n        // time travel\r\n        condition += this.createTimeTravelQuery()\r\n\r\n        if (!conditionsArray.length) {\r\n            condition += \"\"\r\n        } else if (conditionsArray.length === 1) {\r\n            condition += ` WHERE ${conditionsArray[0]}`\r\n        } else {\r\n            condition += ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`\r\n        }\r\n\r\n        return condition\r\n    }\r\n\r\n    /**\r\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\r\n     */\r\n    protected createReturningExpression(returningType: ReturningType): string {\r\n        const columns = this.getReturningColumns()\r\n        const driver = this.connection.driver\r\n\r\n        // also add columns we must auto-return to perform entity updation\r\n        // if user gave his own returning\r\n        if (\r\n            typeof this.expressionMap.returning !== \"string\" &&\r\n            this.expressionMap.extraReturningColumns.length > 0 &&\r\n            driver.isReturningSqlSupported(returningType)\r\n        ) {\r\n            columns.push(\r\n                ...this.expressionMap.extraReturningColumns.filter((column) => {\r\n                    return columns.indexOf(column) === -1\r\n                }),\r\n            )\r\n        }\r\n\r\n        if (columns.length) {\r\n            let columnsExpression = columns\r\n                .map((column) => {\r\n                    const name = this.escape(column.databaseName)\r\n                    if (driver.options.type === \"mssql\") {\r\n                        if (\r\n                            this.expressionMap.queryType === \"insert\" ||\r\n                            this.expressionMap.queryType === \"update\" ||\r\n                            this.expressionMap.queryType === \"soft-delete\" ||\r\n                            this.expressionMap.queryType === \"restore\"\r\n                        ) {\r\n                            return \"INSERTED.\" + name\r\n                        } else {\r\n                            return (\r\n                                this.escape(this.getMainTableName()) +\r\n                                \".\" +\r\n                                name\r\n                            )\r\n                        }\r\n                    } else {\r\n                        return name\r\n                    }\r\n                })\r\n                .join(\", \")\r\n\r\n            if (driver.options.type === \"oracle\") {\r\n                columnsExpression +=\r\n                    \" INTO \" +\r\n                    columns\r\n                        .map((column) => {\r\n                            return this.createParameter({\r\n                                type: (\r\n                                    driver as OracleDriver\r\n                                ).columnTypeToNativeParameter(column.type),\r\n                                dir: (driver as OracleDriver).oracle.BIND_OUT,\r\n                            })\r\n                        })\r\n                        .join(\", \")\r\n            }\r\n\r\n            if (driver.options.type === \"mssql\") {\r\n                if (\r\n                    this.expressionMap.queryType === \"insert\" ||\r\n                    this.expressionMap.queryType === \"update\"\r\n                ) {\r\n                    columnsExpression += \" INTO @OutputTable\"\r\n                }\r\n            }\r\n\r\n            return columnsExpression\r\n        } else if (typeof this.expressionMap.returning === \"string\") {\r\n            return this.expressionMap.returning\r\n        }\r\n\r\n        return \"\"\r\n    }\r\n\r\n    /**\r\n     * If returning / output cause is set to array of column names,\r\n     * then this method will return all column metadatas of those column names.\r\n     */\r\n    protected getReturningColumns(): ColumnMetadata[] {\r\n        const columns: ColumnMetadata[] = []\r\n        if (Array.isArray(this.expressionMap.returning)) {\r\n            ;(this.expressionMap.returning as string[]).forEach(\r\n                (columnName) => {\r\n                    if (this.expressionMap.mainAlias!.hasMetadata) {\r\n                        columns.push(\r\n                            ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\r\n                                columnName,\r\n                            ),\r\n                        )\r\n                    }\r\n                },\r\n            )\r\n        }\r\n        return columns\r\n    }\r\n\r\n    protected createWhereClausesExpression(clauses: WhereClause[]): string {\r\n        return clauses\r\n            .map((clause, index) => {\r\n                const expression = this.createWhereConditionExpression(\r\n                    clause.condition,\r\n                )\r\n\r\n                switch (clause.type) {\r\n                    case \"and\":\r\n                        return (\r\n                            (index > 0 ? \"AND \" : \"\") +\r\n                            `${\r\n                                this.connection.options.isolateWhereStatements\r\n                                    ? \"(\"\r\n                                    : \"\"\r\n                            }${expression}${\r\n                                this.connection.options.isolateWhereStatements\r\n                                    ? \")\"\r\n                                    : \"\"\r\n                            }`\r\n                        )\r\n                    case \"or\":\r\n                        return (\r\n                            (index > 0 ? \"OR \" : \"\") +\r\n                            `${\r\n                                this.connection.options.isolateWhereStatements\r\n                                    ? \"(\"\r\n                                    : \"\"\r\n                            }${expression}${\r\n                                this.connection.options.isolateWhereStatements\r\n                                    ? \")\"\r\n                                    : \"\"\r\n                            }`\r\n                        )\r\n                }\r\n\r\n                return expression\r\n            })\r\n            .join(\" \")\r\n            .trim()\r\n    }\r\n\r\n    /**\r\n     * Computes given where argument - transforms to a where string all forms it can take.\r\n     */\r\n    protected createWhereConditionExpression(\r\n        condition: WhereClauseCondition,\r\n        alwaysWrap: boolean = false,\r\n    ): string {\r\n        if (typeof condition === \"string\") return condition\r\n\r\n        if (Array.isArray(condition)) {\r\n            if (condition.length === 0) {\r\n                return \"1=1\"\r\n            }\r\n\r\n            // In the future we should probably remove this entire condition\r\n            // but for now to prevent any breaking changes it exists.\r\n            if (condition.length === 1 && !alwaysWrap) {\r\n                return this.createWhereClausesExpression(condition)\r\n            }\r\n\r\n            return \"(\" + this.createWhereClausesExpression(condition) + \")\"\r\n        }\r\n\r\n        const { driver } = this.connection\r\n\r\n        switch (condition.operator) {\r\n            case \"lessThan\":\r\n                return `${condition.parameters[0]} < ${condition.parameters[1]}`\r\n            case \"lessThanOrEqual\":\r\n                return `${condition.parameters[0]} <= ${condition.parameters[1]}`\r\n            case \"arrayContains\":\r\n                return `${condition.parameters[0]} @> ${condition.parameters[1]}`\r\n            case \"jsonContains\":\r\n                return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`\r\n            case \"arrayContainedBy\":\r\n                return `${condition.parameters[0]} <@ ${condition.parameters[1]}`\r\n            case \"arrayOverlap\":\r\n                return `${condition.parameters[0]} && ${condition.parameters[1]}`\r\n            case \"moreThan\":\r\n                return `${condition.parameters[0]} > ${condition.parameters[1]}`\r\n            case \"moreThanOrEqual\":\r\n                return `${condition.parameters[0]} >= ${condition.parameters[1]}`\r\n            case \"notEqual\":\r\n                return `${condition.parameters[0]} != ${condition.parameters[1]}`\r\n            case \"equal\":\r\n                return `${condition.parameters[0]} = ${condition.parameters[1]}`\r\n            case \"ilike\":\r\n                if (\r\n                    driver.options.type === \"postgres\" ||\r\n                    driver.options.type === \"cockroachdb\"\r\n                ) {\r\n                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`\r\n                }\r\n\r\n                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`\r\n            case \"like\":\r\n                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`\r\n            case \"between\":\r\n                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`\r\n            case \"in\":\r\n                if (condition.parameters.length <= 1) {\r\n                    return \"0=1\"\r\n                }\r\n                return `${condition.parameters[0]} IN (${condition.parameters\r\n                    .slice(1)\r\n                    .join(\", \")})`\r\n            case \"any\":\r\n                if (driver.options.type === \"cockroachdb\") {\r\n                    return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`\r\n                }\r\n\r\n                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`\r\n            case \"isNull\":\r\n                return `${condition.parameters[0]} IS NULL`\r\n\r\n            case \"not\":\r\n                return `NOT(${this.createWhereConditionExpression(\r\n                    condition.condition,\r\n                )})`\r\n            case \"brackets\":\r\n                return `${this.createWhereConditionExpression(\r\n                    condition.condition,\r\n                    true,\r\n                )}`\r\n            case \"and\":\r\n                return \"(\" + condition.parameters.join(\" AND \") + \")\"\r\n            case \"or\":\r\n                return \"(\" + condition.parameters.join(\" OR \") + \")\"\r\n        }\r\n\r\n        throw new TypeError(\r\n            `Unsupported FindOperator ${FindOperator.constructor.name}`,\r\n        )\r\n    }\r\n\r\n    protected createCteExpression(): string {\r\n        if (!this.hasCommonTableExpressions()) {\r\n            return \"\"\r\n        }\r\n        const databaseRequireRecusiveHint =\r\n            this.connection.driver.cteCapabilities.requiresRecursiveHint\r\n\r\n        const cteStrings = this.expressionMap.commonTableExpressions.map(\r\n            (cte) => {\r\n                let cteBodyExpression = typeof cte.queryBuilder === 'string' ? cte.queryBuilder : '';\r\n                if (typeof cte.queryBuilder !== \"string\") {\r\n                    if (cte.queryBuilder.hasCommonTableExpressions()) {\r\n                        throw new TypeORMError(\r\n                            `Nested CTEs aren't supported (CTE: ${cte.alias})`,\r\n                        )\r\n                    }\r\n                    cteBodyExpression = cte.queryBuilder.getQuery()\r\n                    if (\r\n                        !this.connection.driver.cteCapabilities.writable &&\r\n                        !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\r\n                    ) {\r\n                        throw new TypeORMError(\r\n                            `Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`,\r\n                        )\r\n                    }\r\n                    this.setParameters(cte.queryBuilder.getParameters())\r\n                }\r\n                let cteHeader = this.escape(cte.alias)\r\n                if (cte.options.columnNames) {\r\n                    const escapedColumnNames = cte.options.columnNames.map(\r\n                        (column) => this.escape(column),\r\n                    )\r\n                    if (\r\n                        InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\r\n                    ) {\r\n                        if (\r\n                            cte.queryBuilder.expressionMap.selects.length &&\r\n                            cte.options.columnNames.length !==\r\n                                cte.queryBuilder.expressionMap.selects.length\r\n                        ) {\r\n                            throw new TypeORMError(\r\n                                `cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`,\r\n                            )\r\n                        }\r\n                    }\r\n                    cteHeader += `(${escapedColumnNames.join(\", \")})`\r\n                }\r\n                const recursiveClause =\r\n                    cte.options.recursive && databaseRequireRecusiveHint\r\n                        ? \"RECURSIVE\"\r\n                        : \"\"\r\n                let materializeClause = \"\"\r\n                if (\r\n                    this.connection.driver.cteCapabilities.materializedHint &&\r\n                    cte.options.materialized !== undefined\r\n                ) {\r\n                    materializeClause = cte.options.materialized\r\n                        ? \"MATERIALIZED\"\r\n                        : \"NOT MATERIALIZED\"\r\n                }\r\n\r\n                return [\r\n                    recursiveClause,\r\n                    cteHeader,\r\n                    \"AS\",\r\n                    materializeClause,\r\n                    `(${cteBodyExpression})`,\r\n                ]\r\n                    .filter(Boolean)\r\n                    .join(\" \")\r\n            },\r\n        )\r\n\r\n        return \"WITH \" + cteStrings.join(\", \") + \" \"\r\n    }\r\n\r\n    /**\r\n     * Creates \"WHERE\" condition for an in-ids condition.\r\n     */\r\n    protected getWhereInIdsCondition(\r\n        ids: any | any[],\r\n    ): ObjectLiteral | Brackets {\r\n        const metadata = this.expressionMap.mainAlias!.metadata\r\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) =>\r\n            metadata.ensureEntityIdMap(id),\r\n        )\r\n\r\n        // using in(...ids) for single primary key entities\r\n        if (!metadata.hasMultiplePrimaryKeys) {\r\n            const primaryColumn = metadata.primaryColumns[0]\r\n\r\n            // getEntityValue will try to transform `In`, it is a bug\r\n            // todo: remove this transformer check after #2390 is fixed\r\n            // This also fails for embedded & relation, so until that is fixed skip it.\r\n            if (\r\n                !primaryColumn.transformer &&\r\n                !primaryColumn.relationMetadata &&\r\n                !primaryColumn.embeddedMetadata\r\n            ) {\r\n                return {\r\n                    [primaryColumn.propertyName]: In(\r\n                        normalized.map((id) =>\r\n                            primaryColumn.getEntityValue(id, false),\r\n                        ),\r\n                    ),\r\n                }\r\n            }\r\n        }\r\n\r\n        return new Brackets((qb) => {\r\n            for (const data of normalized) {\r\n                qb.orWhere(new Brackets((qb) => qb.where(data)))\r\n            }\r\n        })\r\n    }\r\n\r\n    protected getExistsCondition(subQuery: any): [string, any[]] {\r\n        const query = subQuery\r\n            .clone()\r\n            .orderBy()\r\n            .groupBy()\r\n            .offset(undefined)\r\n            .limit(undefined)\r\n            .skip(undefined)\r\n            .take(undefined)\r\n            .select(\"1\")\r\n            .setOption(\"disable-global-order\")\r\n\r\n        return [`EXISTS (${query.getQuery()})`, query.getParameters()]\r\n    }\r\n\r\n    private findColumnsForPropertyPath(\r\n        propertyPath: string,\r\n    ): [Alias, string[], ColumnMetadata[]] {\r\n        // Make a helper to iterate the entity & relations?\r\n        // Use that to set the correct alias?  Or the other way around?\r\n\r\n        // Start with the main alias with our property paths\r\n        let alias = this.expressionMap.mainAlias\r\n        const root: string[] = []\r\n        const propertyPathParts = propertyPath.split(\".\")\r\n\r\n        while (propertyPathParts.length > 1) {\r\n            const part = propertyPathParts[0]\r\n\r\n            if (!alias?.hasMetadata) {\r\n                // If there's no metadata, we're wasting our time\r\n                // and can't actually look any of this up.\r\n                break\r\n            }\r\n\r\n            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\r\n                // If this is an embedded then we should combine the two as part of our lookup.\r\n                // Instead of just breaking, we keep going with this in case there's an embedded/relation\r\n                // inside an embedded.\r\n                propertyPathParts.unshift(\r\n                    `${propertyPathParts.shift()}.${propertyPathParts.shift()}`,\r\n                )\r\n                continue\r\n            }\r\n\r\n            if (alias.metadata.hasRelationWithPropertyPath(part)) {\r\n                // If this is a relation then we should find the aliases\r\n                // that match the relation & then continue further down\r\n                // the property path\r\n                const joinAttr = this.expressionMap.joinAttributes.find(\r\n                    (joinAttr) => joinAttr.relationPropertyPath === part,\r\n                )\r\n\r\n                if (!joinAttr?.alias) {\r\n                    const fullRelationPath =\r\n                        root.length > 0 ? `${root.join(\".\")}.${part}` : part\r\n                    throw new Error(\r\n                        `Cannot find alias for relation at ${fullRelationPath}`,\r\n                    )\r\n                }\r\n\r\n                alias = joinAttr.alias\r\n                root.push(...part.split(\".\"))\r\n                propertyPathParts.shift()\r\n                continue\r\n            }\r\n\r\n            break\r\n        }\r\n\r\n        if (!alias) {\r\n            throw new Error(`Cannot find alias for property ${propertyPath}`)\r\n        }\r\n\r\n        // Remaining parts are combined back and used to find the actual property path\r\n        const aliasPropertyPath = propertyPathParts.join(\".\")\r\n\r\n        const columns =\r\n            alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath)\r\n\r\n        if (!columns.length) {\r\n            throw new EntityPropertyNotFoundError(propertyPath, alias.metadata)\r\n        }\r\n\r\n        return [alias, root, columns]\r\n    }\r\n\r\n    /**\r\n     * Creates a property paths for a given ObjectLiteral.\r\n     */\r\n    protected createPropertyPath(\r\n        metadata: EntityMetadata,\r\n        entity: ObjectLiteral,\r\n        prefix: string = \"\",\r\n    ) {\r\n        const paths: string[] = []\r\n\r\n        for (const key of Object.keys(entity)) {\r\n            const path = prefix ? `${prefix}.${key}` : key\r\n\r\n            // There's times where we don't actually want to traverse deeper.\r\n            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\r\n            if (\r\n                entity[key] === null ||\r\n                typeof entity[key] !== \"object\" ||\r\n                InstanceChecker.isFindOperator(entity[key])\r\n            ) {\r\n                paths.push(path)\r\n                continue\r\n            }\r\n\r\n            if (metadata.hasEmbeddedWithPropertyPath(path)) {\r\n                const subPaths = this.createPropertyPath(\r\n                    metadata,\r\n                    entity[key],\r\n                    path,\r\n                )\r\n                paths.push(...subPaths)\r\n                continue\r\n            }\r\n\r\n            if (metadata.hasRelationWithPropertyPath(path)) {\r\n                const relation = metadata.findRelationWithPropertyPath(path)!\r\n\r\n                // There's also cases where we don't want to return back all of the properties.\r\n                // These handles the situation where someone passes the model & we don't need to make\r\n                // a HUGE `where` to uniquely look up the entity.\r\n\r\n                // In the case of a *-to-one, there's only ever one possible entity on the other side\r\n                // so if the join columns are all defined we can return just the relation itself\r\n                // because it will fetch only the join columns and do the lookup.\r\n                if (\r\n                    relation.relationType === \"one-to-one\" ||\r\n                    relation.relationType === \"many-to-one\"\r\n                ) {\r\n                    const joinColumns = relation.joinColumns\r\n                        .map((j) => j.referencedColumn)\r\n                        .filter((j): j is ColumnMetadata => !!j)\r\n\r\n                    const hasAllJoinColumns =\r\n                        joinColumns.length > 0 &&\r\n                        joinColumns.every((column) =>\r\n                            column.getEntityValue(entity[key], false),\r\n                        )\r\n\r\n                    if (hasAllJoinColumns) {\r\n                        paths.push(path)\r\n                        continue\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    relation.relationType === \"one-to-many\" ||\r\n                    relation.relationType === \"many-to-many\"\r\n                ) {\r\n                    throw new Error(\r\n                        `Cannot query across ${relation.relationType} for property ${path}`,\r\n                    )\r\n                }\r\n\r\n                // For any other case, if the `entity[key]` contains all of the primary keys we can do a\r\n                // lookup via these.  We don't need to look up via any other values 'cause these are\r\n                // the unique primary keys.\r\n                // This handles the situation where someone passes the model & we don't need to make\r\n                // a HUGE where.\r\n                const primaryColumns =\r\n                    relation.inverseEntityMetadata.primaryColumns\r\n                const hasAllPrimaryKeys =\r\n                    primaryColumns.length > 0 &&\r\n                    primaryColumns.every((column) =>\r\n                        column.getEntityValue(entity[key], false),\r\n                    )\r\n\r\n                if (hasAllPrimaryKeys) {\r\n                    const subPaths = primaryColumns.map(\r\n                        (column) => `${path}.${column.propertyPath}`,\r\n                    )\r\n                    paths.push(...subPaths)\r\n                    continue\r\n                }\r\n\r\n                // If nothing else, just return every property that's being passed to us.\r\n                const subPaths = this.createPropertyPath(\r\n                    relation.inverseEntityMetadata,\r\n                    entity[key],\r\n                ).map((p) => `${path}.${p}`)\r\n                paths.push(...subPaths)\r\n                continue\r\n            }\r\n\r\n            paths.push(path)\r\n        }\r\n\r\n        return paths\r\n    }\r\n\r\n    protected *getPredicates(where: ObjectLiteral) {\r\n        if (this.expressionMap.mainAlias!.hasMetadata) {\r\n            const propertyPaths = this.createPropertyPath(\r\n                this.expressionMap.mainAlias!.metadata,\r\n                where,\r\n            )\r\n\r\n            for (const propertyPath of propertyPaths) {\r\n                const [alias, aliasPropertyPath, columns] =\r\n                    this.findColumnsForPropertyPath(propertyPath)\r\n\r\n                for (const column of columns) {\r\n                    let containedWhere = where\r\n\r\n                    for (const part of aliasPropertyPath) {\r\n                        if (!containedWhere || !(part in containedWhere)) {\r\n                            containedWhere = {}\r\n                            break\r\n                        }\r\n\r\n                        containedWhere = containedWhere[part]\r\n                    }\r\n\r\n                    // Use the correct alias & the property path from the column\r\n                    const aliasPath = this.expressionMap\r\n                        .aliasNamePrefixingEnabled\r\n                        ? `${alias.name}.${column.propertyPath}`\r\n                        : column.propertyPath\r\n\r\n                    const parameterValue = column.getEntityValue(\r\n                        containedWhere,\r\n                        true,\r\n                    )\r\n\r\n                    yield [aliasPath, parameterValue]\r\n                }\r\n            }\r\n        } else {\r\n            for (const key of Object.keys(where)) {\r\n                const parameterValue = where[key]\r\n                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled\r\n                    ? `${this.alias}.${key}`\r\n                    : key\r\n\r\n                yield [aliasPath, parameterValue]\r\n            }\r\n        }\r\n    }\r\n\r\n    protected getWherePredicateCondition(\r\n        aliasPath: string,\r\n        parameterValue: any,\r\n    ): WhereClauseCondition {\r\n        if (InstanceChecker.isFindOperator(parameterValue)) {\r\n            let parameters: any[] = []\r\n            if (parameterValue.useParameter) {\r\n                if (parameterValue.objectLiteralParameters) {\r\n                    this.setParameters(parameterValue.objectLiteralParameters)\r\n                } else if (parameterValue.multipleParameters) {\r\n                    for (const v of parameterValue.value) {\r\n                        parameters.push(this.createParameter(v))\r\n                    }\r\n                } else {\r\n                    parameters.push(this.createParameter(parameterValue.value))\r\n                }\r\n            }\r\n\r\n            if (parameterValue.type === \"raw\") {\r\n                if (parameterValue.getSql) {\r\n                    return parameterValue.getSql(aliasPath)\r\n                } else {\r\n                    return {\r\n                        operator: \"equal\",\r\n                        parameters: [aliasPath, parameterValue.value],\r\n                    }\r\n                }\r\n            } else if (parameterValue.type === \"not\") {\r\n                if (parameterValue.child) {\r\n                    return {\r\n                        operator: parameterValue.type,\r\n                        condition: this.getWherePredicateCondition(\r\n                            aliasPath,\r\n                            parameterValue.child,\r\n                        ),\r\n                    }\r\n                } else {\r\n                    return {\r\n                        operator: \"notEqual\",\r\n                        parameters: [aliasPath, ...parameters],\r\n                    }\r\n                }\r\n            } else if (parameterValue.type === \"and\") {\r\n                const values: FindOperator<any>[] = parameterValue.value\r\n\r\n                return {\r\n                    operator: parameterValue.type,\r\n                    parameters: values.map((operator) =>\r\n                        this.createWhereConditionExpression(\r\n                            this.getWherePredicateCondition(\r\n                                aliasPath,\r\n                                operator,\r\n                            ),\r\n                        ),\r\n                    ),\r\n                }\r\n            } else if (parameterValue.type === \"or\") {\r\n                const values: FindOperator<any>[] = parameterValue.value\r\n\r\n                return {\r\n                    operator: parameterValue.type,\r\n                    parameters: values.map((operator) =>\r\n                        this.createWhereConditionExpression(\r\n                            this.getWherePredicateCondition(\r\n                                aliasPath,\r\n                                operator,\r\n                            ),\r\n                        ),\r\n                    ),\r\n                }\r\n            } else {\r\n                return {\r\n                    operator: parameterValue.type,\r\n                    parameters: [aliasPath, ...parameters],\r\n                }\r\n            }\r\n            // } else if (parameterValue === null) {\r\n            //     return {\r\n            //         operator: \"isNull\",\r\n            //         parameters: [\r\n            //             aliasPath,\r\n            //         ]\r\n            //     };\r\n        } else {\r\n            return {\r\n                operator: \"equal\",\r\n                parameters: [aliasPath, this.createParameter(parameterValue)],\r\n            }\r\n        }\r\n    }\r\n\r\n    protected getWhereCondition(\r\n        where:\r\n            | string\r\n            | ((qb: this) => string)\r\n            | Brackets\r\n            | NotBrackets\r\n            | ObjectLiteral\r\n            | ObjectLiteral[],\r\n    ): WhereClauseCondition {\r\n        if (typeof where === \"string\") {\r\n            return where\r\n        }\r\n\r\n        if (InstanceChecker.isBrackets(where)) {\r\n            const whereQueryBuilder = this.createQueryBuilder()\r\n\r\n            whereQueryBuilder.parentQueryBuilder = this\r\n\r\n            whereQueryBuilder.expressionMap.mainAlias =\r\n                this.expressionMap.mainAlias\r\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled =\r\n                this.expressionMap.aliasNamePrefixingEnabled\r\n            whereQueryBuilder.expressionMap.parameters =\r\n                this.expressionMap.parameters\r\n            whereQueryBuilder.expressionMap.nativeParameters =\r\n                this.expressionMap.nativeParameters\r\n\r\n            whereQueryBuilder.expressionMap.wheres = []\r\n\r\n            where.whereFactory(whereQueryBuilder as any)\r\n\r\n            return {\r\n                operator: InstanceChecker.isNotBrackets(where)\r\n                    ? \"not\"\r\n                    : \"brackets\",\r\n                condition: whereQueryBuilder.expressionMap.wheres,\r\n            }\r\n        }\r\n\r\n        if (typeof where === \"function\") {\r\n            return where(this)\r\n        }\r\n\r\n        const wheres: ObjectLiteral[] = Array.isArray(where) ? where : [where]\r\n        const clauses: WhereClause[] = []\r\n\r\n        for (const where of wheres) {\r\n            const conditions: WhereClauseCondition = []\r\n\r\n            // Filter the conditions and set up the parameter values\r\n            for (const [aliasPath, parameterValue] of this.getPredicates(\r\n                where,\r\n            )) {\r\n                conditions.push({\r\n                    type: \"and\",\r\n                    condition: this.getWherePredicateCondition(\r\n                        aliasPath,\r\n                        parameterValue,\r\n                    ),\r\n                })\r\n            }\r\n\r\n            clauses.push({ type: \"or\", condition: conditions })\r\n        }\r\n\r\n        if (clauses.length === 1) {\r\n            return clauses[0].condition\r\n        }\r\n\r\n        return clauses\r\n    }\r\n\r\n    /**\r\n     * Creates a query builder used to execute sql queries inside this query builder.\r\n     */\r\n    protected obtainQueryRunner() {\r\n        return this.queryRunner || this.connection.createQueryRunner()\r\n    }\r\n\r\n    protected hasCommonTableExpressions(): boolean {\r\n        return this.expressionMap.commonTableExpressions.length > 0\r\n    }\r\n}\r\n"],"sourceRoot":".."}