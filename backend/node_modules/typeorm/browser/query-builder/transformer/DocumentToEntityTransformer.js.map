{"version":3,"sources":["../browser/src/query-builder/transformer/DocumentToEntityTransformer.ts"],"names":[],"mappings":"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","file":"DocumentToEntityTransformer.js","sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { EmbeddedMetadata } from \"../../metadata/EmbeddedMetadata\"\r\n\r\n/**\r\n * Transforms raw document into entity object.\r\n * Entity is constructed based on its entity metadata.\r\n */\r\nexport class DocumentToEntityTransformer {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        // private selectionMap: AliasMap,\r\n        // private joinMappings: JoinMapping[],\r\n        // private relationCountMetas: RelationCountAttribute[],\r\n        private enableRelationIdValues: boolean = false,\r\n    ) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    transformAll(documents: ObjectLiteral[], metadata: EntityMetadata) {\r\n        return documents.map((document) => this.transform(document, metadata))\r\n    }\r\n\r\n    transform(document: any, metadata: EntityMetadata) {\r\n        const entity: any = metadata.create(undefined, {\r\n            fromDeserializer: true,\r\n        })\r\n        let hasData = false\r\n\r\n        // handle _id property the special way\r\n        if (metadata.objectIdColumn) {\r\n            // todo: we can't use driver in this class\r\n            // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?\r\n            // entity[metadata.ObjectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.ObjectIdColumn.name\"], metadata.ObjectIdColumn);\r\n            const { databaseNameWithoutPrefixes, propertyName } =\r\n                metadata.objectIdColumn\r\n\r\n            const documentIdWithoutPrefixes =\r\n                document[databaseNameWithoutPrefixes]\r\n            const documentIdWithPropertyName = document[propertyName]\r\n\r\n            if (documentIdWithoutPrefixes) {\r\n                entity[propertyName] = documentIdWithoutPrefixes\r\n                hasData = true\r\n            } else if (documentIdWithPropertyName) {\r\n                entity[propertyName] = documentIdWithPropertyName\r\n                hasData = true\r\n            }\r\n        }\r\n\r\n        // add special columns that contains relation ids\r\n        if (this.enableRelationIdValues) {\r\n            metadata.columns\r\n                .filter((column) => !!column.relationMetadata)\r\n                .forEach((column) => {\r\n                    const valueInObject =\r\n                        document[column.databaseNameWithoutPrefixes]\r\n                    if (\r\n                        valueInObject !== undefined &&\r\n                        valueInObject !== null &&\r\n                        column.propertyName\r\n                    ) {\r\n                        // todo: we can't use driver in this class\r\n                        // const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n                        entity[column.propertyName] = valueInObject\r\n                        hasData = true\r\n                    }\r\n                })\r\n        }\r\n\r\n        /*this.joinMappings\r\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)\r\n            .map(joinMapping => {\r\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);\r\n                const isResultArray = joinMapping.isMany;\r\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\r\n\r\n                if (result && (!isResultArray || result.length > 0)) {\r\n                    entity[joinMapping.propertyName] = result;\r\n                    hasData = true;\r\n                }\r\n            });*/\r\n\r\n        // get value from columns selections and put them into object\r\n        metadata.ownColumns.forEach((column) => {\r\n            const valueInObject = document[column.databaseNameWithoutPrefixes]\r\n            if (\r\n                valueInObject !== undefined &&\r\n                column.propertyName &&\r\n                !column.isVirtual\r\n            ) {\r\n                // const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n\r\n                entity[column.propertyName] = valueInObject\r\n                hasData = true\r\n            }\r\n        })\r\n\r\n        const addEmbeddedValuesRecursively = (\r\n            entity: any,\r\n            document: any,\r\n            embeddeds: EmbeddedMetadata[],\r\n        ) => {\r\n            embeddeds.forEach((embedded) => {\r\n                if (!document[embedded.prefix]) return\r\n\r\n                if (embedded.isArray) {\r\n                    entity[embedded.propertyName] = (\r\n                        document[embedded.prefix] as any[]\r\n                    ).map((subValue: any, index: number) => {\r\n                        const newItem = embedded.create({\r\n                            fromDeserializer: true,\r\n                        })\r\n                        embedded.columns.forEach((column) => {\r\n                            newItem[column.propertyName] =\r\n                                subValue[column.databaseNameWithoutPrefixes]\r\n                        })\r\n                        addEmbeddedValuesRecursively(\r\n                            newItem,\r\n                            document[embedded.prefix][index],\r\n                            embedded.embeddeds,\r\n                        )\r\n                        return newItem\r\n                    })\r\n                } else {\r\n                    if (\r\n                        embedded.embeddeds.length &&\r\n                        !entity[embedded.propertyName]\r\n                    )\r\n                        entity[embedded.propertyName] = embedded.create({\r\n                            fromDeserializer: true,\r\n                        })\r\n\r\n                    embedded.columns.forEach((column) => {\r\n                        const value =\r\n                            document[embedded.prefix][\r\n                                column.databaseNameWithoutPrefixes\r\n                            ]\r\n                        if (value === undefined) return\r\n\r\n                        if (!entity[embedded.propertyName])\r\n                            entity[embedded.propertyName] = embedded.create({\r\n                                fromDeserializer: true,\r\n                            })\r\n\r\n                        entity[embedded.propertyName][column.propertyName] =\r\n                            value\r\n                    })\r\n\r\n                    addEmbeddedValuesRecursively(\r\n                        entity[embedded.propertyName],\r\n                        document[embedded.prefix],\r\n                        embedded.embeddeds,\r\n                    )\r\n                }\r\n            })\r\n        }\r\n\r\n        addEmbeddedValuesRecursively(entity, document, metadata.embeddeds)\r\n\r\n        // if relation is loaded then go into it recursively and transform its values too\r\n        /*metadata.relations.forEach(relation => {\r\n            const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);\r\n            if (relationAlias) {\r\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\r\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);\r\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\r\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\r\n\r\n                if (result) {\r\n                    let propertyName = relation.propertyName;\r\n                    if (joinMapping) {\r\n                        propertyName = joinMapping.propertyName;\r\n                    }\r\n\r\n                    if (relation.isLazy) {\r\n                        entity[\"__\" + propertyName + \"__\"] = result;\r\n                    } else {\r\n                        entity[propertyName] = result;\r\n                    }\r\n\r\n                    if (!isResultArray || result.length > 0)\r\n                        hasData = true;\r\n                }\r\n            }\r\n\r\n            // if relation has id field then relation id/ids to that field.\r\n            if (relation.isManyToMany) {\r\n                if (relationAlias) {\r\n                    const ids: any[] = [];\r\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\r\n\r\n                    if (relation.idField || joinMapping) {\r\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\r\n                        const junctionMetadata = relation.junctionEntityMetadata;\r\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;\r\n\r\n                        rawSqlResults.forEach(results => {\r\n                            if (relationAlias) {\r\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\r\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\r\n                                if (value !== undefined && value !== null)\r\n                                    ids.push(value);\r\n                            }\r\n                        });\r\n\r\n                        if (ids && ids.length)\r\n                            entity[propertyName] = ids;\r\n                    }\r\n                }\r\n            } else if (relation.idField) {\r\n                const relationName = relation.name;\r\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\r\n            }\r\n\r\n            // if relation counter\r\n            this.relationCountMetas.forEach(joinMeta => {\r\n                if (joinMeta.alias === relationAlias) {\r\n                    // console.log(\"relation count was found for relation: \", relation);\r\n                    // joinMeta.entity = entity;\r\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\r\n                    // console.log(joinMeta);\r\n                    // console.log(\"---------------------\");\r\n                }\r\n            });\r\n        });*/\r\n\r\n        return hasData ? entity : null\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}