{"version":3,"sources":["../browser/src/query-builder/relation-count/RelationCountLoader.ts"],"names":[],"mappings":"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","file":"RelationCountLoader.js","sourcesContent":["import { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\r\nimport { DataSource } from \"../../data-source/DataSource\"\r\nimport { RelationCountAttribute } from \"./RelationCountAttribute\"\r\nimport { RelationCountLoadResult } from \"./RelationCountLoadResult\"\r\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\r\n\r\nexport class RelationCountLoader {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        protected connection: DataSource,\r\n        protected queryRunner: QueryRunner | undefined,\r\n        protected relationCountAttributes: RelationCountAttribute[],\r\n    ) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\r\n        const onlyUnique = (value: any, index: number, self: any) => {\r\n            return self.indexOf(value) === index\r\n        }\r\n\r\n        const promises = this.relationCountAttributes.map(\r\n            async (relationCountAttr) => {\r\n                if (relationCountAttr.relation.isOneToMany) {\r\n                    // example: Post and Category\r\n                    // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\r\n                    // we expect it to load array of post ids\r\n\r\n                    // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\r\n                    const relation = relationCountAttr.relation // \"category.posts\"\r\n                    const inverseRelation = relation.inverseRelation! // \"post.category\"\r\n                    const referenceColumnName =\r\n                        inverseRelation.joinColumns[0].referencedColumn!\r\n                            .propertyName // post id\r\n                    const inverseSideTable =\r\n                        relation.inverseEntityMetadata.target // Post\r\n                    const inverseSideTableName =\r\n                        relation.inverseEntityMetadata.tableName // post\r\n                    const inverseSideTableAlias =\r\n                        relationCountAttr.alias || inverseSideTableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\r\n                    const inverseSidePropertyName = inverseRelation.propertyName // \"category\" from \"post.category\"\r\n\r\n                    let referenceColumnValues = rawEntities\r\n                        .map(\r\n                            (rawEntity) =>\r\n                                rawEntity[\r\n                                    relationCountAttr.parentAlias +\r\n                                        \"_\" +\r\n                                        referenceColumnName\r\n                                ],\r\n                        )\r\n                        .filter((value) => !!value)\r\n                    referenceColumnValues =\r\n                        referenceColumnValues.filter(onlyUnique)\r\n\r\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\r\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\r\n                    if (referenceColumnValues.length === 0)\r\n                        return {\r\n                            relationCountAttribute: relationCountAttr,\r\n                            results: [],\r\n                        }\r\n\r\n                    // generate query:\r\n                    // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\r\n                    const qb = this.connection.createQueryBuilder(\r\n                        this.queryRunner,\r\n                    )\r\n                    qb.select(\r\n                        inverseSideTableAlias + \".\" + inverseSidePropertyName,\r\n                        \"parentId\",\r\n                    )\r\n                        .addSelect(\"COUNT(*)\", \"cnt\")\r\n                        .from(inverseSideTable, inverseSideTableAlias)\r\n                        .where(\r\n                            inverseSideTableAlias +\r\n                                \".\" +\r\n                                inverseSidePropertyName +\r\n                                \" IN (:...ids)\",\r\n                        )\r\n                        .addGroupBy(\r\n                            inverseSideTableAlias +\r\n                                \".\" +\r\n                                inverseSidePropertyName,\r\n                        )\r\n                        .setParameter(\"ids\", referenceColumnValues)\r\n\r\n                    // apply condition (custom query builder factory)\r\n                    if (relationCountAttr.queryBuilderFactory)\r\n                        relationCountAttr.queryBuilderFactory(qb)\r\n\r\n                    return {\r\n                        relationCountAttribute: relationCountAttr,\r\n                        results: await qb.getRawMany(),\r\n                    }\r\n                } else {\r\n                    // example: Post and Category\r\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\r\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\r\n                    // we expect it to load array of post ids\r\n\r\n                    let joinTableColumnName: string\r\n                    let inverseJoinColumnName: string\r\n                    let firstJunctionColumn: ColumnMetadata\r\n                    let secondJunctionColumn: ColumnMetadata\r\n\r\n                    if (relationCountAttr.relation.isOwning) {\r\n                        // todo fix joinColumns[0] and inverseJoinColumns[0].\r\n                        joinTableColumnName =\r\n                            relationCountAttr.relation.joinColumns[0]\r\n                                .referencedColumn!.databaseName\r\n                        inverseJoinColumnName =\r\n                            relationCountAttr.relation.inverseJoinColumns[0]\r\n                                .referencedColumn!.databaseName\r\n                        firstJunctionColumn =\r\n                            relationCountAttr.relation.junctionEntityMetadata!\r\n                                .columns[0]\r\n                        secondJunctionColumn =\r\n                            relationCountAttr.relation.junctionEntityMetadata!\r\n                                .columns[1]\r\n                    } else {\r\n                        joinTableColumnName =\r\n                            relationCountAttr.relation.inverseRelation!\r\n                                .inverseJoinColumns[0].referencedColumn!\r\n                                .databaseName\r\n                        inverseJoinColumnName =\r\n                            relationCountAttr.relation.inverseRelation!\r\n                                .joinColumns[0].referencedColumn!.databaseName\r\n                        firstJunctionColumn =\r\n                            relationCountAttr.relation.junctionEntityMetadata!\r\n                                .columns[1]\r\n                        secondJunctionColumn =\r\n                            relationCountAttr.relation.junctionEntityMetadata!\r\n                                .columns[0]\r\n                    }\r\n\r\n                    let referenceColumnValues = rawEntities\r\n                        .map(\r\n                            (rawEntity) =>\r\n                                rawEntity[\r\n                                    relationCountAttr.parentAlias +\r\n                                        \"_\" +\r\n                                        joinTableColumnName\r\n                                ],\r\n                        )\r\n                        .filter((value) => !!value)\r\n                    referenceColumnValues =\r\n                        referenceColumnValues.filter(onlyUnique)\r\n\r\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\r\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\r\n                    if (referenceColumnValues.length === 0)\r\n                        return {\r\n                            relationCountAttribute: relationCountAttr,\r\n                            results: [],\r\n                        }\r\n\r\n                    const junctionAlias = relationCountAttr.junctionAlias\r\n                    const inverseSideTableName =\r\n                        relationCountAttr.joinInverseSideMetadata.tableName\r\n                    const inverseSideTableAlias =\r\n                        relationCountAttr.alias || inverseSideTableName\r\n                    const junctionTableName =\r\n                        relationCountAttr.relation.junctionEntityMetadata!\r\n                            .tableName\r\n\r\n                    const condition =\r\n                        junctionAlias +\r\n                        \".\" +\r\n                        firstJunctionColumn.propertyName +\r\n                        \" IN (\" +\r\n                        referenceColumnValues.map((vals) =>\r\n                            isNaN(vals) ? \"'\" + vals + \"'\" : vals,\r\n                        ) +\r\n                        \")\" +\r\n                        \" AND \" +\r\n                        junctionAlias +\r\n                        \".\" +\r\n                        secondJunctionColumn.propertyName +\r\n                        \" = \" +\r\n                        inverseSideTableAlias +\r\n                        \".\" +\r\n                        inverseJoinColumnName\r\n\r\n                    const qb = this.connection.createQueryBuilder(\r\n                        this.queryRunner,\r\n                    )\r\n                    qb.select(\r\n                        junctionAlias + \".\" + firstJunctionColumn.propertyName,\r\n                        \"parentId\",\r\n                    )\r\n                        .addSelect(\r\n                            \"COUNT(\" +\r\n                                qb.escape(inverseSideTableAlias) +\r\n                                \".\" +\r\n                                qb.escape(inverseJoinColumnName) +\r\n                                \")\",\r\n                            \"cnt\",\r\n                        )\r\n                        .from(inverseSideTableName, inverseSideTableAlias)\r\n                        .innerJoin(junctionTableName, junctionAlias, condition)\r\n                        .addGroupBy(\r\n                            junctionAlias +\r\n                                \".\" +\r\n                                firstJunctionColumn.propertyName,\r\n                        )\r\n\r\n                    // apply condition (custom query builder factory)\r\n                    if (relationCountAttr.queryBuilderFactory)\r\n                        relationCountAttr.queryBuilderFactory(qb)\r\n\r\n                    return {\r\n                        relationCountAttribute: relationCountAttr,\r\n                        results: await qb.getRawMany(),\r\n                    }\r\n                }\r\n            },\r\n        )\r\n\r\n        return Promise.all(promises)\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}