{"version":3,"sources":["../browser/src/metadata/EntityMetadata.ts"],"names":[],"mappings":"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","file":"EntityMetadata.js","sourcesContent":["import { QueryRunner, SelectQueryBuilder } from \"..\"\r\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { DataSource } from \"../data-source/DataSource\"\r\nimport { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\"\r\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\r\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\r\nimport { TreeMetadataArgs } from \"../metadata-args/TreeMetadataArgs\"\r\nimport { OrmUtils } from \"../util/OrmUtils\"\r\nimport { CheckMetadata } from \"./CheckMetadata\"\r\nimport { ColumnMetadata } from \"./ColumnMetadata\"\r\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\r\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\r\nimport { ExclusionMetadata } from \"./ExclusionMetadata\"\r\nimport { ForeignKeyMetadata } from \"./ForeignKeyMetadata\"\r\nimport { IndexMetadata } from \"./IndexMetadata\"\r\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\r\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\r\nimport { RelationMetadata } from \"./RelationMetadata\"\r\nimport { TableType } from \"./types/TableTypes\"\r\nimport { TreeType } from \"./types/TreeTypes\"\r\nimport { UniqueMetadata } from \"./UniqueMetadata\"\r\nimport { ClosureTreeOptions } from \"./types/ClosureTreeOptions\"\r\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\nimport { shorten } from \"../util/StringUtils\"\r\n\r\n/**\r\n * Contains all entity metadata.\r\n */\r\nexport class EntityMetadata {\r\n    readonly \"@instanceof\" = Symbol.for(\"EntityMetadata\")\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Connection where this entity metadata is created.\r\n     */\r\n    connection: DataSource\r\n\r\n    /**\r\n     * Metadata arguments used to build this entity metadata.\r\n     */\r\n    tableMetadataArgs: TableMetadataArgs\r\n\r\n    /**\r\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\r\n     */\r\n    closureJunctionTable: EntityMetadata\r\n\r\n    /**\r\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\r\n     */\r\n    parentClosureEntityMetadata: EntityMetadata\r\n\r\n    /**\r\n     * Parent's entity metadata. Used in inheritance patterns.\r\n     */\r\n    parentEntityMetadata: EntityMetadata\r\n\r\n    /**\r\n     * Children entity metadatas. Used in inheritance patterns.\r\n     */\r\n    childEntityMetadatas: EntityMetadata[] = []\r\n\r\n    /**\r\n     * All \"inheritance tree\" from a target entity.\r\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\r\n     * It also contains child entities for single table inheritance.\r\n     */\r\n    inheritanceTree: Function[] = []\r\n\r\n    /**\r\n     * Table type. Tables can be closure, junction, etc.\r\n     */\r\n    tableType: TableType = \"regular\"\r\n\r\n    /**\r\n     * Target class to which this entity metadata is bind.\r\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\r\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\r\n     */\r\n    target: Function | string\r\n\r\n    /**\r\n     * Gets the name of the target.\r\n     */\r\n    targetName: string\r\n\r\n    /**\r\n     * Entity's name.\r\n     * Equal to entity target class's name if target is set to table.\r\n     * If target class is not then then it equals to table name.\r\n     */\r\n    name: string\r\n\r\n    /**\r\n     * View's expression.\r\n     * Used in views\r\n     */\r\n    expression?: string | ((connection: DataSource) => SelectQueryBuilder<any>)\r\n\r\n    /**\r\n     * View's dependencies.\r\n     * Used in views\r\n     */\r\n    dependsOn?: Set<Function | string>\r\n\r\n    /**\r\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\r\n     */\r\n    withoutRowid?: boolean = false\r\n\r\n    /**\r\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\r\n     * If user haven't specified a table name this property will be undefined.\r\n     */\r\n    givenTableName?: string\r\n\r\n    /**\r\n     * Entity table name in the database.\r\n     * This is final table name of the entity.\r\n     * This name already passed naming strategy, and generated based on\r\n     * multiple criteria, including user table name and global table prefix.\r\n     */\r\n    tableName: string\r\n\r\n    /**\r\n     * Entity table path. Contains database name, schema name and table name.\r\n     * E.g. myDB.mySchema.myTable\r\n     */\r\n    tablePath: string\r\n\r\n    /**\r\n     * Gets the table name without global table prefix.\r\n     * When querying table you need a table name with prefix, but in some scenarios,\r\n     * for example when you want to name a junction table that contains names of two other tables,\r\n     * you may want a table name without prefix.\r\n     */\r\n    tableNameWithoutPrefix: string\r\n\r\n    /**\r\n     * Indicates if schema will be synchronized for this entity or not.\r\n     */\r\n    synchronize: boolean = true\r\n\r\n    /**\r\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\r\n     */\r\n    engine?: string\r\n\r\n    /**\r\n     * Database name.\r\n     */\r\n    database?: string\r\n\r\n    /**\r\n     * Schema name. Used in Postgres and Sql Server.\r\n     */\r\n    schema?: string\r\n\r\n    /**\r\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\r\n     */\r\n    orderBy?: OrderByCondition\r\n\r\n    /**\r\n     * If this entity metadata's table using one of the inheritance patterns,\r\n     * then this will contain what pattern it uses.\r\n     */\r\n    inheritancePattern?: \"STI\" /*|\"CTI\"*/\r\n\r\n    /**\r\n     * Checks if there any non-nullable column exist in this entity.\r\n     */\r\n    hasNonNullableRelations: boolean = false\r\n\r\n    /**\r\n     * Indicates if this entity metadata of a junction table, or not.\r\n     * Junction table is a table created by many-to-many relationship.\r\n     *\r\n     * Its also possible to understand if entity is junction via tableType.\r\n     */\r\n    isJunction: boolean = false\r\n\r\n    /**\r\n     * Indicates if the entity should be instantiated using the constructor\r\n     * or via allocating a new object via `Object.create()`.\r\n     */\r\n    isAlwaysUsingConstructor: boolean = true\r\n\r\n    /**\r\n     * Indicates if this entity is a tree, what type of tree it is.\r\n     */\r\n    treeType?: TreeType\r\n\r\n    /**\r\n     * Indicates if this entity is a tree, what options of tree it has.\r\n     */\r\n    treeOptions?: ClosureTreeOptions\r\n\r\n    /**\r\n     * Checks if this table is a junction table of the closure table.\r\n     * This type is for tables that contain junction metadata of the closure tables.\r\n     */\r\n    isClosureJunction: boolean = false\r\n\r\n    /**\r\n     * Checks if entity's table has multiple primary columns.\r\n     */\r\n    hasMultiplePrimaryKeys: boolean = false\r\n\r\n    /**\r\n     * Indicates if this entity metadata has uuid generated columns.\r\n     */\r\n    hasUUIDGeneratedColumns: boolean = false\r\n\r\n    /**\r\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\r\n     * Used to store a value in a discriminator column.\r\n     */\r\n    discriminatorValue?: string\r\n\r\n    /**\r\n     * Entity's column metadatas defined by user.\r\n     */\r\n    ownColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\r\n     */\r\n    columns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * Ancestor columns used only in closure junction tables.\r\n     */\r\n    ancestorColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * Descendant columns used only in closure junction tables.\r\n     */\r\n    descendantColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * All columns except for virtual columns.\r\n     */\r\n    nonVirtualColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * In the case if this entity metadata is junction table's entity metadata,\r\n     * this will contain all referenced columns of owner entity.\r\n     */\r\n    ownerColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * In the case if this entity metadata is junction table's entity metadata,\r\n     * this will contain all referenced columns of inverse entity.\r\n     */\r\n    inverseColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * Gets the column with generated flag.\r\n     */\r\n    generatedColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * Gets the object id column used with mongodb database.\r\n     */\r\n    objectIdColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Gets entity column which contains a create date value.\r\n     */\r\n    createDateColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Gets entity column which contains an update date value.\r\n     */\r\n    updateDateColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Gets entity column which contains a delete date value.\r\n     */\r\n    deleteDateColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Gets entity column which contains an entity version.\r\n     */\r\n    versionColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\r\n     */\r\n    discriminatorColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Special column that stores tree level in tree entities.\r\n     */\r\n    treeLevelColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Nested set's left value column.\r\n     * Used only in tree entities with nested set pattern applied.\r\n     */\r\n    nestedSetLeftColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Nested set's right value column.\r\n     * Used only in tree entities with nested set pattern applied.\r\n     */\r\n    nestedSetRightColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Materialized path column.\r\n     * Used only in tree entities with materialized path pattern applied.\r\n     */\r\n    materializedPathColumn?: ColumnMetadata\r\n\r\n    /**\r\n     * Gets the primary columns.\r\n     */\r\n    primaryColumns: ColumnMetadata[] = []\r\n\r\n    /**\r\n     * Entity's relation metadatas.\r\n     */\r\n    ownRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\r\n     */\r\n    relations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * List of eager relations this metadata has.\r\n     */\r\n    eagerRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * List of eager relations this metadata has.\r\n     */\r\n    lazyRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only one-to-one relations of the entity.\r\n     */\r\n    oneToOneRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only owner one-to-one relations of the entity.\r\n     */\r\n    ownerOneToOneRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only one-to-many relations of the entity.\r\n     */\r\n    oneToManyRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only many-to-one relations of the entity.\r\n     */\r\n    manyToOneRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only many-to-many relations of the entity.\r\n     */\r\n    manyToManyRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only owner many-to-many relations of the entity.\r\n     */\r\n    ownerManyToManyRelations: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Gets only owner one-to-one and many-to-one relations.\r\n     */\r\n    relationsWithJoinColumns: RelationMetadata[] = []\r\n\r\n    /**\r\n     * Tree parent relation. Used only in tree-tables.\r\n     */\r\n    treeParentRelation?: RelationMetadata\r\n\r\n    /**\r\n     * Tree children relation. Used only in tree-tables.\r\n     */\r\n    treeChildrenRelation?: RelationMetadata\r\n\r\n    /**\r\n     * Entity's relation id metadatas.\r\n     */\r\n    relationIds: RelationIdMetadata[] = []\r\n\r\n    /**\r\n     * Entity's relation id metadatas.\r\n     */\r\n    relationCounts: RelationCountMetadata[] = []\r\n\r\n    /**\r\n     * Entity's foreign key metadatas.\r\n     */\r\n    foreignKeys: ForeignKeyMetadata[] = []\r\n\r\n    /**\r\n     * Entity's embedded metadatas.\r\n     */\r\n    embeddeds: EmbeddedMetadata[] = []\r\n\r\n    /**\r\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\r\n     */\r\n    allEmbeddeds: EmbeddedMetadata[] = []\r\n\r\n    /**\r\n     * Entity's own indices.\r\n     */\r\n    ownIndices: IndexMetadata[] = []\r\n\r\n    /**\r\n     * Entity's index metadatas.\r\n     */\r\n    indices: IndexMetadata[] = []\r\n\r\n    /**\r\n     * Entity's unique metadatas.\r\n     */\r\n    uniques: UniqueMetadata[] = []\r\n\r\n    /**\r\n     * Entity's own uniques.\r\n     */\r\n    ownUniques: UniqueMetadata[] = []\r\n\r\n    /**\r\n     * Entity's check metadatas.\r\n     */\r\n    checks: CheckMetadata[] = []\r\n\r\n    /**\r\n     * Entity's exclusion metadatas.\r\n     */\r\n    exclusions: ExclusionMetadata[] = []\r\n\r\n    /**\r\n     * Entity's own listener metadatas.\r\n     */\r\n    ownListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Entity listener metadatas.\r\n     */\r\n    listeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER LOAD\" type.\r\n     */\r\n    afterLoadListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"BEFORE INSERT\" type.\r\n     */\r\n    beforeInsertListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER INSERT\" type.\r\n     */\r\n    afterInsertListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"BEFORE UPDATE\" type.\r\n     */\r\n    beforeUpdateListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER UPDATE\" type.\r\n     */\r\n    afterUpdateListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"BEFORE REMOVE\" type.\r\n     */\r\n    beforeRemoveListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\r\n     */\r\n    beforeSoftRemoveListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"BEFORE RECOVER\" type.\r\n     */\r\n    beforeRecoverListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER REMOVE\" type.\r\n     */\r\n    afterRemoveListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\r\n     */\r\n    afterSoftRemoveListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER RECOVER\" type.\r\n     */\r\n    afterRecoverListeners: EntityListenerMetadata[] = []\r\n\r\n    /**\r\n     * Map of columns and relations of the entity.\r\n     *\r\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\r\n     * This method will create following object:\r\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\r\n     */\r\n    propertiesMap: ObjectLiteral\r\n\r\n    /**\r\n     * Table comment. Not supported by all database types.\r\n     */\r\n    comment?: string\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(options: {\r\n        connection: DataSource\r\n        inheritanceTree?: Function[]\r\n        inheritancePattern?: \"STI\" /*|\"CTI\"*/\r\n        tableTree?: TreeMetadataArgs\r\n        parentClosureEntityMetadata?: EntityMetadata\r\n        args: TableMetadataArgs\r\n    }) {\r\n        this.connection = options.connection\r\n        this.inheritanceTree = options.inheritanceTree || []\r\n        this.inheritancePattern = options.inheritancePattern\r\n        this.treeType = options.tableTree ? options.tableTree.type : undefined\r\n        this.treeOptions = options.tableTree\r\n            ? options.tableTree.options\r\n            : undefined\r\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!\r\n        this.tableMetadataArgs = options.args\r\n        this.target = this.tableMetadataArgs.target\r\n        this.tableType = this.tableMetadataArgs.type\r\n        this.expression = this.tableMetadataArgs.expression\r\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid\r\n        this.dependsOn = this.tableMetadataArgs.dependsOn\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a new entity.\r\n     */\r\n    create(\r\n        queryRunner?: QueryRunner,\r\n        options?: { fromDeserializer?: boolean; pojo?: boolean },\r\n    ): any {\r\n        const pojo = options && options.pojo === true ? true : false\r\n        // if target is set to a function (e.g. class) that can be created then create it\r\n        let ret: any\r\n        if (typeof this.target === \"function\" && !pojo) {\r\n            if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {\r\n                ret = new (<any>this.target)()\r\n            } else {\r\n                ret = Object.create(this.target.prototype)\r\n            }\r\n        } else {\r\n            // otherwise simply return a new empty object\r\n            ret = {}\r\n        }\r\n\r\n        // add \"typename\" property\r\n        if (this.connection.options.typename) {\r\n            ret[this.connection.options.typename] = this.targetName\r\n        }\r\n\r\n        this.lazyRelations.forEach((relation) =>\r\n            this.connection.relationLoader.enableLazyLoad(\r\n                relation,\r\n                ret,\r\n                queryRunner,\r\n            ),\r\n        )\r\n        return ret\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity has an id.\r\n     */\r\n    hasId(entity: ObjectLiteral): boolean {\r\n        if (!entity) return false\r\n\r\n        return this.primaryColumns.every((primaryColumn) => {\r\n            const value = primaryColumn.getEntityValue(entity)\r\n            return value !== null && value !== undefined && value !== \"\"\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity / object contains ALL primary keys entity must have.\r\n     * Returns true if it contains all of them, false if at least one of them is not defined.\r\n     */\r\n    hasAllPrimaryKeys(entity: ObjectLiteral): boolean {\r\n        return this.primaryColumns.every((primaryColumn) => {\r\n            const value = primaryColumn.getEntityValue(entity)\r\n            return value !== null && value !== undefined\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Ensures that given object is an entity id map.\r\n     * If given id is an object then it means its already id map.\r\n     * If given id isn't an object then it means its a value of the id column\r\n     * and it creates a new id map with this value and name of the primary column.\r\n     */\r\n    ensureEntityIdMap(id: any): ObjectLiteral {\r\n        if (ObjectUtils.isObject(id)) return id\r\n\r\n        if (this.hasMultiplePrimaryKeys)\r\n            throw new CannotCreateEntityIdMapError(this, id)\r\n\r\n        return this.primaryColumns[0].createValueMap(id)\r\n    }\r\n\r\n    /**\r\n     * Gets primary keys of the entity and returns them in a literal object.\r\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\r\n     * For multiple primary keys it returns multiple keys in object.\r\n     * For primary keys inside embeds it returns complex object literal with keys in them.\r\n     */\r\n    getEntityIdMap(\r\n        entity: ObjectLiteral | undefined,\r\n    ): ObjectLiteral | undefined {\r\n        if (!entity) return undefined\r\n\r\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, {\r\n            skipNulls: true,\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Creates a \"mixed id map\".\r\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\r\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\r\n     * This is called mixed id map.\r\n     */\r\n    getEntityIdMixedMap(\r\n        entity: ObjectLiteral | undefined,\r\n    ): ObjectLiteral | undefined {\r\n        if (!entity) return entity\r\n\r\n        const idMap = this.getEntityIdMap(entity)\r\n        if (this.hasMultiplePrimaryKeys) {\r\n            return idMap\r\n        } else if (idMap) {\r\n            return this.primaryColumns[0].getEntityValue(idMap) // todo: what about parent primary column?\r\n        }\r\n\r\n        return idMap\r\n    }\r\n\r\n    /**\r\n     * Compares two different entities by their ids.\r\n     * Returns true if they match, false otherwise.\r\n     */\r\n    compareEntities(\r\n        firstEntity: ObjectLiteral,\r\n        secondEntity: ObjectLiteral,\r\n    ): boolean {\r\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity)\r\n        if (!firstEntityIdMap) return false\r\n\r\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity)\r\n        if (!secondEntityIdMap) return false\r\n\r\n        return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap)\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given property name.\r\n     */\r\n    findColumnWithPropertyName(\r\n        propertyName: string,\r\n    ): ColumnMetadata | undefined {\r\n        return this.columns.find(\r\n            (column) => column.propertyName === propertyName,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given database name.\r\n     */\r\n    findColumnWithDatabaseName(\r\n        databaseName: string,\r\n    ): ColumnMetadata | undefined {\r\n        return this.columns.find(\r\n            (column) => column.databaseName === databaseName,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Checks if there is a column or relationship with a given property path.\r\n     */\r\n    hasColumnWithPropertyPath(propertyPath: string): boolean {\r\n        const hasColumn = this.columns.some(\r\n            (column) => column.propertyPath === propertyPath,\r\n        )\r\n        return hasColumn || this.hasRelationWithPropertyPath(propertyPath)\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given property path.\r\n     */\r\n    findColumnWithPropertyPath(\r\n        propertyPath: string,\r\n    ): ColumnMetadata | undefined {\r\n        const column = this.columns.find(\r\n            (column) => column.propertyPath === propertyPath,\r\n        )\r\n        if (column) return column\r\n\r\n        // in the case if column with property path was not found, try to find a relation with such property path\r\n        // if we find relation and it has a single join column then its the column user was seeking\r\n        const relation = this.relations.find(\r\n            (relation) => relation.propertyPath === propertyPath,\r\n        )\r\n        if (relation && relation.joinColumns.length === 1)\r\n            return relation.joinColumns[0]\r\n\r\n        return undefined\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given property path.\r\n     * Does not search in relation unlike findColumnWithPropertyPath.\r\n     */\r\n    findColumnWithPropertyPathStrict(\r\n        propertyPath: string,\r\n    ): ColumnMetadata | undefined {\r\n        return this.columns.find(\r\n            (column) => column.propertyPath === propertyPath,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Finds columns with a given property path.\r\n     * Property path can match a relation, and relations can contain multiple columns.\r\n     */\r\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\r\n        const column = this.columns.find(\r\n            (column) => column.propertyPath === propertyPath,\r\n        )\r\n        if (column) return [column]\r\n\r\n        // in the case if column with property path was not found, try to find a relation with such property path\r\n        // if we find relation and it has a single join column then its the column user was seeking\r\n        const relation = this.findRelationWithPropertyPath(propertyPath)\r\n        if (relation && relation.joinColumns) return relation.joinColumns\r\n\r\n        return []\r\n    }\r\n\r\n    /**\r\n     * Checks if there is a relation with the given property path.\r\n     */\r\n    hasRelationWithPropertyPath(propertyPath: string): boolean {\r\n        return this.relations.some(\r\n            (relation) => relation.propertyPath === propertyPath,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Finds relation with the given property path.\r\n     */\r\n    findRelationWithPropertyPath(\r\n        propertyPath: string,\r\n    ): RelationMetadata | undefined {\r\n        return this.relations.find(\r\n            (relation) => relation.propertyPath === propertyPath,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Checks if there is an embedded with a given property path.\r\n     */\r\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\r\n        return this.allEmbeddeds.some(\r\n            (embedded) => embedded.propertyPath === propertyPath,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Finds embedded with a given property path.\r\n     */\r\n    findEmbeddedWithPropertyPath(\r\n        propertyPath: string,\r\n    ): EmbeddedMetadata | undefined {\r\n        return this.allEmbeddeds.find(\r\n            (embedded) => embedded.propertyPath === propertyPath,\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Returns an array of databaseNames mapped from provided propertyPaths\r\n     */\r\n    mapPropertyPathsToColumns(propertyPaths: string[]) {\r\n        return propertyPaths.map((propertyPath) => {\r\n            const column = this.findColumnWithPropertyPath(propertyPath)\r\n            if (column == null) {\r\n                throw new EntityPropertyNotFoundError(propertyPath, this)\r\n            }\r\n            return column\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Iterates through entity and finds and extracts all values from relations in the entity.\r\n     * If relation value is an array its being flattened.\r\n     */\r\n    extractRelationValuesFromEntity(\r\n        entity: ObjectLiteral,\r\n        relations: RelationMetadata[],\r\n    ): [RelationMetadata, any, EntityMetadata][] {\r\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = []\r\n        relations.forEach((relation) => {\r\n            const value = relation.getEntityValue(entity)\r\n            if (Array.isArray(value)) {\r\n                value.forEach((subValue) =>\r\n                    relationsAndValues.push([\r\n                        relation,\r\n                        subValue,\r\n                        EntityMetadata.getInverseEntityMetadata(\r\n                            subValue,\r\n                            relation,\r\n                        ),\r\n                    ]),\r\n                )\r\n            } else if (value) {\r\n                relationsAndValues.push([\r\n                    relation,\r\n                    value,\r\n                    EntityMetadata.getInverseEntityMetadata(value, relation),\r\n                ])\r\n            }\r\n        })\r\n        return relationsAndValues\r\n    }\r\n\r\n    /**\r\n     * In the case of SingleTableInheritance, find the correct metadata\r\n     * for a given value.\r\n     *\r\n     * @param value The value to find the metadata for.\r\n     * @returns The found metadata for the entity or the base metadata if no matching metadata\r\n     *          was found in the whole inheritance tree.\r\n     */\r\n    findInheritanceMetadata(value: any): EntityMetadata {\r\n        // Check for single table inheritance and find the correct metadata in that case.\r\n        // Goal is to use the correct discriminator as we could have a repository\r\n        // for an (abstract) base class and thus the target would not match.\r\n\r\n        if (\r\n            this.inheritancePattern === \"STI\" &&\r\n            this.childEntityMetadatas.length > 0\r\n        ) {\r\n            // There could be a column on the base class that can manually be set to override the type.\r\n            let manuallySetDiscriminatorValue: unknown\r\n            if (this.discriminatorColumn) {\r\n                manuallySetDiscriminatorValue =\r\n                    value[this.discriminatorColumn.propertyName]\r\n            }\r\n            return (\r\n                this.childEntityMetadatas.find(\r\n                    (meta) =>\r\n                        manuallySetDiscriminatorValue ===\r\n                            meta.discriminatorValue ||\r\n                        value.constructor === meta.target,\r\n                ) || this\r\n            )\r\n        }\r\n        return this\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Static Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    private static getInverseEntityMetadata(\r\n        value: any,\r\n        relation: RelationMetadata,\r\n    ): EntityMetadata {\r\n        return relation.inverseEntityMetadata.findInheritanceMetadata(value)\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Static Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a property paths for a given entity.\r\n     *\r\n     * @deprecated\r\n     */\r\n    static createPropertyPath(\r\n        metadata: EntityMetadata,\r\n        entity: ObjectLiteral,\r\n        prefix: string = \"\",\r\n    ) {\r\n        const paths: string[] = []\r\n        Object.keys(entity).forEach((key) => {\r\n            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\r\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\r\n            const parentPath = prefix ? prefix + \".\" + key : key\r\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\r\n                const subPaths = this.createPropertyPath(\r\n                    metadata,\r\n                    entity[key],\r\n                    parentPath,\r\n                )\r\n                paths.push(...subPaths)\r\n            } else {\r\n                const path = prefix ? prefix + \".\" + key : key\r\n                paths.push(path)\r\n            }\r\n        })\r\n        return paths\r\n    }\r\n\r\n    /**\r\n     * Finds difference between two entity id maps.\r\n     * Returns items that exist in the first array and absent in the second array.\r\n     */\r\n    static difference(\r\n        firstIdMaps: ObjectLiteral[],\r\n        secondIdMaps: ObjectLiteral[],\r\n    ): ObjectLiteral[] {\r\n        return firstIdMaps.filter((firstIdMap) => {\r\n            return !secondIdMaps.find((secondIdMap) =>\r\n                OrmUtils.compareIds(firstIdMap, secondIdMap),\r\n            )\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Creates value map from the given values and columns.\r\n     * Examples of usages are primary columns map and join columns map.\r\n     */\r\n    static getValueMap(\r\n        entity: ObjectLiteral,\r\n        columns: ColumnMetadata[],\r\n        options?: { skipNulls?: boolean },\r\n    ): ObjectLiteral | undefined {\r\n        return columns.reduce((map, column) => {\r\n            const value = column.getEntityValueMap(entity, options)\r\n\r\n            // make sure that none of the values of the columns are not missing\r\n            if (map === undefined || value === null || value === undefined)\r\n                return undefined\r\n\r\n            return OrmUtils.mergeDeep(map, value)\r\n        }, {} as ObjectLiteral | undefined)\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Builder Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    build() {\r\n        const namingStrategy = this.connection.namingStrategy\r\n        const entityPrefix = this.connection.options.entityPrefix\r\n        const entitySkipConstructor =\r\n            this.connection.options.entitySkipConstructor\r\n\r\n        this.engine = this.tableMetadataArgs.engine\r\n        this.database =\r\n            this.tableMetadataArgs.type === \"entity-child\" &&\r\n            this.parentEntityMetadata\r\n                ? this.parentEntityMetadata.database\r\n                : this.tableMetadataArgs.database\r\n        if (this.tableMetadataArgs.schema) {\r\n            this.schema = this.tableMetadataArgs.schema\r\n        } else if (\r\n            this.tableMetadataArgs.type === \"entity-child\" &&\r\n            this.parentEntityMetadata\r\n        ) {\r\n            this.schema = this.parentEntityMetadata.schema\r\n        } else if (this.connection.options?.hasOwnProperty(\"schema\")) {\r\n            this.schema = (this.connection.options as any).schema\r\n        }\r\n        this.givenTableName =\r\n            this.tableMetadataArgs.type === \"entity-child\" &&\r\n            this.parentEntityMetadata\r\n                ? this.parentEntityMetadata.givenTableName\r\n                : this.tableMetadataArgs.name\r\n        this.synchronize =\r\n            this.tableMetadataArgs.synchronize === false ? false : true\r\n        this.targetName =\r\n            typeof this.tableMetadataArgs.target === \"function\"\r\n                ? (this.tableMetadataArgs.target as any).name\r\n                : this.tableMetadataArgs.target\r\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\r\n            this.tableNameWithoutPrefix =\r\n                namingStrategy.closureJunctionTableName(this.givenTableName!)\r\n        } else if (\r\n            this.tableMetadataArgs.type === \"entity-child\" &&\r\n            this.parentEntityMetadata\r\n        ) {\r\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\r\n                this.parentEntityMetadata.targetName,\r\n                this.parentEntityMetadata.givenTableName,\r\n            )\r\n        } else {\r\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\r\n                this.targetName,\r\n                this.givenTableName,\r\n            )\r\n\r\n            if (\r\n                this.tableMetadataArgs.type === \"junction\" &&\r\n                this.connection.driver.maxAliasLength &&\r\n                this.connection.driver.maxAliasLength > 0 &&\r\n                this.tableNameWithoutPrefix.length >\r\n                    this.connection.driver.maxAliasLength\r\n            ) {\r\n                // note: we are not using DriverUtils.buildAlias here because we would like to avoid\r\n                // hashed table names. However, current algorithm also isn't perfect, but we cannot\r\n                // change it, since it's a big breaking change. Planned to 0.4.0\r\n                this.tableNameWithoutPrefix = shorten(\r\n                    this.tableNameWithoutPrefix,\r\n                    { separator: \"_\", segmentLength: 3 },\r\n                )\r\n            }\r\n        }\r\n        this.tableName = entityPrefix\r\n            ? namingStrategy.prefixTableName(\r\n                  entityPrefix,\r\n                  this.tableNameWithoutPrefix,\r\n              )\r\n            : this.tableNameWithoutPrefix\r\n        this.target = this.target ? this.target : this.tableName\r\n        this.name = this.targetName ? this.targetName : this.tableName\r\n        this.expression = this.tableMetadataArgs.expression\r\n        this.withoutRowid =\r\n            this.tableMetadataArgs.withoutRowid === true ? true : false\r\n        this.tablePath = this.connection.driver.buildTableName(\r\n            this.tableName,\r\n            this.schema,\r\n            this.database,\r\n        )\r\n        this.orderBy =\r\n            typeof this.tableMetadataArgs.orderBy === \"function\"\r\n                ? this.tableMetadataArgs.orderBy(this.propertiesMap)\r\n                : this.tableMetadataArgs.orderBy // todo: is propertiesMap available here? Looks like its not\r\n\r\n        if (entitySkipConstructor !== undefined) {\r\n            this.isAlwaysUsingConstructor = !entitySkipConstructor\r\n        }\r\n\r\n        this.isJunction =\r\n            this.tableMetadataArgs.type === \"closure-junction\" ||\r\n            this.tableMetadataArgs.type === \"junction\"\r\n        this.isClosureJunction =\r\n            this.tableMetadataArgs.type === \"closure-junction\"\r\n\r\n        this.comment = this.tableMetadataArgs.comment\r\n    }\r\n\r\n    /**\r\n     * Registers a new column in the entity and recomputes all depend properties.\r\n     */\r\n    registerColumn(column: ColumnMetadata) {\r\n        if (this.ownColumns.indexOf(column) !== -1) return\r\n\r\n        this.ownColumns.push(column)\r\n        this.columns = this.embeddeds.reduce(\r\n            (columns, embedded) => columns.concat(embedded.columnsFromTree),\r\n            this.ownColumns,\r\n        )\r\n        this.primaryColumns = this.columns.filter((column) => column.isPrimary)\r\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1\r\n        this.hasUUIDGeneratedColumns =\r\n            this.columns.filter(\r\n                (column) =>\r\n                    column.isGenerated || column.generationStrategy === \"uuid\",\r\n            ).length > 0\r\n        this.propertiesMap = this.createPropertiesMap()\r\n        if (this.childEntityMetadatas)\r\n            this.childEntityMetadatas.forEach((entityMetadata) =>\r\n                entityMetadata.registerColumn(column),\r\n            )\r\n    }\r\n\r\n    /**\r\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\r\n     * in a special format - { propertyName: propertyName }.\r\n     *\r\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\r\n     * This method will create following object:\r\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\r\n     */\r\n    createPropertiesMap(): { [name: string]: string | any } {\r\n        const map: { [name: string]: string | any } = {}\r\n        this.columns.forEach((column) =>\r\n            OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)),\r\n        )\r\n        this.relations.forEach((relation) =>\r\n            OrmUtils.mergeDeep(\r\n                map,\r\n                relation.createValueMap(relation.propertyPath),\r\n            ),\r\n        )\r\n        return map\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has any column which rely on returning data,\r\n     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\r\n     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\r\n     * it means we cannot execute bulk inserts in some cases.\r\n     */\r\n    getInsertionReturningColumns(): ColumnMetadata[] {\r\n        return this.columns.filter((column) => {\r\n            return (\r\n                column.default !== undefined ||\r\n                column.asExpression !== undefined ||\r\n                column.isGenerated ||\r\n                column.isCreateDate ||\r\n                column.isUpdateDate ||\r\n                column.isDeleteDate ||\r\n                column.isVersion\r\n            )\r\n        })\r\n    }\r\n}\r\n"],"sourceRoot":".."}