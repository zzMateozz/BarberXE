{"version":3,"sources":["../browser/src/persistence/subject-builder/OneToManySubjectBuilder.ts"],"names":[],"mappings":"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","file":"OneToManySubjectBuilder.js","sourcesContent":["import { Subject } from \"../Subject\"\r\nimport { OrmUtils } from \"../../util/OrmUtils\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\r\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\r\n\r\n/**\r\n * Builds operations needs to be executed for one-to-many relations of the given subjects.\r\n *\r\n * by example: post contains one-to-many relation with category in the property called \"categories\", e.g.\r\n *             @OneToMany(type => Category, category => category.post) categories: Category[]\r\n *             If user adds categories into the post and saves post we need to bind them.\r\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\r\n *\r\n * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class\r\n *       make sure to reflect changes there as well.\r\n */\r\nexport class OneToManySubjectBuilder {\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(protected subjects: Subject[]) {}\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds all required operations.\r\n     */\r\n    build(): void {\r\n        this.subjects.forEach((subject) => {\r\n            subject.metadata.oneToManyRelations.forEach((relation) => {\r\n                // skip relations for which persistence is disabled\r\n                if (relation.persistenceEnabled === false) return\r\n\r\n                this.buildForSubjectRelation(subject, relation)\r\n            })\r\n        })\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Protected Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds operations for a given subject and relation.\r\n     *\r\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\r\n     */\r\n    protected buildForSubjectRelation(\r\n        subject: Subject,\r\n        relation: RelationMetadata,\r\n    ) {\r\n        // prepare objects (relation id maps) for the database entity\r\n        // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,\r\n        //             particularly their relation ids, e.g. category ids stored in the database\r\n\r\n        // in most cases relatedEntityDatabaseValues will contain only the entity key properties.\r\n        // this is because subject.databaseEntity contains relations with loaded relation ids only.\r\n        // however if the entity uses the afterLoad hook to calculate any properties, the fetched \"key object\" might include ADDITIONAL properties.\r\n        // to handle such situations, we pass the data to relation.inverseEntityMetadata.getEntityIdMap to extract the key without any other properties.\r\n\r\n        let relatedEntityDatabaseRelationIds: ObjectLiteral[] = []\r\n        if (subject.databaseEntity) {\r\n            // related entities in the database can exist only if this entity (post) is saved\r\n            const relatedEntityDatabaseRelation: ObjectLiteral[] | undefined =\r\n                relation.getEntityValue(subject.databaseEntity)\r\n            if (relatedEntityDatabaseRelation) {\r\n                relatedEntityDatabaseRelationIds =\r\n                    relatedEntityDatabaseRelation.map(\r\n                        (entity) =>\r\n                            relation.inverseEntityMetadata.getEntityIdMap(\r\n                                entity,\r\n                            )!,\r\n                    )\r\n            }\r\n        }\r\n\r\n        // get related entities of persisted entity\r\n        // by example: get categories from the passed to persist post entity\r\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(\r\n            subject.entity!,\r\n        )\r\n        if (relatedEntities === null)\r\n            // we treat relations set to null as removed, so we don't skip it\r\n            relatedEntities = [] as ObjectLiteral[]\r\n        if (relatedEntities === undefined)\r\n            // if relation is undefined then nothing to update\r\n            return\r\n\r\n        // extract only relation ids from the related entities, since we only need them for comparison\r\n        // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)\r\n        const relatedPersistedEntityRelationIds: ObjectLiteral[] = []\r\n        relatedEntities.forEach((relatedEntity) => {\r\n            // by example: relatedEntity is a category here\r\n            let relationIdMap =\r\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity) // by example: relationIdMap is category.id map here, e.g. { id: ... }\r\n\r\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\r\n            let relatedEntitySubject = this.subjects.find((subject) => {\r\n                return subject.entity === relatedEntity\r\n            })\r\n\r\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\r\n            if (relatedEntitySubject)\r\n                relationIdMap = relatedEntitySubject.identifier\r\n\r\n            // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\r\n            // by example: if post contains categories which does not have ids yet (because they are new)\r\n            //             it means they are always newly inserted and relation update operation always must be created for them\r\n            //             it does not make sense to perform difference operation for them for both add and remove actions\r\n            if (!relationIdMap) {\r\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\r\n                // if (!relatedEntitySubject)\r\n                //     throw new TypeORMError(`One-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\r\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\r\n                //         `Please setup cascade insertion or save entities before binding it.`);\r\n                if (!relatedEntitySubject) return\r\n\r\n                // okay, so related subject exist and its marked for insertion, then add a new change map\r\n                // by example: this will tell category to insert into its post relation our post we are working with\r\n                //             relatedEntitySubject is newly inserted CategorySubject\r\n                //             relation.inverseRelation is ManyToOne relation inside Category\r\n                //             subject is Post needs to be inserted into Category\r\n                relatedEntitySubject.changeMaps.push({\r\n                    relation: relation.inverseRelation!,\r\n                    value: subject,\r\n                })\r\n\r\n                return\r\n            }\r\n\r\n            // check if this binding really exist in the database\r\n            // by example: find our category if its already bind in the database\r\n            const relationIdInDatabaseSubjectRelation =\r\n                relatedEntityDatabaseRelationIds.find(\r\n                    (relatedDatabaseEntityRelationId) => {\r\n                        return OrmUtils.compareIds(\r\n                            relationIdMap,\r\n                            relatedDatabaseEntityRelationId,\r\n                        )\r\n                    },\r\n                )\r\n\r\n            // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to \"bind\" them\r\n            // by example: this will tell category to insert into its post relation our post we are working with\r\n            //             relatedEntitySubject is newly inserted CategorySubject\r\n            //             relation.inverseRelation is ManyToOne relation inside Category\r\n            //             subject is Post needs to be inserted into Category\r\n            if (!relationIdInDatabaseSubjectRelation) {\r\n                // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\r\n                // but since we are going to update \"category\" table (since its an owning side of relation with join column)\r\n                // we create a new subject here:\r\n                if (!relatedEntitySubject) {\r\n                    relatedEntitySubject = new Subject({\r\n                        metadata: relation.inverseEntityMetadata,\r\n                        parentSubject: subject,\r\n                        canBeUpdated: true,\r\n                        identifier: relationIdMap,\r\n                    })\r\n                    this.subjects.push(relatedEntitySubject)\r\n                }\r\n\r\n                relatedEntitySubject.changeMaps.push({\r\n                    relation: relation.inverseRelation!,\r\n                    value: subject,\r\n                })\r\n            }\r\n\r\n            // if related entity has relation id then we add it to the list of relation ids\r\n            // this list will be used later to compare with database relation ids to find a difference\r\n            // what exist in this array and does not exist in the database are newly inserted relations\r\n            // what does not exist in this array, but exist in the database are removed relations\r\n            // removed relations are set to null from inverse side of relation\r\n            relatedPersistedEntityRelationIds.push(relationIdMap)\r\n        })\r\n\r\n        // find what related entities were added and what were removed based on difference between what we save and what database has\r\n        if (relation.inverseRelation?.orphanedRowAction !== \"disable\") {\r\n            EntityMetadata.difference(\r\n                relatedEntityDatabaseRelationIds,\r\n                relatedPersistedEntityRelationIds,\r\n            ).forEach((removedRelatedEntityRelationId) => {\r\n                // by example: removedRelatedEntityRelationId is category that was bind in the database before, but now its unbind\r\n\r\n                // todo: probably we can improve this in the future by finding entity with column those values,\r\n                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\r\n                // we create a new subject which operations will be executed in subject operation executor\r\n                const removedRelatedEntitySubject = new Subject({\r\n                    metadata: relation.inverseEntityMetadata,\r\n                    parentSubject: subject,\r\n                    identifier: removedRelatedEntityRelationId,\r\n                })\r\n\r\n                if (\r\n                    !relation.inverseRelation ||\r\n                    relation.inverseRelation.orphanedRowAction === \"nullify\"\r\n                ) {\r\n                    removedRelatedEntitySubject.canBeUpdated = true\r\n                    removedRelatedEntitySubject.changeMaps = [\r\n                        {\r\n                            relation: relation.inverseRelation!,\r\n                            value: null,\r\n                        },\r\n                    ]\r\n                } else if (\r\n                    relation.inverseRelation.orphanedRowAction === \"delete\"\r\n                ) {\r\n                    removedRelatedEntitySubject.mustBeRemoved = true\r\n                } else if (\r\n                    relation.inverseRelation.orphanedRowAction === \"soft-delete\"\r\n                ) {\r\n                    removedRelatedEntitySubject.canBeSoftRemoved = true\r\n                }\r\n\r\n                this.subjects.push(removedRelatedEntitySubject)\r\n            })\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}