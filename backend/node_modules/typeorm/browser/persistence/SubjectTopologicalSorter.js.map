{"version":3,"sources":["../browser/src/persistence/SubjectTopologicalSorter.ts"],"names":[],"mappings":"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","file":"SubjectTopologicalSorter.js","sourcesContent":["import { Subject } from \"./Subject\"\r\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\r\nimport { TypeORMError } from \"../error\"\r\n\r\n/**\r\n * Orders insert or remove subjects in proper order (using topological sorting)\r\n * to make sure insert or remove operations are executed in a proper order.\r\n */\r\nexport class SubjectTopologicalSorter {\r\n    // -------------------------------------------------------------------------\r\n    // Public Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Insert subjects needs to be sorted.\r\n     */\r\n    subjects: Subject[]\r\n\r\n    /**\r\n     * Unique list of entity metadatas of this subject.\r\n     */\r\n    metadatas: EntityMetadata[]\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(subjects: Subject[]) {\r\n        this.subjects = [...subjects] // copy subjects to prevent changing of sent array\r\n        this.metadatas = this.getUniqueMetadatas(this.subjects)\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Sorts (orders) subjects in their topological order.\r\n     */\r\n    sort(direction: \"insert\" | \"delete\"): Subject[] {\r\n        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\r\n        if (!this.metadatas.length) return this.subjects\r\n\r\n        const sortedSubjects: Subject[] = []\r\n\r\n        // first if we sort for deletion all junction subjects\r\n        // junction subjects are subjects without entity and database entity set\r\n        if (direction === \"delete\") {\r\n            const junctionSubjects = this.subjects.filter(\r\n                (subject) => !subject.entity && !subject.databaseEntity,\r\n            )\r\n            sortedSubjects.push(...junctionSubjects)\r\n            this.removeAlreadySorted(junctionSubjects)\r\n        }\r\n\r\n        // next we always insert entities with non-nullable relations, sort them first\r\n        const nonNullableDependencies = this.getNonNullableDependencies()\r\n        let sortedNonNullableEntityTargets = this.toposort(\r\n            nonNullableDependencies,\r\n        )\r\n        if (direction === \"insert\")\r\n            sortedNonNullableEntityTargets =\r\n                sortedNonNullableEntityTargets.reverse()\r\n\r\n        // so we have a sorted entity targets\r\n        // go thought each of them and find all subjects with sorted entity target\r\n        // add those sorted targets and remove them from original array of targets\r\n        sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {\r\n            const entityTargetSubjects = this.subjects.filter(\r\n                (subject) =>\r\n                    subject.metadata.targetName === sortedEntityTarget ||\r\n                    subject.metadata.inheritanceTree.some(\r\n                        (s) => s.name === sortedEntityTarget,\r\n                    ),\r\n            )\r\n            sortedSubjects.push(...entityTargetSubjects)\r\n            this.removeAlreadySorted(entityTargetSubjects)\r\n        })\r\n\r\n        // next sort all other entities\r\n        // same process as in above but with other entities\r\n        const otherDependencies: string[][] = this.getDependencies()\r\n        let sortedOtherEntityTargets = this.toposort(otherDependencies)\r\n        if (direction === \"insert\")\r\n            sortedOtherEntityTargets = sortedOtherEntityTargets.reverse()\r\n\r\n        sortedOtherEntityTargets.forEach((sortedEntityTarget) => {\r\n            const entityTargetSubjects = this.subjects.filter(\r\n                (subject) => subject.metadata.targetName === sortedEntityTarget,\r\n            )\r\n            sortedSubjects.push(...entityTargetSubjects)\r\n            this.removeAlreadySorted(entityTargetSubjects)\r\n        })\r\n\r\n        // if we have something left in the subjects add them as well\r\n        sortedSubjects.push(...this.subjects)\r\n        return sortedSubjects\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Removes already sorted subjects from this.subjects list of subjects.\r\n     */\r\n    protected removeAlreadySorted(subjects: Subject[]) {\r\n        subjects.forEach((subject) => {\r\n            this.subjects.splice(this.subjects.indexOf(subject), 1)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Extracts all unique metadatas from the given subjects.\r\n     */\r\n    protected getUniqueMetadatas(subjects: Subject[]) {\r\n        const metadatas: EntityMetadata[] = []\r\n        subjects.forEach((subject) => {\r\n            if (metadatas.indexOf(subject.metadata) === -1)\r\n                metadatas.push(subject.metadata)\r\n        })\r\n        return metadatas\r\n    }\r\n\r\n    /**\r\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\r\n     * We need to execute insertions first for entities which non-nullable relations.\r\n     */\r\n    protected getNonNullableDependencies(): string[][] {\r\n        return this.metadatas.reduce((dependencies, metadata) => {\r\n            metadata.relationsWithJoinColumns.forEach((relation) => {\r\n                if (relation.isNullable) return\r\n\r\n                dependencies.push([\r\n                    metadata.targetName,\r\n                    relation.inverseEntityMetadata.targetName,\r\n                ])\r\n            })\r\n            return dependencies\r\n        }, [] as string[][])\r\n    }\r\n\r\n    /**\r\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\r\n     * We need to execute insertions first for entities which non-nullable relations.\r\n     */\r\n    protected getDependencies(): string[][] {\r\n        return this.metadatas.reduce((dependencies, metadata) => {\r\n            metadata.relationsWithJoinColumns.forEach((relation) => {\r\n                // if relation is self-referenced we skip it\r\n                if (relation.inverseEntityMetadata === metadata) return\r\n\r\n                dependencies.push([\r\n                    metadata.targetName,\r\n                    relation.inverseEntityMetadata.targetName,\r\n                ])\r\n            })\r\n            return dependencies\r\n        }, [] as string[][])\r\n    }\r\n\r\n    /**\r\n     * Sorts given graph using topological sorting algorithm.\r\n     *\r\n     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\r\n     */\r\n    protected toposort(edges: any[][]) {\r\n        function uniqueNodes(arr: any[]) {\r\n            let res = []\r\n            for (let i = 0, len = arr.length; i < len; i++) {\r\n                let edge: any = arr[i]\r\n                if (res.indexOf(edge[0]) < 0) res.push(edge[0])\r\n                if (res.indexOf(edge[1]) < 0) res.push(edge[1])\r\n            }\r\n            return res\r\n        }\r\n\r\n        const nodes = uniqueNodes(edges)\r\n        let cursor = nodes.length,\r\n            sorted = new Array(cursor),\r\n            visited: any = {},\r\n            i = cursor\r\n\r\n        while (i--) {\r\n            if (!visited[i]) visit(nodes[i], i, [])\r\n        }\r\n\r\n        function visit(node: any, i: number, predecessors: any[]) {\r\n            if (predecessors.indexOf(node) >= 0) {\r\n                throw new TypeORMError(\r\n                    \"Cyclic dependency: \" + JSON.stringify(node),\r\n                ) // todo: better error\r\n            }\r\n\r\n            if (!~nodes.indexOf(node)) {\r\n                throw new TypeORMError(\r\n                    \"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" +\r\n                        JSON.stringify(node),\r\n                )\r\n            }\r\n\r\n            if (visited[i]) return\r\n            visited[i] = true\r\n\r\n            // outgoing edges\r\n            let outgoing = edges.filter(function (edge) {\r\n                return edge[0] === node\r\n            })\r\n            if ((i = outgoing.length)) {\r\n                let preds = predecessors.concat(node)\r\n                do {\r\n                    let child = outgoing[--i][1]\r\n                    visit(child, nodes.indexOf(child), preds)\r\n                } while (i)\r\n            }\r\n\r\n            sorted[--cursor] = node\r\n        }\r\n\r\n        return sorted\r\n    }\r\n}\r\n"],"sourceRoot":".."}