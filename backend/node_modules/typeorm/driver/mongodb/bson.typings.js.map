{"version":3,"sources":["../../src/driver/mongodb/bson.typings.ts"],"names":[],"mappings":"","file":"bson.typings.js","sourcesContent":["/**\r\n * A class representation of the BSON Binary type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class Binary extends BSONValue {\r\n    get _bsontype(): \"Binary\"\r\n    /* Excluded from this release type: BSON_BINARY_SUBTYPE_DEFAULT */\r\n    /** Initial buffer default size */\r\n    static readonly BUFFER_SIZE = 256\r\n    /** Default BSON type */\r\n    static readonly SUBTYPE_DEFAULT = 0\r\n    /** Function BSON type */\r\n    static readonly SUBTYPE_FUNCTION = 1\r\n    /** Byte Array BSON type */\r\n    static readonly SUBTYPE_BYTE_ARRAY = 2\r\n    /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */\r\n    static readonly SUBTYPE_UUID_OLD = 3\r\n    /** UUID BSON type */\r\n    static readonly SUBTYPE_UUID = 4\r\n    /** MD5 BSON type */\r\n    static readonly SUBTYPE_MD5 = 5\r\n    /** Encrypted BSON type */\r\n    static readonly SUBTYPE_ENCRYPTED = 6\r\n    /** Column BSON type */\r\n    static readonly SUBTYPE_COLUMN = 7\r\n    /** User BSON type */\r\n    static readonly SUBTYPE_USER_DEFINED = 128\r\n    buffer: Uint8Array\r\n    sub_type: number\r\n    position: number\r\n    /**\r\n     * Create a new Binary instance.\r\n     *\r\n     * This constructor can accept a string as its first argument. In this case,\r\n     * this string will be encoded using ISO-8859-1, **not** using UTF-8.\r\n     * This is almost certainly not what you want. Use `new Binary(Buffer.from(string))`\r\n     * instead to convert the string to a Buffer using UTF-8 first.\r\n     *\r\n     * @param buffer - a buffer object containing the binary data.\r\n     * @param subType - the option binary type.\r\n     */\r\n    constructor(buffer?: string | BinarySequence, subType?: number)\r\n    /**\r\n     * Updates this binary with byte_value.\r\n     *\r\n     * @param byteValue - a single byte we wish to write.\r\n     */\r\n    put(byteValue: string | number | Uint8Array | number[]): void\r\n    /**\r\n     * Writes a buffer or string to the binary.\r\n     *\r\n     * @param sequence - a string or buffer to be written to the Binary BSON object.\r\n     * @param offset - specify the binary of where to write the content.\r\n     */\r\n    write(sequence: string | BinarySequence, offset: number): void\r\n    /**\r\n     * Reads **length** bytes starting at **position**.\r\n     *\r\n     * @param position - read from the given position in the Binary.\r\n     * @param length - the number of bytes to read.\r\n     */\r\n    read(position: number, length: number): BinarySequence\r\n    /**\r\n     * Returns the value of this binary as a string.\r\n     * @param asRaw - Will skip converting to a string\r\n     * @remarks\r\n     * This is handy when calling this function conditionally for some key value pairs and not others\r\n     */\r\n    value(asRaw?: boolean): string | BinarySequence\r\n    /** the length of the binary sequence */\r\n    length(): number\r\n    toJSON(): string\r\n    toString(encoding?: \"hex\" | \"base64\" | \"utf8\" | \"utf-8\"): string\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    toUUID(): UUID\r\n    /** Creates an Binary instance from a hex digit string */\r\n    static createFromHexString(hex: string, subType?: number): Binary\r\n    /** Creates an Binary instance from a base64 string */\r\n    static createFromBase64(base64: string, subType?: number): Binary\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface BinaryExtended {\r\n    $binary: {\r\n        subType: string\r\n        base64: string\r\n    }\r\n}\r\n\r\n/** @public */\r\nexport declare interface BinaryExtendedLegacy {\r\n    $type: string\r\n    $binary: string\r\n}\r\n\r\n/** @public */\r\nexport declare type BinarySequence = Uint8Array | number[]\r\n\r\ndeclare namespace BSON {\r\n    export {\r\n        setInternalBufferSize,\r\n        serialize,\r\n        serializeWithBufferAndIndex,\r\n        deserialize,\r\n        calculateObjectSize,\r\n        deserializeStream,\r\n        UUIDExtended,\r\n        BinaryExtended,\r\n        BinaryExtendedLegacy,\r\n        BinarySequence,\r\n        CodeExtended,\r\n        DBRefLike,\r\n        Decimal128Extended,\r\n        DoubleExtended,\r\n        EJSONOptions,\r\n        Int32Extended,\r\n        LongExtended,\r\n        MaxKeyExtended,\r\n        MinKeyExtended,\r\n        ObjectIdExtended,\r\n        ObjectIdLike,\r\n        BSONRegExpExtended,\r\n        BSONRegExpExtendedLegacy,\r\n        BSONSymbolExtended,\r\n        LongWithoutOverrides,\r\n        TimestampExtended,\r\n        TimestampOverrides,\r\n        LongWithoutOverridesClass,\r\n        SerializeOptions,\r\n        DeserializeOptions,\r\n        Code,\r\n        BSONSymbol,\r\n        DBRef,\r\n        Binary,\r\n        ObjectId,\r\n        UUID,\r\n        Long,\r\n        Timestamp,\r\n        Double,\r\n        Int32,\r\n        MinKey,\r\n        MaxKey,\r\n        BSONRegExp,\r\n        Decimal128,\r\n        BSONValue,\r\n        BSONError,\r\n        BSONVersionError,\r\n        BSONRuntimeError,\r\n        BSONType,\r\n        EJSON,\r\n        Document,\r\n        CalculateObjectSizeOptions,\r\n    }\r\n}\r\nexport { BSON }\r\n\r\n/**\r\n * @public\r\n * @category Error\r\n *\r\n * `BSONError` objects are thrown when BSON ecounters an error.\r\n *\r\n * This is the parent class for all the other errors thrown by this library.\r\n */\r\nexport declare class BSONError extends Error {\r\n    /* Excluded from this release type: bsonError */\r\n    get name(): string\r\n    constructor(message: string)\r\n    /**\r\n     * @public\r\n     *\r\n     * All errors thrown from the BSON library inherit from `BSONError`.\r\n     * This method can assist with determining if an error originates from the BSON library\r\n     * even if it does not pass an `instanceof` check against this class' constructor.\r\n     *\r\n     * @param value - any javascript value that needs type checking\r\n     */\r\n    static isBSONError(value: unknown): value is BSONError\r\n}\r\n\r\n/**\r\n * A class representation of the BSON RegExp type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class BSONRegExp extends BSONValue {\r\n    get _bsontype(): \"BSONRegExp\"\r\n    pattern: string\r\n    options: string\r\n    /**\r\n     * @param pattern - The regular expression pattern to match\r\n     * @param options - The regular expression options\r\n     */\r\n    constructor(pattern: string, options?: string)\r\n    static parseOptions(options?: string): string\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface BSONRegExpExtended {\r\n    $regularExpression: {\r\n        pattern: string\r\n        options: string\r\n    }\r\n}\r\n\r\n/** @public */\r\nexport declare interface BSONRegExpExtendedLegacy {\r\n    $regex: string | BSONRegExp\r\n    $options: string\r\n}\r\n\r\n/**\r\n * @public\r\n * @category Error\r\n *\r\n * An error generated when BSON functions encounter an unexpected input\r\n * or reaches an unexpected/invalid internal state\r\n *\r\n */\r\nexport declare class BSONRuntimeError extends BSONError {\r\n    get name(): \"BSONRuntimeError\"\r\n    constructor(message: string)\r\n}\r\n\r\n/**\r\n * A class representation of the BSON Symbol type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class BSONSymbol extends BSONValue {\r\n    get _bsontype(): \"BSONSymbol\"\r\n    value: string\r\n    /**\r\n     * @param value - the string representing the symbol.\r\n     */\r\n    constructor(value: string)\r\n    /** Access the wrapped string value. */\r\n    valueOf(): string\r\n    toString(): string\r\n    inspect(): string\r\n    toJSON(): string\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n}\r\n\r\n/** @public */\r\nexport declare interface BSONSymbolExtended {\r\n    $symbol: string\r\n}\r\n\r\n/** @public */\r\nexport declare const BSONType: Readonly<{\r\n    readonly double: 1\r\n    readonly string: 2\r\n    readonly object: 3\r\n    readonly array: 4\r\n    readonly binData: 5\r\n    readonly undefined: 6\r\n    readonly objectId: 7\r\n    readonly bool: 8\r\n    readonly date: 9\r\n    readonly null: 10\r\n    readonly regex: 11\r\n    readonly dbPointer: 12\r\n    readonly javascript: 13\r\n    readonly symbol: 14\r\n    readonly javascriptWithScope: 15\r\n    readonly int: 16\r\n    readonly timestamp: 17\r\n    readonly long: 18\r\n    readonly decimal: 19\r\n    readonly minKey: -1\r\n    readonly maxKey: 127\r\n}>\r\n\r\n/** @public */\r\nexport declare type BSONType = (typeof BSONType)[keyof typeof BSONType]\r\n\r\n/** @public */\r\nexport declare abstract class BSONValue {\r\n    /** @public */\r\n    abstract get _bsontype(): string\r\n    /** @public */\r\n    abstract inspect(): string\r\n    /* Excluded from this release type: toExtendedJSON */\r\n}\r\n\r\n/**\r\n * @public\r\n * @category Error\r\n */\r\nexport declare class BSONVersionError extends BSONError {\r\n    get name(): \"BSONVersionError\"\r\n    constructor()\r\n}\r\n\r\n/**\r\n * Calculate the bson size for a passed in Javascript object.\r\n *\r\n * @param object - the Javascript object to calculate the BSON byte size for\r\n * @returns size of BSON object in bytes\r\n * @public\r\n */\r\nexport declare function calculateObjectSize(\r\n    object: Document,\r\n    options?: CalculateObjectSizeOptions,\r\n): number\r\n\r\n/** @public */\r\nexport declare type CalculateObjectSizeOptions = Pick<\r\n    SerializeOptions,\r\n    \"serializeFunctions\" | \"ignoreUndefined\"\r\n>\r\n\r\n/**\r\n * A class representation of the BSON Code type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class Code extends BSONValue {\r\n    get _bsontype(): \"Code\"\r\n    code: string\r\n    scope: Document | null\r\n    /**\r\n     * @param code - a string or function.\r\n     * @param scope - an optional scope for the function.\r\n     */\r\n    constructor(code: string | Function, scope?: Document | null)\r\n    toJSON(): {\r\n        code: string\r\n        scope?: Document\r\n    }\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface CodeExtended {\r\n    $code: string\r\n    $scope?: Document\r\n}\r\n\r\n/**\r\n * A class representation of the BSON DBRef type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class DBRef extends BSONValue {\r\n    get _bsontype(): \"DBRef\"\r\n    collection: string\r\n    oid: ObjectId\r\n    db?: string\r\n    fields: Document\r\n    /**\r\n     * @param collection - the collection name.\r\n     * @param oid - the reference ObjectId.\r\n     * @param db - optional db name, if omitted the reference is local to the current db.\r\n     */\r\n    constructor(\r\n        collection: string,\r\n        oid: ObjectId,\r\n        db?: string,\r\n        fields?: Document,\r\n    )\r\n    /* Excluded from this release type: namespace */\r\n    /* Excluded from this release type: namespace */\r\n    toJSON(): DBRefLike & Document\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface DBRefLike {\r\n    $ref: string\r\n    $id: ObjectId\r\n    $db?: string\r\n}\r\n\r\n/**\r\n * A class representation of the BSON Decimal128 type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class Decimal128 extends BSONValue {\r\n    get _bsontype(): \"Decimal128\"\r\n    readonly bytes: Uint8Array\r\n    /**\r\n     * @param bytes - a buffer containing the raw Decimal128 bytes in little endian order,\r\n     *                or a string representation as returned by .toString()\r\n     */\r\n    constructor(bytes: Uint8Array | string)\r\n    /**\r\n     * Create a Decimal128 instance from a string representation\r\n     *\r\n     * @param representation - a numeric string representation.\r\n     */\r\n    static fromString(representation: string): Decimal128\r\n    /** Create a string representation of the raw Decimal128 value */\r\n    toString(): string\r\n    toJSON(): Decimal128Extended\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface Decimal128Extended {\r\n    $numberDecimal: string\r\n}\r\n\r\n/**\r\n * Deserialize data as BSON.\r\n *\r\n * @param buffer - the buffer containing the serialized set of BSON documents.\r\n * @returns returns the deserialized Javascript Object.\r\n * @public\r\n */\r\nexport declare function deserialize(\r\n    buffer: Uint8Array,\r\n    options?: DeserializeOptions,\r\n): Document\r\n\r\n/** @public */\r\nexport declare interface DeserializeOptions {\r\n    /** when deserializing a Long will return as a BigInt. */\r\n    useBigInt64?: boolean\r\n    /** when deserializing a Long will fit it into a Number if it's smaller than 53 bits. */\r\n    promoteLongs?: boolean\r\n    /** when deserializing a Binary will return it as a node.js Buffer instance. */\r\n    promoteBuffers?: boolean\r\n    /** when deserializing will promote BSON values to their Node.js closest equivalent types. */\r\n    promoteValues?: boolean\r\n    /** allow to specify if there what fields we wish to return as unserialized raw buffer. */\r\n    fieldsAsRaw?: Document\r\n    /** return BSON regular expressions as BSONRegExp instances. */\r\n    bsonRegExp?: boolean\r\n    /** allows the buffer to be larger than the parsed BSON object. */\r\n    allowObjectSmallerThanBufferSize?: boolean\r\n    /** Offset into buffer to begin reading document from */\r\n    index?: number\r\n    raw?: boolean\r\n    /** Allows for opt-out utf-8 validation for all keys or\r\n     * specified keys. Must be all true or all false.\r\n     *\r\n     * @example\r\n     * ```js\r\n     * // disables validation on all keys\r\n     *  validation: { utf8: false }\r\n     *\r\n     * // enables validation only on specified keys a, b, and c\r\n     *  validation: { utf8: { a: true, b: true, c: true } }\r\n     *\r\n     *  // disables validation only on specified keys a, b\r\n     *  validation: { utf8: { a: false, b: false } }\r\n     * ```\r\n     */\r\n    validation?: {\r\n        utf8: boolean | Record<string, true> | Record<string, false>\r\n    }\r\n}\r\n\r\n/**\r\n * Deserialize stream data as BSON documents.\r\n *\r\n * @param data - the buffer containing the serialized set of BSON documents.\r\n * @param startIndex - the start index in the data Buffer where the deserialization is to start.\r\n * @param numberOfDocuments - number of documents to deserialize.\r\n * @param documents - an array where to store the deserialized documents.\r\n * @param docStartIndex - the index in the documents array from where to start inserting documents.\r\n * @param options - additional options used for the deserialization.\r\n * @returns next index in the buffer after deserialization **x** numbers of documents.\r\n * @public\r\n */\r\nexport declare function deserializeStream(\r\n    data: Uint8Array | ArrayBuffer,\r\n    startIndex: number,\r\n    numberOfDocuments: number,\r\n    documents: Document[],\r\n    docStartIndex: number,\r\n    options: DeserializeOptions,\r\n): number\r\n\r\n/** @public */\r\nexport declare interface Document {\r\n    [key: string]: any\r\n}\r\n\r\n/**\r\n * A class representation of the BSON Double type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class Double extends BSONValue {\r\n    get _bsontype(): \"Double\"\r\n    value: number\r\n    /**\r\n     * Create a Double type\r\n     *\r\n     * @param value - the number we want to represent as a double.\r\n     */\r\n    constructor(value: number)\r\n    /**\r\n     * Access the number value.\r\n     *\r\n     * @returns returns the wrapped double number.\r\n     */\r\n    valueOf(): number\r\n    toJSON(): number\r\n    toString(radix?: number): string\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface DoubleExtended {\r\n    $numberDouble: string\r\n}\r\n\r\n/** @public */\r\nexport declare const EJSON: {\r\n    parse: typeof parse\r\n    stringify: typeof stringify\r\n    serialize: typeof EJSONserialize\r\n    deserialize: typeof EJSONdeserialize\r\n}\r\n\r\n/**\r\n * Deserializes an Extended JSON object into a plain JavaScript object with native/BSON types\r\n *\r\n * @param ejson - The Extended JSON object to deserialize\r\n * @param options - Optional settings passed to the parse method\r\n */\r\ndeclare function EJSONdeserialize(ejson: Document, options?: EJSONOptions): any\r\n\r\n/** @public */\r\nexport declare type EJSONOptions = {\r\n    /** Output using the Extended JSON v1 spec */\r\n    legacy?: boolean\r\n    /** Enable Extended JSON's `relaxed` mode, which attempts to return native JS types where possible, rather than BSON types */\r\n    relaxed?: boolean\r\n    /** Enable native bigint support */\r\n    useBigInt64?: boolean\r\n}\r\n\r\n/**\r\n * Serializes an object to an Extended JSON string, and reparse it as a JavaScript object.\r\n *\r\n * @param value - The object to serialize\r\n * @param options - Optional settings passed to the `stringify` function\r\n */\r\ndeclare function EJSONserialize(value: any, options?: EJSONOptions): Document\r\n\r\n/**\r\n * A class representation of a BSON Int32 type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class Int32 extends BSONValue {\r\n    get _bsontype(): \"Int32\"\r\n    value: number\r\n    /**\r\n     * Create an Int32 type\r\n     *\r\n     * @param value - the number we want to represent as an int32.\r\n     */\r\n    constructor(value: number | string)\r\n    /**\r\n     * Access the number value.\r\n     *\r\n     * @returns returns the wrapped int32 number.\r\n     */\r\n    valueOf(): number\r\n    toString(radix?: number): string\r\n    toJSON(): number\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface Int32Extended {\r\n    $numberInt: string\r\n}\r\n\r\ndeclare const kId: unique symbol\r\n\r\n/**\r\n * A class representing a 64-bit integer\r\n * @public\r\n * @category BSONType\r\n * @remarks\r\n * The internal representation of a long is the two given signed, 32-bit values.\r\n * We use 32-bit pieces because these are the size of integers on which\r\n * Javascript performs bit-operations.  For operations like addition and\r\n * multiplication, we split each number into 16 bit pieces, which can easily be\r\n * multiplied within Javascript's floating-point representation without overflow\r\n * or change in sign.\r\n * In the algorithms below, we frequently reduce the negative case to the\r\n * positive case by negating the input(s) and then post-processing the result.\r\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n * a positive number, it overflows back into a negative).  Not handling this\r\n * case would often result in infinite recursion.\r\n * Common constant values ZERO, ONE, NEG_ONE, etc. are found as static properties on this class.\r\n */\r\nexport declare class Long extends BSONValue {\r\n    get _bsontype(): \"Long\"\r\n    /** An indicator used to reliably determine if an object is a Long or not. */\r\n    get __isLong__(): boolean\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     */\r\n    high: number\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     */\r\n    low: number\r\n    /**\r\n     * Whether unsigned or not.\r\n     */\r\n    unsigned: boolean\r\n    /**\r\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n     *  See the from* functions below for more convenient ways of constructing Longs.\r\n     *\r\n     * Acceptable signatures are:\r\n     * - Long(low, high, unsigned?)\r\n     * - Long(bigint, unsigned?)\r\n     * - Long(string, unsigned?)\r\n     *\r\n     * @param low - The low (signed) 32 bits of the long\r\n     * @param high - The high (signed) 32 bits of the long\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     */\r\n    constructor(\r\n        low?: number | bigint | string,\r\n        high?: number | boolean,\r\n        unsigned?: boolean,\r\n    )\r\n    static TWO_PWR_24: Long\r\n    /** Maximum unsigned value. */\r\n    static MAX_UNSIGNED_VALUE: Long\r\n    /** Signed zero */\r\n    static ZERO: Long\r\n    /** Unsigned zero. */\r\n    static UZERO: Long\r\n    /** Signed one. */\r\n    static ONE: Long\r\n    /** Unsigned one. */\r\n    static UONE: Long\r\n    /** Signed negative one. */\r\n    static NEG_ONE: Long\r\n    /** Maximum signed value. */\r\n    static MAX_VALUE: Long\r\n    /** Minimum signed value. */\r\n    static MIN_VALUE: Long\r\n    /**\r\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits.\r\n     * Each is assumed to use 32 bits.\r\n     * @param lowBits - The low 32 bits\r\n     * @param highBits - The high 32 bits\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long\r\n    /**\r\n     * Returns a Long representing the given 32 bit integer value.\r\n     * @param value - The 32 bit integer in question\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromInt(value: number, unsigned?: boolean): Long\r\n    /**\r\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n     * @param value - The number in question\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromNumber(value: number, unsigned?: boolean): Long\r\n    /**\r\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n     * @param value - The number in question\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromBigInt(value: bigint, unsigned?: boolean): Long\r\n    /**\r\n     * Returns a Long representation of the given string, written using the specified radix.\r\n     * @param str - The textual representation of the Long\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @param radix - The radix in which the text is written (2-36), defaults to 10\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromString(str: string, unsigned?: boolean, radix?: number): Long\r\n    /**\r\n     * Creates a Long from its byte representation.\r\n     * @param bytes - Byte representation\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @param le - Whether little or big endian, defaults to big endian\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long\r\n    /**\r\n     * Creates a Long from its little endian byte representation.\r\n     * @param bytes - Little endian byte representation\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromBytesLE(bytes: number[], unsigned?: boolean): Long\r\n    /**\r\n     * Creates a Long from its big endian byte representation.\r\n     * @param bytes - Big endian byte representation\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     * @returns The corresponding Long value\r\n     */\r\n    static fromBytesBE(bytes: number[], unsigned?: boolean): Long\r\n    /**\r\n     * Tests if the specified object is a Long.\r\n     */\r\n    static isLong(value: unknown): value is Long\r\n    /**\r\n     * Converts the specified value to a Long.\r\n     * @param unsigned - Whether unsigned or not, defaults to signed\r\n     */\r\n    static fromValue(\r\n        val:\r\n            | number\r\n            | string\r\n            | {\r\n                  low: number\r\n                  high: number\r\n                  unsigned?: boolean\r\n              },\r\n        unsigned?: boolean,\r\n    ): Long\r\n    /** Returns the sum of this and the specified Long. */\r\n    add(addend: string | number | Long | Timestamp): Long\r\n    /**\r\n     * Returns the sum of this and the specified Long.\r\n     * @returns Sum\r\n     */\r\n    and(other: string | number | Long | Timestamp): Long\r\n    /**\r\n     * Compares this Long's value with the specified's.\r\n     * @returns 0 if they are the same, 1 if the this is greater and -1 if the given one is greater\r\n     */\r\n    compare(other: string | number | Long | Timestamp): 0 | 1 | -1\r\n    /** This is an alias of {@link Long.compare} */\r\n    comp(other: string | number | Long | Timestamp): 0 | 1 | -1\r\n    /**\r\n     * Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.\r\n     * @returns Quotient\r\n     */\r\n    divide(divisor: string | number | Long | Timestamp): Long\r\n    /**This is an alias of {@link Long.divide} */\r\n    div(divisor: string | number | Long | Timestamp): Long\r\n    /**\r\n     * Tests if this Long's value equals the specified's.\r\n     * @param other - Other value\r\n     */\r\n    equals(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.equals} */\r\n    eq(other: string | number | Long | Timestamp): boolean\r\n    /** Gets the high 32 bits as a signed integer. */\r\n    getHighBits(): number\r\n    /** Gets the high 32 bits as an unsigned integer. */\r\n    getHighBitsUnsigned(): number\r\n    /** Gets the low 32 bits as a signed integer. */\r\n    getLowBits(): number\r\n    /** Gets the low 32 bits as an unsigned integer. */\r\n    getLowBitsUnsigned(): number\r\n    /** Gets the number of bits needed to represent the absolute value of this Long. */\r\n    getNumBitsAbs(): number\r\n    /** Tests if this Long's value is greater than the specified's. */\r\n    greaterThan(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.greaterThan} */\r\n    gt(other: string | number | Long | Timestamp): boolean\r\n    /** Tests if this Long's value is greater than or equal the specified's. */\r\n    greaterThanOrEqual(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.greaterThanOrEqual} */\r\n    gte(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.greaterThanOrEqual} */\r\n    ge(other: string | number | Long | Timestamp): boolean\r\n    /** Tests if this Long's value is even. */\r\n    isEven(): boolean\r\n    /** Tests if this Long's value is negative. */\r\n    isNegative(): boolean\r\n    /** Tests if this Long's value is odd. */\r\n    isOdd(): boolean\r\n    /** Tests if this Long's value is positive. */\r\n    isPositive(): boolean\r\n    /** Tests if this Long's value equals zero. */\r\n    isZero(): boolean\r\n    /** Tests if this Long's value is less than the specified's. */\r\n    lessThan(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long#lessThan}. */\r\n    lt(other: string | number | Long | Timestamp): boolean\r\n    /** Tests if this Long's value is less than or equal the specified's. */\r\n    lessThanOrEqual(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.lessThanOrEqual} */\r\n    lte(other: string | number | Long | Timestamp): boolean\r\n    /** Returns this Long modulo the specified. */\r\n    modulo(divisor: string | number | Long | Timestamp): Long\r\n    /** This is an alias of {@link Long.modulo} */\r\n    mod(divisor: string | number | Long | Timestamp): Long\r\n    /** This is an alias of {@link Long.modulo} */\r\n    rem(divisor: string | number | Long | Timestamp): Long\r\n    /**\r\n     * Returns the product of this and the specified Long.\r\n     * @param multiplier - Multiplier\r\n     * @returns Product\r\n     */\r\n    multiply(multiplier: string | number | Long | Timestamp): Long\r\n    /** This is an alias of {@link Long.multiply} */\r\n    mul(multiplier: string | number | Long | Timestamp): Long\r\n    /** Returns the Negation of this Long's value. */\r\n    negate(): Long\r\n    /** This is an alias of {@link Long.negate} */\r\n    neg(): Long\r\n    /** Returns the bitwise NOT of this Long. */\r\n    not(): Long\r\n    /** Tests if this Long's value differs from the specified's. */\r\n    notEquals(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.notEquals} */\r\n    neq(other: string | number | Long | Timestamp): boolean\r\n    /** This is an alias of {@link Long.notEquals} */\r\n    ne(other: string | number | Long | Timestamp): boolean\r\n    /**\r\n     * Returns the bitwise OR of this Long and the specified.\r\n     */\r\n    or(other: number | string | Long): Long\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount.\r\n     * @param numBits - Number of bits\r\n     * @returns Shifted Long\r\n     */\r\n    shiftLeft(numBits: number | Long): Long\r\n    /** This is an alias of {@link Long.shiftLeft} */\r\n    shl(numBits: number | Long): Long\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n     * @param numBits - Number of bits\r\n     * @returns Shifted Long\r\n     */\r\n    shiftRight(numBits: number | Long): Long\r\n    /** This is an alias of {@link Long.shiftRight} */\r\n    shr(numBits: number | Long): Long\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount.\r\n     * @param numBits - Number of bits\r\n     * @returns Shifted Long\r\n     */\r\n    shiftRightUnsigned(numBits: Long | number): Long\r\n    /** This is an alias of {@link Long.shiftRightUnsigned} */\r\n    shr_u(numBits: number | Long): Long\r\n    /** This is an alias of {@link Long.shiftRightUnsigned} */\r\n    shru(numBits: number | Long): Long\r\n    /**\r\n     * Returns the difference of this and the specified Long.\r\n     * @param subtrahend - Subtrahend\r\n     * @returns Difference\r\n     */\r\n    subtract(subtrahend: string | number | Long | Timestamp): Long\r\n    /** This is an alias of {@link Long.subtract} */\r\n    sub(subtrahend: string | number | Long | Timestamp): Long\r\n    /** Converts the Long to a 32 bit integer, assuming it is a 32 bit integer. */\r\n    toInt(): number\r\n    /** Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa). */\r\n    toNumber(): number\r\n    /** Converts the Long to a BigInt (arbitrary precision). */\r\n    toBigInt(): bigint\r\n    /**\r\n     * Converts this Long to its byte representation.\r\n     * @param le - Whether little or big endian, defaults to big endian\r\n     * @returns Byte representation\r\n     */\r\n    toBytes(le?: boolean): number[]\r\n    /**\r\n     * Converts this Long to its little endian byte representation.\r\n     * @returns Little endian byte representation\r\n     */\r\n    toBytesLE(): number[]\r\n    /**\r\n     * Converts this Long to its big endian byte representation.\r\n     * @returns Big endian byte representation\r\n     */\r\n    toBytesBE(): number[]\r\n    /**\r\n     * Converts this Long to signed.\r\n     */\r\n    toSigned(): Long\r\n    /**\r\n     * Converts the Long to a string written in the specified radix.\r\n     * @param radix - Radix (2-36), defaults to 10\r\n     * @throws RangeError If `radix` is out of range\r\n     */\r\n    toString(radix?: number): string\r\n    /** Converts this Long to unsigned. */\r\n    toUnsigned(): Long\r\n    /** Returns the bitwise XOR of this Long and the given one. */\r\n    xor(other: Long | number | string): Long\r\n    /** This is an alias of {@link Long.isZero} */\r\n    eqz(): boolean\r\n    /** This is an alias of {@link Long.lessThanOrEqual} */\r\n    le(other: string | number | Long | Timestamp): boolean\r\n    toExtendedJSON(options?: EJSONOptions): number | LongExtended\r\n    static fromExtendedJSON(\r\n        doc: {\r\n            $numberLong: string\r\n        },\r\n        options?: EJSONOptions,\r\n    ): number | Long | bigint\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface LongExtended {\r\n    $numberLong: string\r\n}\r\n\r\n/** @public */\r\nexport declare type LongWithoutOverrides = new (\r\n    low: unknown,\r\n    high?: number | boolean,\r\n    unsigned?: boolean,\r\n) => {\r\n    [P in Exclude<keyof Long, TimestampOverrides>]: Long[P]\r\n}\r\n\r\n/** @public */\r\nexport declare const LongWithoutOverridesClass: LongWithoutOverrides\r\n\r\n/**\r\n * A class representation of the BSON MaxKey type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class MaxKey extends BSONValue {\r\n    get _bsontype(): \"MaxKey\"\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface MaxKeyExtended {\r\n    $maxKey: 1\r\n}\r\n\r\n/**\r\n * A class representation of the BSON MinKey type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class MinKey extends BSONValue {\r\n    get _bsontype(): \"MinKey\"\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface MinKeyExtended {\r\n    $minKey: 1\r\n}\r\n\r\n/**\r\n * A class representation of the BSON ObjectId type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport declare class ObjectId extends BSONValue {\r\n    get _bsontype(): \"ObjectId\"\r\n    /* Excluded from this release type: index */\r\n    static cacheHexString: boolean\r\n    /* Excluded from this release type: [kId] */\r\n    /* Excluded from this release type: __id */\r\n    /**\r\n     * Create an ObjectId type\r\n     *\r\n     * @param inputId - Can be a 24 character hex string, 12 byte binary Buffer, or a number.\r\n     */\r\n    constructor(\r\n        inputId?: string | number | ObjectId | ObjectIdLike | Uint8Array,\r\n    )\r\n    /**\r\n     * The ObjectId bytes\r\n     * @readonly\r\n     */\r\n    get id(): Uint8Array\r\n    set id(value: Uint8Array)\r\n    /** Returns the ObjectId id as a 24 character hex string representation */\r\n    toHexString(): string\r\n    /* Excluded from this release type: getInc */\r\n    /**\r\n     * Generate a 12 byte id buffer used in ObjectId's\r\n     *\r\n     * @param time - pass in a second based timestamp.\r\n     */\r\n    static generate(time?: number): Uint8Array\r\n    /**\r\n     * Converts the id into a 24 character hex string for printing, unless encoding is provided.\r\n     * @param encoding - hex or base64\r\n     */\r\n    toString(encoding?: \"hex\" | \"base64\"): string\r\n    /** Converts to its JSON the 24 character hex string representation. */\r\n    toJSON(): string\r\n    /**\r\n     * Compares the equality of this ObjectId with `otherID`.\r\n     *\r\n     * @param otherId - ObjectId instance to compare against.\r\n     */\r\n    equals(otherId: string | ObjectId | ObjectIdLike): boolean\r\n    /** Returns the generation date (accurate up to the second) that this ID was generated. */\r\n    getTimestamp(): Date\r\n    /* Excluded from this release type: createPk */\r\n    /**\r\n     * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\r\n     *\r\n     * @param time - an integer number representing a number of seconds.\r\n     */\r\n    static createFromTime(time: number): ObjectId\r\n    /**\r\n     * Creates an ObjectId from a hex string representation of an ObjectId.\r\n     *\r\n     * @param hexString - create a ObjectId from a passed in 24 character hexstring.\r\n     */\r\n    static createFromHexString(hexString: string): ObjectId\r\n    /** Creates an ObjectId instance from a base64 string */\r\n    static createFromBase64(base64: string): ObjectId\r\n    /**\r\n     * Checks if a value is a valid bson ObjectId\r\n     *\r\n     * @param id - ObjectId instance to validate.\r\n     */\r\n    static isValid(\r\n        id: string | number | ObjectId | ObjectIdLike | Uint8Array,\r\n    ): boolean\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface ObjectIdExtended {\r\n    $oid: string\r\n}\r\n\r\n/** @public */\r\nexport declare interface ObjectIdLike {\r\n    id: string | Uint8Array\r\n    __id?: string\r\n    toHexString(): string\r\n}\r\n\r\n/**\r\n * Parse an Extended JSON string, constructing the JavaScript value or object described by that\r\n * string.\r\n *\r\n * @example\r\n * ```js\r\n * const { EJSON } = require('bson');\r\n * const text = '{ \"int32\": { \"$numberInt\": \"10\" } }';\r\n *\r\n * // prints { int32: { [String: '10'] _bsontype: 'Int32', value: '10' } }\r\n * console.log(EJSON.parse(text, { relaxed: false }));\r\n *\r\n * // prints { int32: 10 }\r\n * console.log(EJSON.parse(text));\r\n * ```\r\n */\r\ndeclare function parse(text: string, options?: EJSONOptions): any\r\n\r\n/**\r\n * Serialize a Javascript object.\r\n *\r\n * @param object - the Javascript object to serialize.\r\n * @returns Buffer object containing the serialized object.\r\n * @public\r\n */\r\nexport declare function serialize(\r\n    object: Document,\r\n    options?: SerializeOptions,\r\n): Uint8Array\r\n\r\n/** @public */\r\nexport declare interface SerializeOptions {\r\n    /** the serializer will check if keys are valid. */\r\n    checkKeys?: boolean\r\n    /** serialize the javascript functions **(default:false)**. */\r\n    serializeFunctions?: boolean\r\n    /** serialize will not emit undefined fields **(default:true)** */\r\n    ignoreUndefined?: boolean\r\n    /* Excluded from this release type: minInternalBufferSize */\r\n    /** the index in the buffer where we wish to start serializing into */\r\n    index?: number\r\n}\r\n\r\n/**\r\n * Serialize a Javascript object using a predefined Buffer and index into the buffer,\r\n * useful when pre-allocating the space for serialization.\r\n *\r\n * @param object - the Javascript object to serialize.\r\n * @param finalBuffer - the Buffer you pre-allocated to store the serialized BSON object.\r\n * @returns the index pointing to the last written byte in the buffer.\r\n * @public\r\n */\r\nexport declare function serializeWithBufferAndIndex(\r\n    object: Document,\r\n    finalBuffer: Uint8Array,\r\n    options?: SerializeOptions,\r\n): number\r\n\r\n/**\r\n * Sets the size of the internal serialization buffer.\r\n *\r\n * @param size - The desired size for the internal serialization buffer\r\n * @public\r\n */\r\nexport declare function setInternalBufferSize(size: number): void\r\n\r\n/**\r\n * Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer\r\n * function is specified or optionally including only the specified properties if a replacer array\r\n * is specified.\r\n *\r\n * @param value - The value to convert to extended JSON\r\n * @param replacer - A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string\r\n * @param space - A String or Number object that's used to insert white space into the output JSON string for readability purposes.\r\n * @param options - Optional settings\r\n *\r\n * @example\r\n * ```js\r\n * const { EJSON } = require('bson');\r\n * const Int32 = require('mongodb').Int32;\r\n * const doc = { int32: new Int32(10) };\r\n *\r\n * // prints '{\"int32\":{\"$numberInt\":\"10\"}}'\r\n * console.log(EJSON.stringify(doc, { relaxed: false }));\r\n *\r\n * // prints '{\"int32\":10}'\r\n * console.log(EJSON.stringify(doc));\r\n * ```\r\n */\r\ndeclare function stringify(\r\n    value: any,\r\n    replacer?:\r\n        | (number | string)[]\r\n        | ((this: any, key: string, value: any) => any)\r\n        | EJSONOptions,\r\n    space?: string | number,\r\n    options?: EJSONOptions,\r\n): string\r\n\r\n/**\r\n * @public\r\n * @category BSONType\r\n * */\r\nexport declare class Timestamp extends LongWithoutOverridesClass {\r\n    get _bsontype(): \"Timestamp\"\r\n    static readonly MAX_VALUE: Long\r\n    /**\r\n     * @param int - A 64-bit bigint representing the Timestamp.\r\n     */\r\n    constructor(int: bigint)\r\n    /**\r\n     * @param long - A 64-bit Long representing the Timestamp.\r\n     */\r\n    constructor(long: Long)\r\n    /**\r\n     * @param value - A pair of two values indicating timestamp and increment.\r\n     */\r\n    constructor(value: { t: number; i: number })\r\n    toJSON(): {\r\n        $timestamp: string\r\n    }\r\n    /** Returns a Timestamp represented by the given (32-bit) integer value. */\r\n    static fromInt(value: number): Timestamp\r\n    /** Returns a Timestamp representing the given number value, provided that it is a finite number. Otherwise, zero is returned. */\r\n    static fromNumber(value: number): Timestamp\r\n    /**\r\n     * Returns a Timestamp for the given high and low bits. Each is assumed to use 32 bits.\r\n     *\r\n     * @param lowBits - the low 32-bits.\r\n     * @param highBits - the high 32-bits.\r\n     */\r\n    static fromBits(lowBits: number, highBits: number): Timestamp\r\n    /**\r\n     * Returns a Timestamp from the given string, optionally using the given radix.\r\n     *\r\n     * @param str - the textual representation of the Timestamp.\r\n     * @param optRadix - the radix in which the text is written.\r\n     */\r\n    static fromString(str: string, optRadix: number): Timestamp\r\n    /* Excluded from this release type: toExtendedJSON */\r\n    /* Excluded from this release type: fromExtendedJSON */\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare interface TimestampExtended {\r\n    $timestamp: {\r\n        t: number\r\n        i: number\r\n    }\r\n}\r\n\r\n/** @public */\r\nexport declare type TimestampOverrides =\r\n    | \"_bsontype\"\r\n    | \"toExtendedJSON\"\r\n    | \"fromExtendedJSON\"\r\n    | \"inspect\"\r\n\r\n/**\r\n * A class representation of the BSON UUID type.\r\n * @public\r\n */\r\nexport declare class UUID extends Binary {\r\n    static cacheHexString: boolean\r\n    /* Excluded from this release type: __id */\r\n    /**\r\n     * Create an UUID type\r\n     *\r\n     * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.\r\n     */\r\n    constructor(input?: string | Uint8Array | UUID)\r\n    /**\r\n     * The UUID bytes\r\n     * @readonly\r\n     */\r\n    get id(): Uint8Array\r\n    set id(value: Uint8Array)\r\n    /**\r\n     * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)\r\n     * @param includeDashes - should the string exclude dash-separators.\r\n     * */\r\n    toHexString(includeDashes?: boolean): string\r\n    /**\r\n     * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.\r\n     */\r\n    toString(encoding?: \"hex\" | \"base64\"): string\r\n    /**\r\n     * Converts the id into its JSON string representation.\r\n     * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\r\n     */\r\n    toJSON(): string\r\n    /**\r\n     * Compares the equality of this UUID with `otherID`.\r\n     *\r\n     * @param otherId - UUID instance to compare against.\r\n     */\r\n    equals(otherId: string | Uint8Array | UUID): boolean\r\n    /**\r\n     * Creates a Binary instance from the current UUID.\r\n     */\r\n    toBinary(): Binary\r\n    /**\r\n     * Generates a populated buffer containing a v4 uuid\r\n     */\r\n    static generate(): Uint8Array\r\n    /**\r\n     * Checks if a value is a valid bson UUID\r\n     * @param input - UUID, string or Buffer to validate.\r\n     */\r\n    static isValid(input: string | Uint8Array | UUID): boolean\r\n    /**\r\n     * Creates an UUID from a hex string representation of an UUID.\r\n     * @param hexString - 32 or 36 character hex string (dashes excluded/included).\r\n     */\r\n    static createFromHexString(hexString: string): UUID\r\n    /** Creates an UUID from a base64 string representation of an UUID. */\r\n    static createFromBase64(base64: string): UUID\r\n    inspect(): string\r\n}\r\n\r\n/** @public */\r\nexport declare type UUIDExtended = {\r\n    $uuid: string\r\n}\r\n\r\nexport {}\r\n"],"sourceRoot":"../.."}