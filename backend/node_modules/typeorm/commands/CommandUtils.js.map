{"version":3,"sources":["../../src/commands/CommandUtils.ts"],"names":[],"mappings":"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","file":"CommandUtils.js","sourcesContent":["import fs from \"fs/promises\"\r\nimport path from \"path\"\r\nimport { TypeORMError } from \"../error\"\r\nimport { DataSource } from \"../data-source\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { importOrRequireFile } from \"../util/ImportUtils\"\r\n\r\n/**\r\n * Command line utils functions.\r\n */\r\nexport class CommandUtils {\r\n    static async loadDataSource(\r\n        dataSourceFilePath: string,\r\n    ): Promise<DataSource> {\r\n        let dataSourceFileExports\r\n        try {\r\n            [dataSourceFileExports] = await importOrRequireFile(\r\n                dataSourceFilePath,\r\n            )\r\n        } catch (err) {\r\n            throw new Error(\r\n                `Unable to open file: \"${dataSourceFilePath}\". ${err.message}`,\r\n            )\r\n        }\r\n\r\n        if (\r\n            !dataSourceFileExports ||\r\n            typeof dataSourceFileExports !== \"object\"\r\n        ) {\r\n            throw new Error(\r\n                `Given data source file must contain export of a DataSource instance`,\r\n            )\r\n        }\r\n\r\n        if (InstanceChecker.isDataSource(dataSourceFileExports)) {\r\n            return dataSourceFileExports\r\n        }\r\n\r\n        const dataSourceExports = []\r\n        for (const fileExportKey in dataSourceFileExports) {\r\n            const fileExport = dataSourceFileExports[fileExportKey]\r\n            // It is necessary to await here in case of the exported async value (Promise<DataSource>).\r\n            // e.g. the DataSource is instantiated with an async factory in the source file\r\n            // It is safe to await regardless of the export being async or not due to `awaits` definition:\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#return_value\r\n            const awaitedFileExport = await fileExport\r\n            if (InstanceChecker.isDataSource(awaitedFileExport)) {\r\n                dataSourceExports.push(awaitedFileExport)\r\n            }\r\n        }\r\n\r\n        if (dataSourceExports.length === 0) {\r\n            throw new Error(\r\n                `Given data source file must contain export of a DataSource instance`,\r\n            )\r\n        }\r\n        if (dataSourceExports.length > 1) {\r\n            throw new Error(\r\n                `Given data source file must contain only one export of DataSource instance`,\r\n            )\r\n        }\r\n        return dataSourceExports[0]\r\n    }\r\n\r\n    /**\r\n     * Creates directories recursively.\r\n     */\r\n    static async createDirectories(directory: string): Promise<void> {\r\n        await fs.mkdir(directory, { recursive: true })\r\n    }\r\n\r\n    /**\r\n     * Creates a file with the given content in the given path.\r\n     */\r\n    static async createFile(\r\n        filePath: string,\r\n        content: string,\r\n        override: boolean = true,\r\n    ): Promise<void> {\r\n        await CommandUtils.createDirectories(path.dirname(filePath))\r\n        if (override === false && (await CommandUtils.fileExists(filePath))) {\r\n            return\r\n        }\r\n        await fs.writeFile(filePath, content)\r\n    }\r\n\r\n    /**\r\n     * Reads everything from a given file and returns its content as a string.\r\n     */\r\n    static async readFile(filePath: string): Promise<string> {\r\n        const file = await fs.readFile(filePath)\r\n\r\n        return file.toString()\r\n    }\r\n\r\n    static async fileExists(filePath: string) {\r\n        try {\r\n            await fs.access(filePath, fs.constants.F_OK)\r\n            return true\r\n        } catch {\r\n            return false\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets migration timestamp and validates argument (if sent)\r\n     */\r\n    static getTimestamp(timestampOptionArgument: any): number {\r\n        if (\r\n            timestampOptionArgument &&\r\n            (isNaN(timestampOptionArgument) || timestampOptionArgument < 0)\r\n        ) {\r\n            throw new TypeORMError(\r\n                `timestamp option should be a non-negative number. received: ${timestampOptionArgument}`,\r\n            )\r\n        }\r\n        return timestampOptionArgument\r\n            ? new Date(Number(timestampOptionArgument)).getTime()\r\n            : Date.now()\r\n    }\r\n}\r\n"],"sourceRoot":".."}