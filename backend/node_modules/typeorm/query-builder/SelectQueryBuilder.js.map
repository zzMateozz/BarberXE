{"version":3,"sources":["../../src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","file":"SelectQueryBuilder.js","sourcesContent":["import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\"\r\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\"\r\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\"\r\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\"\r\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\"\r\nimport { JoinAttribute } from \"./JoinAttribute\"\r\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\r\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\r\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\"\r\nimport { RelationIdLoader as QueryStrategyRelationIdLoader } from \"./RelationIdLoader\"\r\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\"\r\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\"\r\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\"\r\nimport { QueryBuilder } from \"./QueryBuilder\"\r\nimport { ReadStream } from \"../platform/PlatformTools\"\r\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\"\r\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\r\nimport { SelectQuery } from \"./SelectQuery\"\r\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\r\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\r\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\r\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\r\nimport { EntityTarget } from \"../common/EntityTarget\"\r\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\r\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\r\nimport { Brackets } from \"./Brackets\"\r\nimport { QueryResultCacheOptions } from \"../cache/QueryResultCacheOptions\"\r\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\"\r\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\r\nimport { ObjectUtils } from \"../util/ObjectUtils\"\r\nimport { DriverUtils } from \"../driver/DriverUtils\"\r\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\"\r\nimport { TypeORMError } from \"../error\"\r\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\r\nimport { FindOptionsSelect } from \"../find-options/FindOptionsSelect\"\r\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\r\nimport { FindOptionsOrder } from \"../find-options/FindOptionsOrder\"\r\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\r\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\r\nimport { FindOptionsRelations } from \"../find-options/FindOptionsRelations\"\r\nimport { OrmUtils } from \"../util/OrmUtils\"\r\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\r\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { FindOperator } from \"../find-options/FindOperator\"\r\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\r\n\r\n/**\r\n * Allows to build complex sql queries in a fashion way and execute those queries.\r\n */\r\nexport class SelectQueryBuilder<Entity extends ObjectLiteral>\r\n    extends QueryBuilder<Entity>\r\n    implements WhereExpressionBuilder\r\n{\r\n    readonly \"@instanceof\" = Symbol.for(\"SelectQueryBuilder\")\r\n\r\n    protected findOptions: FindManyOptions = {}\r\n    protected selects: string[] = []\r\n    protected joins: {\r\n        type: \"inner\" | \"left\"\r\n        alias: string\r\n        parentAlias: string\r\n        relationMetadata: RelationMetadata\r\n        select: boolean\r\n        selection: FindOptionsSelect<any> | undefined\r\n    }[] = []\r\n    protected conditions: string = \"\"\r\n    protected orderBys: {\r\n        alias: string\r\n        direction: \"ASC\" | \"DESC\"\r\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\r\n    }[] = []\r\n    protected relationMetadatas: RelationMetadata[] = []\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Implemented Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets generated SQL query without parameters being replaced.\r\n     */\r\n    getQuery(): string {\r\n        let sql = this.createComment()\r\n        sql += this.createCteExpression()\r\n        sql += this.createSelectExpression()\r\n        sql += this.createJoinExpression()\r\n        sql += this.createWhereExpression()\r\n        sql += this.createGroupByExpression()\r\n        sql += this.createHavingExpression()\r\n        sql += this.createOrderByExpression()\r\n        sql += this.createLimitOffsetExpression()\r\n        sql += this.createLockExpression()\r\n        sql = sql.trim()\r\n        if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\"\r\n        return this.replacePropertyNamesForTheWholeQuery(sql)\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    setFindOptions(findOptions: FindManyOptions<Entity>) {\r\n        this.findOptions = findOptions\r\n        this.applyFindOptions()\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Creates a subquery - query that can be used inside other queries.\r\n     */\r\n    subQuery(): SelectQueryBuilder<any> {\r\n        const qb = this.createQueryBuilder()\r\n        qb.expressionMap.subQuery = true\r\n        qb.parentQueryBuilder = this\r\n        return qb\r\n    }\r\n\r\n    /**\r\n     * Creates SELECT query.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(): this\r\n\r\n    /**\r\n     * Creates SELECT query.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(\r\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\r\n        selectionAliasName?: string,\r\n    ): this\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string, selectionAliasName?: string): this\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string[]): this\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(\r\n        selection?:\r\n            | string\r\n            | string[]\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        selectionAliasName?: string,\r\n    ): SelectQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"select\"\r\n        if (Array.isArray(selection)) {\r\n            this.expressionMap.selects = selection.map((selection) => ({\r\n                selection: selection,\r\n            }))\r\n        } else if (typeof selection === \"function\") {\r\n            const subQueryBuilder = selection(this.subQuery())\r\n            this.setParameters(subQueryBuilder.getParameters())\r\n            this.expressionMap.selects.push({\r\n                selection: subQueryBuilder.getQuery(),\r\n                aliasName: selectionAliasName,\r\n            })\r\n        } else if (selection) {\r\n            this.expressionMap.selects = [\r\n                { selection: selection, aliasName: selectionAliasName },\r\n            ]\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(\r\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\r\n        selectionAliasName?: string,\r\n    ): this\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(selection: string, selectionAliasName?: string): this\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(selection: string[]): this\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(\r\n        selection:\r\n            | string\r\n            | string[]\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        selectionAliasName?: string,\r\n    ): this {\r\n        if (!selection) return this\r\n\r\n        if (Array.isArray(selection)) {\r\n            this.expressionMap.selects = this.expressionMap.selects.concat(\r\n                selection.map((selection) => ({ selection: selection })),\r\n            )\r\n        } else if (typeof selection === \"function\") {\r\n            const subQueryBuilder = selection(this.subQuery())\r\n            this.setParameters(subQueryBuilder.getParameters())\r\n            this.expressionMap.selects.push({\r\n                selection: subQueryBuilder.getQuery(),\r\n                aliasName: selectionAliasName,\r\n            })\r\n        } else if (selection) {\r\n            this.expressionMap.selects.push({\r\n                selection: selection,\r\n                aliasName: selectionAliasName,\r\n            })\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Set max execution time.\r\n     * @param milliseconds\r\n     */\r\n    maxExecutionTime(milliseconds: number): this {\r\n        this.expressionMap.maxExecutionTime = milliseconds\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets whether the selection is DISTINCT.\r\n     */\r\n    distinct(distinct: boolean = true): this {\r\n        this.expressionMap.selectDistinct = distinct\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the distinct on clause for Postgres.\r\n     */\r\n    distinctOn(distinctOn: string[]): this {\r\n        this.expressionMap.selectDistinctOn = distinctOn\r\n        return this\r\n    }\r\n\r\n    fromDummy(): SelectQueryBuilder<any> {\r\n        return this.from(\r\n            this.connection.driver.dummyTableName ??\r\n                \"(SELECT 1 AS dummy_column)\",\r\n            \"dummy_table\",\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     * Removes all previously set from-s.\r\n     */\r\n    from<T extends ObjectLiteral>(\r\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\r\n        aliasName: string,\r\n    ): SelectQueryBuilder<T>\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     * Removes all previously set from-s.\r\n     */\r\n    from<T extends ObjectLiteral>(\r\n        entityTarget: EntityTarget<T>,\r\n        aliasName: string,\r\n    ): SelectQueryBuilder<T>\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     * Removes all previously set from-s.\r\n     */\r\n    from<T extends ObjectLiteral>(\r\n        entityTarget:\r\n            | EntityTarget<T>\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        aliasName: string,\r\n    ): SelectQueryBuilder<T> {\r\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\r\n        this.expressionMap.setMainAlias(mainAlias)\r\n        return this as any as SelectQueryBuilder<T>\r\n    }\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    addFrom<T extends ObjectLiteral>(\r\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\r\n        aliasName: string,\r\n    ): SelectQueryBuilder<T>\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    addFrom<T extends ObjectLiteral>(\r\n        entityTarget: EntityTarget<T>,\r\n        aliasName: string,\r\n    ): SelectQueryBuilder<T>\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    addFrom<T extends ObjectLiteral>(\r\n        entityTarget:\r\n            | EntityTarget<T>\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        aliasName: string,\r\n    ): SelectQueryBuilder<T> {\r\n        const alias = this.createFromAlias(entityTarget, aliasName)\r\n        if (!this.expressionMap.mainAlias)\r\n            this.expressionMap.setMainAlias(alias)\r\n\r\n        return this as any as SelectQueryBuilder<T>\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs (without selection) given subquery.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs (without selection) entity's property.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs (without selection) given entity's table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs (without selection) given table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs (without selection).\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) given subquery.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) entity's property.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) entity's table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) given table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs (without selection).\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs entity and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs table and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.addSelect(alias)\r\n        this.innerJoin(entityOrProperty, alias, condition, parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs entity and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs table and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.addSelect(alias)\r\n        this.leftJoin(entityOrProperty, alias, condition, parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(\r\n        mapToProperty: string,\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(\r\n        mapToProperty: string,\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(\r\n        mapToProperty: string,\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(\r\n        mapToProperty: string,\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(\r\n        mapToProperty: string,\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.addSelect(alias)\r\n        this.join(\r\n            \"INNER\",\r\n            entityOrProperty,\r\n            alias,\r\n            condition,\r\n            parameters,\r\n            mapToProperty,\r\n            true,\r\n        )\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(\r\n        mapToProperty: string,\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n        mapAsEntity?: Function | string,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(\r\n        mapToProperty: string,\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(\r\n        mapToProperty: string,\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(\r\n        mapToProperty: string,\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(\r\n        mapToProperty: string,\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n        mapAsEntity?: Function | string,\r\n    ): this {\r\n        this.addSelect(alias)\r\n        this.join(\r\n            \"INNER\",\r\n            entityOrProperty,\r\n            alias,\r\n            condition,\r\n            parameters,\r\n            mapToProperty,\r\n            false,\r\n            mapAsEntity,\r\n        )\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(\r\n        mapToProperty: string,\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(\r\n        mapToProperty: string,\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(\r\n        mapToProperty: string,\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(\r\n        mapToProperty: string,\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(\r\n        mapToProperty: string,\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.addSelect(alias)\r\n        this.join(\r\n            \"LEFT\",\r\n            entityOrProperty,\r\n            alias,\r\n            condition,\r\n            parameters,\r\n            mapToProperty,\r\n            true,\r\n        )\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(\r\n        mapToProperty: string,\r\n        subQueryFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n        mapAsEntity?: Function | string,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(\r\n        mapToProperty: string,\r\n        property: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(\r\n        mapToProperty: string,\r\n        entity: Function | string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(\r\n        mapToProperty: string,\r\n        tableName: string,\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(\r\n        mapToProperty: string,\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        alias: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n        mapAsEntity?: Function | string,\r\n    ): this {\r\n        this.addSelect(alias)\r\n        this.join(\r\n            \"LEFT\",\r\n            entityOrProperty,\r\n            alias,\r\n            condition,\r\n            parameters,\r\n            mapToProperty,\r\n            false,\r\n            mapAsEntity,\r\n        )\r\n        return this\r\n    }\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\r\n    //     const select = new SelectAttribute(this.expressionMap);\r\n    //     select.mapToProperty = mapToProperty;\r\n    //     select.entityOrProperty = entityOrProperty;\r\n    //     select.aliasName = aliasName;\r\n    //     select.qbFactory = qbFactory;\r\n    //     return this;\r\n    // }\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(\r\n        mapToProperty: string,\r\n        relationName: string,\r\n        options?: { disableMixedMap?: boolean },\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(\r\n        mapToProperty: string,\r\n        relationName: string,\r\n        alias: string,\r\n        queryBuilderFactory: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n    ): this\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(\r\n        mapToProperty: string,\r\n        relationName: string,\r\n        aliasNameOrOptions?: string | { disableMixedMap?: boolean },\r\n        queryBuilderFactory?: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n    ): this {\r\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap)\r\n        relationIdAttribute.mapToProperty = mapToProperty\r\n        relationIdAttribute.relationName = relationName\r\n        if (typeof aliasNameOrOptions === \"string\")\r\n            relationIdAttribute.alias = aliasNameOrOptions\r\n        if (\r\n            typeof aliasNameOrOptions === \"object\" &&\r\n            (aliasNameOrOptions as any).disableMixedMap\r\n        )\r\n            relationIdAttribute.disableMixedMap = true\r\n\r\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory\r\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute)\r\n\r\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\r\n            this.expressionMap.createAlias({\r\n                type: \"other\",\r\n                name: relationIdAttribute.junctionAlias,\r\n                metadata: relationIdAttribute.relation.junctionEntityMetadata,\r\n            })\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationCountAndMap(\r\n        mapToProperty: string,\r\n        relationName: string,\r\n        aliasName?: string,\r\n        queryBuilderFactory?: (\r\n            qb: SelectQueryBuilder<any>,\r\n        ) => SelectQueryBuilder<any>,\r\n    ): this {\r\n        const relationCountAttribute = new RelationCountAttribute(\r\n            this.expressionMap,\r\n        )\r\n        relationCountAttribute.mapToProperty = mapToProperty\r\n        relationCountAttribute.relationName = relationName\r\n        relationCountAttribute.alias = aliasName\r\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory\r\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute)\r\n\r\n        this.expressionMap.createAlias({\r\n            type: \"other\",\r\n            name: relationCountAttribute.junctionAlias,\r\n        })\r\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\r\n            this.expressionMap.createAlias({\r\n                type: \"other\",\r\n                name: relationCountAttribute.junctionAlias,\r\n                metadata:\r\n                    relationCountAttribute.relation.junctionEntityMetadata,\r\n            })\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Loads all relation ids for all relations of the selected entity.\r\n     * All relation ids will be mapped to relation property themself.\r\n     * If array of strings is given then loads only relation ids of the given properties.\r\n     */\r\n    loadAllRelationIds(options?: {\r\n        relations?: string[]\r\n        disableMixedMap?: boolean\r\n    }): this {\r\n        // todo: add skip relations\r\n        this.expressionMap.mainAlias!.metadata.relations.forEach((relation) => {\r\n            if (\r\n                options !== undefined &&\r\n                options.relations !== undefined &&\r\n                options.relations.indexOf(relation.propertyPath) === -1\r\n            )\r\n                return\r\n\r\n            this.loadRelationIdAndMap(\r\n                this.expressionMap.mainAlias!.name +\r\n                    \".\" +\r\n                    relation.propertyPath,\r\n                this.expressionMap.mainAlias!.name +\r\n                    \".\" +\r\n                    relation.propertyPath,\r\n                options,\r\n            )\r\n        })\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets WHERE condition in the query builder.\r\n     * If you had previously WHERE expression defined,\r\n     * calling this function will override previously set WHERE conditions.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    where(\r\n        where:\r\n            | Brackets\r\n            | string\r\n            | ((qb: this) => string)\r\n            | ObjectLiteral\r\n            | ObjectLiteral[],\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\r\n        const condition = this.getWhereCondition(where)\r\n        if (condition) {\r\n            this.expressionMap.wheres = [\r\n                { type: \"simple\", condition: condition },\r\n            ]\r\n        }\r\n        if (parameters) this.setParameters(parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds new AND WHERE condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    andWhere(\r\n        where:\r\n            | string\r\n            | Brackets\r\n            | ((qb: this) => string)\r\n            | ObjectLiteral\r\n            | ObjectLiteral[],\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.expressionMap.wheres.push({\r\n            type: \"and\",\r\n            condition: this.getWhereCondition(where),\r\n        })\r\n        if (parameters) this.setParameters(parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds new OR WHERE condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    orWhere(\r\n        where:\r\n            | Brackets\r\n            | string\r\n            | ((qb: this) => string)\r\n            | ObjectLiteral\r\n            | ObjectLiteral[],\r\n        parameters?: ObjectLiteral,\r\n    ): this {\r\n        this.expressionMap.wheres.push({\r\n            type: \"or\",\r\n            condition: this.getWhereCondition(where),\r\n        })\r\n        if (parameters) this.setParameters(parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets a new where EXISTS clause\r\n     */\r\n    whereExists(subQuery: SelectQueryBuilder<any>): this {\r\n        return this.where(...this.getExistsCondition(subQuery))\r\n    }\r\n\r\n    /**\r\n     * Adds a new AND where EXISTS clause\r\n     */\r\n    andWhereExists(subQuery: SelectQueryBuilder<any>): this {\r\n        return this.andWhere(...this.getExistsCondition(subQuery))\r\n    }\r\n\r\n    /**\r\n     * Adds a new OR where EXISTS clause\r\n     */\r\n    orWhereExists(subQuery: SelectQueryBuilder<any>): this {\r\n        return this.orWhere(...this.getExistsCondition(subQuery))\r\n    }\r\n\r\n    /**\r\n     * Adds new AND WHERE with conditions for the given ids.\r\n     *\r\n     * Ids are mixed.\r\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\r\n     * If you have multiple primary keys you need to pass object with property names and values specified,\r\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\r\n     */\r\n    whereInIds(ids: any | any[]): this {\r\n        return this.where(this.getWhereInIdsCondition(ids))\r\n    }\r\n\r\n    /**\r\n     * Adds new AND WHERE with conditions for the given ids.\r\n     *\r\n     * Ids are mixed.\r\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\r\n     * If you have multiple primary keys you need to pass object with property names and values specified,\r\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\r\n     */\r\n    andWhereInIds(ids: any | any[]): this {\r\n        return this.andWhere(this.getWhereInIdsCondition(ids))\r\n    }\r\n\r\n    /**\r\n     * Adds new OR WHERE with conditions for the given ids.\r\n     *\r\n     * Ids are mixed.\r\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\r\n     * If you have multiple primary keys you need to pass object with property names and values specified,\r\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\r\n     */\r\n    orWhereInIds(ids: any | any[]): this {\r\n        return this.orWhere(this.getWhereInIdsCondition(ids))\r\n    }\r\n\r\n    /**\r\n     * Sets HAVING condition in the query builder.\r\n     * If you had previously HAVING expression defined,\r\n     * calling this function will override previously set HAVING conditions.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    having(having: string, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.havings.push({ type: \"simple\", condition: having })\r\n        if (parameters) this.setParameters(parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds new AND HAVING condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    andHaving(having: string, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.havings.push({ type: \"and\", condition: having })\r\n        if (parameters) this.setParameters(parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds new OR HAVING condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    orHaving(having: string, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.havings.push({ type: \"or\", condition: having })\r\n        if (parameters) this.setParameters(parameters)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets GROUP BY condition in the query builder.\r\n     * If you had previously GROUP BY expression defined,\r\n     * calling this function will override previously set GROUP BY conditions.\r\n     */\r\n    groupBy(): this\r\n\r\n    /**\r\n     * Sets GROUP BY condition in the query builder.\r\n     * If you had previously GROUP BY expression defined,\r\n     * calling this function will override previously set GROUP BY conditions.\r\n     */\r\n    groupBy(groupBy: string): this\r\n\r\n    /**\r\n     * Sets GROUP BY condition in the query builder.\r\n     * If you had previously GROUP BY expression defined,\r\n     * calling this function will override previously set GROUP BY conditions.\r\n     */\r\n    groupBy(groupBy?: string): this {\r\n        if (groupBy) {\r\n            this.expressionMap.groupBys = [groupBy]\r\n        } else {\r\n            this.expressionMap.groupBys = []\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds GROUP BY condition in the query builder.\r\n     */\r\n    addGroupBy(groupBy: string): this {\r\n        this.expressionMap.groupBys.push(groupBy)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Enables time travelling for the current query (only supported by cockroach currently)\r\n     */\r\n    timeTravelQuery(timeTravelFn?: string | boolean): this {\r\n        if (this.connection.driver.options.type === \"cockroachdb\") {\r\n            if (timeTravelFn === undefined) {\r\n                this.expressionMap.timeTravel = \"follower_read_timestamp()\"\r\n            } else {\r\n                this.expressionMap.timeTravel = timeTravelFn\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     *\r\n     * Calling order by without order set will remove all previously set order bys.\r\n     */\r\n    orderBy(): this\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     */\r\n    orderBy(\r\n        sort: string,\r\n        order?: \"ASC\" | \"DESC\",\r\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\r\n    ): this\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     */\r\n    orderBy(order: OrderByCondition): this\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     */\r\n    orderBy(\r\n        sort?: string | OrderByCondition,\r\n        order: \"ASC\" | \"DESC\" = \"ASC\",\r\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\r\n    ): this {\r\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\r\n            throw new TypeORMError(\r\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\r\n            )\r\n        if (\r\n            nulls !== undefined &&\r\n            nulls !== \"NULLS FIRST\" &&\r\n            nulls !== \"NULLS LAST\"\r\n        )\r\n            throw new TypeORMError(\r\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\r\n            )\r\n\r\n        if (sort) {\r\n            if (typeof sort === \"object\") {\r\n                this.expressionMap.orderBys = sort as OrderByCondition\r\n            } else {\r\n                if (nulls) {\r\n                    this.expressionMap.orderBys = {\r\n                        [sort as string]: { order, nulls },\r\n                    }\r\n                } else {\r\n                    this.expressionMap.orderBys = { [sort as string]: order }\r\n                }\r\n            }\r\n        } else {\r\n            this.expressionMap.orderBys = {}\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds ORDER BY condition in the query builder.\r\n     */\r\n    addOrderBy(\r\n        sort: string,\r\n        order: \"ASC\" | \"DESC\" = \"ASC\",\r\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\r\n    ): this {\r\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\r\n            throw new TypeORMError(\r\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\r\n            )\r\n        if (\r\n            nulls !== undefined &&\r\n            nulls !== \"NULLS FIRST\" &&\r\n            nulls !== \"NULLS LAST\"\r\n        )\r\n            throw new TypeORMError(\r\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\r\n            )\r\n\r\n        if (nulls) {\r\n            this.expressionMap.orderBys[sort] = { order, nulls }\r\n        } else {\r\n            this.expressionMap.orderBys[sort] = order\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets LIMIT - maximum number of rows to be selected.\r\n     * NOTE that it may not work as you expect if you are using joins.\r\n     * If you want to implement pagination, and you are having join in your query,\r\n     * then use the take method instead.\r\n     */\r\n    limit(limit?: number): this {\r\n        this.expressionMap.limit = this.normalizeNumber(limit)\r\n        if (\r\n            this.expressionMap.limit !== undefined &&\r\n            isNaN(this.expressionMap.limit)\r\n        )\r\n            throw new TypeORMError(\r\n                `Provided \"limit\" value is not a number. Please provide a numeric value.`,\r\n            )\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets OFFSET - selection offset.\r\n     * NOTE that it may not work as you expect if you are using joins.\r\n     * If you want to implement pagination, and you are having join in your query,\r\n     * then use the skip method instead.\r\n     */\r\n    offset(offset?: number): this {\r\n        this.expressionMap.offset = this.normalizeNumber(offset)\r\n        if (\r\n            this.expressionMap.offset !== undefined &&\r\n            isNaN(this.expressionMap.offset)\r\n        )\r\n            throw new TypeORMError(\r\n                `Provided \"offset\" value is not a number. Please provide a numeric value.`,\r\n            )\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets maximal number of entities to take.\r\n     */\r\n    take(take?: number): this {\r\n        this.expressionMap.take = this.normalizeNumber(take)\r\n        if (\r\n            this.expressionMap.take !== undefined &&\r\n            isNaN(this.expressionMap.take)\r\n        )\r\n            throw new TypeORMError(\r\n                `Provided \"take\" value is not a number. Please provide a numeric value.`,\r\n            )\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets number of entities to skip.\r\n     */\r\n    skip(skip?: number): this {\r\n        this.expressionMap.skip = this.normalizeNumber(skip)\r\n        if (\r\n            this.expressionMap.skip !== undefined &&\r\n            isNaN(this.expressionMap.skip)\r\n        )\r\n            throw new TypeORMError(\r\n                `Provided \"skip\" value is not a number. Please provide a numeric value.`,\r\n            )\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Set certain index to be used by the query.\r\n     *\r\n     * @param index Name of index to be used.\r\n     */\r\n    useIndex(index: string): this {\r\n        this.expressionMap.useIndex = index\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(\r\n        lockMode:\r\n            | \"pessimistic_read\"\r\n            | \"pessimistic_write\"\r\n            | \"dirty_read\"\r\n            /*\r\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\r\n                will be removed in a future version.\r\n\r\n                Use setOnLocked instead.\r\n             */\r\n            | \"pessimistic_partial_write\"\r\n            | \"pessimistic_write_or_fail\"\r\n            | \"for_no_key_update\"\r\n            | \"for_key_share\",\r\n        lockVersion?: undefined,\r\n        lockTables?: string[],\r\n    ): this\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(\r\n        lockMode:\r\n            | \"optimistic\"\r\n            | \"pessimistic_read\"\r\n            | \"pessimistic_write\"\r\n            | \"dirty_read\"\r\n            /*\r\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\r\n                will be removed in a future version.\r\n\r\n                Use setOnLocked instead.\r\n             */\r\n            | \"pessimistic_partial_write\"\r\n            | \"pessimistic_write_or_fail\"\r\n            | \"for_no_key_update\"\r\n            | \"for_key_share\",\r\n        lockVersion?: number | Date,\r\n        lockTables?: string[],\r\n    ): this {\r\n        this.expressionMap.lockMode = lockMode\r\n        this.expressionMap.lockVersion = lockVersion\r\n        this.expressionMap.lockTables = lockTables\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets lock handling by adding NO WAIT or SKIP LOCKED.\r\n     */\r\n    setOnLocked(onLocked: \"nowait\" | \"skip_locked\"): this {\r\n        this.expressionMap.onLocked = onLocked\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\r\n     */\r\n    withDeleted(): this {\r\n        this.expressionMap.withDeleted = true\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Gets first raw result returned by execution of generated query builder sql.\r\n     */\r\n    async getRawOne<T = any>(): Promise<T | undefined> {\r\n        return (await this.getRawMany())[0]\r\n    }\r\n\r\n    /**\r\n     * Gets all raw results returned by execution of generated query builder sql.\r\n     */\r\n    async getRawMany<T = any>(): Promise<T[]> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError()\r\n\r\n        this.expressionMap.queryEntity = false\r\n        const queryRunner = this.obtainQueryRunner()\r\n        let transactionStartedByUs: boolean = false\r\n        try {\r\n            // start transaction if it was enabled\r\n            if (\r\n                this.expressionMap.useTransaction === true &&\r\n                queryRunner.isTransactionActive === false\r\n            ) {\r\n                await queryRunner.startTransaction()\r\n                transactionStartedByUs = true\r\n            }\r\n\r\n            const results = await this.loadRawResults(queryRunner)\r\n\r\n            // close transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                await queryRunner.commitTransaction()\r\n            }\r\n\r\n            return results\r\n        } catch (error) {\r\n            // rollback transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                try {\r\n                    await queryRunner.rollbackTransaction()\r\n                } catch (rollbackError) {}\r\n            }\r\n            throw error\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) {\r\n                // means we created our own query runner\r\n                await queryRunner.release()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\r\n     */\r\n    async getRawAndEntities<T = any>(): Promise<{\r\n        entities: Entity[]\r\n        raw: T[]\r\n    }> {\r\n        const queryRunner = this.obtainQueryRunner()\r\n        let transactionStartedByUs: boolean = false\r\n        try {\r\n            // start transaction if it was enabled\r\n            if (\r\n                this.expressionMap.useTransaction === true &&\r\n                queryRunner.isTransactionActive === false\r\n            ) {\r\n                await queryRunner.startTransaction()\r\n                transactionStartedByUs = true\r\n            }\r\n\r\n            this.expressionMap.queryEntity = true\r\n            const results = await this.executeEntitiesAndRawResults(queryRunner)\r\n\r\n            // close transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                await queryRunner.commitTransaction()\r\n            }\r\n\r\n            return results\r\n        } catch (error) {\r\n            // rollback transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                try {\r\n                    await queryRunner.rollbackTransaction()\r\n                } catch (rollbackError) {}\r\n            }\r\n            throw error\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner)\r\n                // means we created our own query runner\r\n                await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets single entity returned by execution of generated query builder sql.\r\n     */\r\n    async getOne(): Promise<Entity | null> {\r\n        const results = await this.getRawAndEntities()\r\n        const result = results.entities[0] as any\r\n\r\n        if (\r\n            result &&\r\n            this.expressionMap.lockMode === \"optimistic\" &&\r\n            this.expressionMap.lockVersion\r\n        ) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata\r\n\r\n            if (this.expressionMap.lockVersion instanceof Date) {\r\n                const actualVersion =\r\n                    metadata.updateDateColumn!.getEntityValue(result) // what if columns arent set?\r\n                if (\r\n                    actualVersion.getTime() !==\r\n                    this.expressionMap.lockVersion.getTime()\r\n                )\r\n                    throw new OptimisticLockVersionMismatchError(\r\n                        metadata.name,\r\n                        this.expressionMap.lockVersion,\r\n                        actualVersion,\r\n                    )\r\n            } else {\r\n                const actualVersion =\r\n                    metadata.versionColumn!.getEntityValue(result) // what if columns arent set?\r\n                if (actualVersion !== this.expressionMap.lockVersion)\r\n                    throw new OptimisticLockVersionMismatchError(\r\n                        metadata.name,\r\n                        this.expressionMap.lockVersion,\r\n                        actualVersion,\r\n                    )\r\n            }\r\n        }\r\n\r\n        if (result === undefined) {\r\n            return null\r\n        }\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\r\n     */\r\n    async getOneOrFail(): Promise<Entity> {\r\n        const entity = await this.getOne()\r\n\r\n        if (!entity) {\r\n            throw new EntityNotFoundError(\r\n                this.expressionMap.mainAlias!.target,\r\n                this.expressionMap.parameters,\r\n            )\r\n        }\r\n\r\n        return entity\r\n    }\r\n\r\n    /**\r\n     * Gets entities returned by execution of generated query builder sql.\r\n     */\r\n    async getMany(): Promise<Entity[]> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError()\r\n\r\n        const results = await this.getRawAndEntities()\r\n        return results.entities\r\n    }\r\n\r\n    /**\r\n     * Gets count - number of entities selected by sql generated by this query builder.\r\n     * Count excludes all limitations set by offset, limit, skip, and take.\r\n     */\r\n    async getCount(): Promise<number> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError()\r\n\r\n        const queryRunner = this.obtainQueryRunner()\r\n        let transactionStartedByUs: boolean = false\r\n        try {\r\n            // start transaction if it was enabled\r\n            if (\r\n                this.expressionMap.useTransaction === true &&\r\n                queryRunner.isTransactionActive === false\r\n            ) {\r\n                await queryRunner.startTransaction()\r\n                transactionStartedByUs = true\r\n            }\r\n\r\n            this.expressionMap.queryEntity = false\r\n            const results = await this.executeCountQuery(queryRunner)\r\n\r\n            // close transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                await queryRunner.commitTransaction()\r\n            }\r\n\r\n            return results\r\n        } catch (error) {\r\n            // rollback transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                try {\r\n                    await queryRunner.rollbackTransaction()\r\n                } catch (rollbackError) {}\r\n            }\r\n            throw error\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner)\r\n                // means we created our own query runner\r\n                await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets exists\r\n     * Returns whether any rows exists matching current query.\r\n     */\r\n    async getExists(): Promise<boolean> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError()\r\n\r\n        const queryRunner = this.obtainQueryRunner()\r\n        let transactionStartedByUs: boolean = false\r\n        try {\r\n            // start transaction if it was enabled\r\n            if (\r\n                this.expressionMap.useTransaction === true &&\r\n                queryRunner.isTransactionActive === false\r\n            ) {\r\n                await queryRunner.startTransaction()\r\n                transactionStartedByUs = true\r\n            }\r\n\r\n            this.expressionMap.queryEntity = false\r\n            const results = await this.executeExistsQuery(queryRunner)\r\n\r\n            // close transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                await queryRunner.commitTransaction()\r\n            }\r\n\r\n            return results\r\n        } catch (error) {\r\n            // rollback transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                try {\r\n                    await queryRunner.rollbackTransaction()\r\n                } catch (rollbackError) {}\r\n            }\r\n            throw error\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner)\r\n                // means we created our own query runner\r\n                await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\r\n     * This method is useful to build pagination.\r\n     */\r\n    async getManyAndCount(): Promise<[Entity[], number]> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError()\r\n\r\n        const queryRunner = this.obtainQueryRunner()\r\n        let transactionStartedByUs: boolean = false\r\n        try {\r\n            // start transaction if it was enabled\r\n            if (\r\n                this.expressionMap.useTransaction === true &&\r\n                queryRunner.isTransactionActive === false\r\n            ) {\r\n                await queryRunner.startTransaction()\r\n                transactionStartedByUs = true\r\n            }\r\n\r\n            this.expressionMap.queryEntity = true\r\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(\r\n                queryRunner,\r\n            )\r\n            this.expressionMap.queryEntity = false\r\n            const cacheId = this.expressionMap.cacheId\r\n            // Creates a new cacheId for the count query, or it will retreive the above query results\r\n            // and count will return 0.\r\n            this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId\r\n            const count = await this.executeCountQuery(queryRunner)\r\n            const results: [Entity[], number] = [entitiesAndRaw.entities, count]\r\n\r\n            // close transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                await queryRunner.commitTransaction()\r\n            }\r\n\r\n            return results\r\n        } catch (error) {\r\n            // rollback transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                try {\r\n                    await queryRunner.rollbackTransaction()\r\n                } catch (rollbackError) {}\r\n            }\r\n            throw error\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner)\r\n                // means we created our own query runner\r\n                await queryRunner.release()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes built SQL query and returns raw data stream.\r\n     */\r\n    async stream(): Promise<ReadStream> {\r\n        this.expressionMap.queryEntity = false\r\n        const [sql, parameters] = this.getQueryAndParameters()\r\n        const queryRunner = this.obtainQueryRunner()\r\n        let transactionStartedByUs: boolean = false\r\n        try {\r\n            // start transaction if it was enabled\r\n            if (\r\n                this.expressionMap.useTransaction === true &&\r\n                queryRunner.isTransactionActive === false\r\n            ) {\r\n                await queryRunner.startTransaction()\r\n                transactionStartedByUs = true\r\n            }\r\n\r\n            const releaseFn = () => {\r\n                if (queryRunner !== this.queryRunner)\r\n                    // means we created our own query runner\r\n                    return queryRunner.release()\r\n                return\r\n            }\r\n            const results = queryRunner.stream(\r\n                sql,\r\n                parameters,\r\n                releaseFn,\r\n                releaseFn,\r\n            )\r\n\r\n            // close transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                await queryRunner.commitTransaction()\r\n            }\r\n\r\n            return results\r\n        } catch (error) {\r\n            // rollback transaction if we started it\r\n            if (transactionStartedByUs) {\r\n                try {\r\n                    await queryRunner.rollbackTransaction()\r\n                } catch (rollbackError) {}\r\n            }\r\n            throw error\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables or disables query result caching.\r\n     */\r\n    cache(enabled: boolean): this\r\n\r\n    /**\r\n     * Enables query result caching and sets in milliseconds in which cache will expire.\r\n     * If not set then global caching time will be used.\r\n     */\r\n    cache(milliseconds: number): this\r\n\r\n    /**\r\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\r\n     */\r\n    cache(id: any, milliseconds?: number): this\r\n\r\n    /**\r\n     * Enables or disables query result caching.\r\n     */\r\n    cache(\r\n        enabledOrMillisecondsOrId: boolean | number | string,\r\n        maybeMilliseconds?: number,\r\n    ): this {\r\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\r\n            this.expressionMap.cache = enabledOrMillisecondsOrId\r\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\r\n            this.expressionMap.cache = true\r\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId\r\n        } else if (\r\n            typeof enabledOrMillisecondsOrId === \"string\" ||\r\n            typeof enabledOrMillisecondsOrId === \"number\"\r\n        ) {\r\n            this.expressionMap.cache = true\r\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId\r\n        }\r\n\r\n        if (maybeMilliseconds) {\r\n            this.expressionMap.cacheDuration = maybeMilliseconds\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets extra options that can be used to configure how query builder works.\r\n     */\r\n    setOption(option: SelectQueryBuilderOption): this {\r\n        this.expressionMap.options.push(option)\r\n        return this\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    protected join(\r\n        direction: \"INNER\" | \"LEFT\",\r\n        entityOrProperty:\r\n            | Function\r\n            | string\r\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n        aliasName: string,\r\n        condition?: string,\r\n        parameters?: ObjectLiteral,\r\n        mapToProperty?: string,\r\n        isMappingMany?: boolean,\r\n        mapAsEntity?: Function | string,\r\n    ): void {\r\n        if (parameters) {\r\n            this.setParameters(parameters)\r\n        }\r\n\r\n        const joinAttribute = new JoinAttribute(\r\n            this.connection,\r\n            this.expressionMap,\r\n        )\r\n        joinAttribute.direction = direction\r\n        joinAttribute.mapAsEntity = mapAsEntity\r\n        joinAttribute.mapToProperty = mapToProperty\r\n        joinAttribute.isMappingMany = isMappingMany\r\n        joinAttribute.entityOrProperty = entityOrProperty // relationName\r\n        joinAttribute.condition = condition // joinInverseSideCondition\r\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\r\n        this.expressionMap.joinAttributes.push(joinAttribute)\r\n\r\n        const joinAttributeMetadata = joinAttribute.metadata\r\n        if (joinAttributeMetadata) {\r\n            if (\r\n                joinAttributeMetadata.deleteDateColumn &&\r\n                !this.expressionMap.withDeleted\r\n            ) {\r\n                const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`\r\n                joinAttribute.condition = joinAttribute.condition\r\n                    ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}`\r\n                    : `${conditionDeleteColumn}`\r\n            }\r\n            // todo: find and set metadata right there?\r\n            joinAttribute.alias = this.expressionMap.createAlias({\r\n                type: \"join\",\r\n                name: aliasName,\r\n                metadata: joinAttributeMetadata,\r\n            })\r\n            if (\r\n                joinAttribute.relation &&\r\n                joinAttribute.relation.junctionEntityMetadata\r\n            ) {\r\n                this.expressionMap.createAlias({\r\n                    type: \"join\",\r\n                    name: joinAttribute.junctionAlias,\r\n                    metadata: joinAttribute.relation.junctionEntityMetadata,\r\n                })\r\n            }\r\n        } else {\r\n            let subQuery: string = \"\"\r\n            if (typeof entityOrProperty === \"function\") {\r\n                const subQueryBuilder: SelectQueryBuilder<any> = (\r\n                    entityOrProperty as any\r\n                )((this as any as SelectQueryBuilder<any>).subQuery())\r\n                this.setParameters(subQueryBuilder.getParameters())\r\n                subQuery = subQueryBuilder.getQuery()\r\n            } else {\r\n                subQuery = entityOrProperty\r\n            }\r\n            const isSubQuery =\r\n                typeof entityOrProperty === \"function\" ||\r\n                (entityOrProperty.substr(0, 1) === \"(\" &&\r\n                    entityOrProperty.substr(-1) === \")\")\r\n            joinAttribute.alias = this.expressionMap.createAlias({\r\n                type: \"join\",\r\n                name: aliasName,\r\n                tablePath:\r\n                    isSubQuery === false\r\n                        ? (entityOrProperty as string)\r\n                        : undefined,\r\n                subQuery: isSubQuery === true ? subQuery : undefined,\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates \"SELECT FROM\" part of SQL query.\r\n     */\r\n    protected createSelectExpression() {\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new TypeORMError(\r\n                \"Cannot build query because main alias is not set (call qb#from method)\",\r\n            )\r\n\r\n        // todo throw exception if selects or from is missing\r\n\r\n        const allSelects: SelectQuery[] = []\r\n        const excludedSelects: SelectQuery[] = []\r\n\r\n        if (this.expressionMap.mainAlias.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias.metadata\r\n            allSelects.push(\r\n                ...this.buildEscapedEntityColumnSelects(\r\n                    this.expressionMap.mainAlias.name,\r\n                    metadata,\r\n                ),\r\n            )\r\n            excludedSelects.push(\r\n                ...this.findEntityColumnSelects(\r\n                    this.expressionMap.mainAlias.name,\r\n                    metadata,\r\n                ),\r\n            )\r\n        }\r\n\r\n        // add selects from joins\r\n        this.expressionMap.joinAttributes.forEach((join) => {\r\n            if (join.metadata) {\r\n                allSelects.push(\r\n                    ...this.buildEscapedEntityColumnSelects(\r\n                        join.alias.name!,\r\n                        join.metadata,\r\n                    ),\r\n                )\r\n                excludedSelects.push(\r\n                    ...this.findEntityColumnSelects(\r\n                        join.alias.name!,\r\n                        join.metadata,\r\n                    ),\r\n                )\r\n            } else {\r\n                const hasMainAlias = this.expressionMap.selects.some(\r\n                    (select) => select.selection === join.alias.name,\r\n                )\r\n                if (hasMainAlias) {\r\n                    allSelects.push({\r\n                        selection: this.escape(join.alias.name!) + \".*\",\r\n                    })\r\n                    const excludedSelect = this.expressionMap.selects.find(\r\n                        (select) => select.selection === join.alias.name,\r\n                    )\r\n                    excludedSelects.push(excludedSelect!)\r\n                }\r\n            }\r\n        })\r\n\r\n        // add all other selects\r\n        this.expressionMap.selects\r\n            .filter((select) => excludedSelects.indexOf(select) === -1)\r\n            .forEach((select) =>\r\n                allSelects.push({\r\n                    selection: this.replacePropertyNames(select.selection),\r\n                    aliasName: select.aliasName,\r\n                }),\r\n            )\r\n\r\n        // if still selection is empty, then simply set it to all (*)\r\n        if (allSelects.length === 0) allSelects.push({ selection: \"*\" })\r\n\r\n        // Use certain index\r\n        let useIndex: string = \"\"\r\n        if (this.expressionMap.useIndex) {\r\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\r\n                useIndex = ` USE INDEX (${this.expressionMap.useIndex})`\r\n            }\r\n        }\r\n\r\n        // create a selection query\r\n        const froms = this.expressionMap.aliases\r\n            .filter(\r\n                (alias) =>\r\n                    alias.type === \"from\" &&\r\n                    (alias.tablePath || alias.subQuery),\r\n            )\r\n            .map((alias) => {\r\n                if (alias.subQuery)\r\n                    return alias.subQuery + \" \" + this.escape(alias.name)\r\n\r\n                return (\r\n                    this.getTableName(alias.tablePath!) +\r\n                    \" \" +\r\n                    this.escape(alias.name)\r\n                )\r\n            })\r\n\r\n        const select = this.createSelectDistinctExpression()\r\n        const selection = allSelects\r\n            .map(\r\n                (select) =>\r\n                    select.selection +\r\n                    (select.aliasName\r\n                        ? \" AS \" + this.escape(select.aliasName)\r\n                        : \"\"),\r\n            )\r\n            .join(\", \")\r\n\r\n        return (\r\n            select +\r\n            selection +\r\n            \" FROM \" +\r\n            froms.join(\", \") +\r\n            this.createTableLockExpression() +\r\n            useIndex\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates select | select distinct part of SQL query.\r\n     */\r\n    protected createSelectDistinctExpression(): string {\r\n        const { selectDistinct, selectDistinctOn, maxExecutionTime } =\r\n            this.expressionMap\r\n        const { driver } = this.connection\r\n\r\n        let select = \"SELECT \"\r\n\r\n        if (maxExecutionTime > 0) {\r\n            if (DriverUtils.isMySQLFamily(driver)) {\r\n                select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `\r\n            }\r\n        }\r\n\r\n        if (\r\n            DriverUtils.isPostgresFamily(driver) &&\r\n            selectDistinctOn.length > 0\r\n        ) {\r\n            const selectDistinctOnMap = selectDistinctOn\r\n                .map((on) => this.replacePropertyNames(on))\r\n                .join(\", \")\r\n\r\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `\r\n        } else if (selectDistinct) {\r\n            select = \"SELECT DISTINCT \"\r\n        }\r\n\r\n        return select\r\n    }\r\n\r\n    /**\r\n     * Creates \"JOIN\" part of SQL query.\r\n     */\r\n    protected createJoinExpression(): string {\r\n        // examples:\r\n        // select from owning side\r\n        // qb.select(\"post\")\r\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\r\n        // select from non-owning side\r\n        // qb.select(\"category\")\r\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\r\n\r\n        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {\r\n            const relation = joinAttr.relation\r\n            const destinationTableName = joinAttr.tablePath\r\n            const destinationTableAlias = joinAttr.alias.name\r\n            let appendedCondition = joinAttr.condition\r\n                ? \" AND (\" + joinAttr.condition + \")\"\r\n                : \"\"\r\n            const parentAlias = joinAttr.parentAlias\r\n\r\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\r\n            // table to join, without junction table involved. This means we simply join direct table.\r\n            if (!parentAlias || !relation) {\r\n                const destinationJoin = joinAttr.alias.subQuery\r\n                    ? joinAttr.alias.subQuery\r\n                    : this.getTableName(destinationTableName)\r\n                return (\r\n                    \" \" +\r\n                    joinAttr.direction +\r\n                    \" JOIN \" +\r\n                    destinationJoin +\r\n                    \" \" +\r\n                    this.escape(destinationTableAlias) +\r\n                    this.createTableLockExpression() +\r\n                    (joinAttr.condition\r\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\r\n                        : \"\")\r\n                )\r\n            }\r\n\r\n            // if real entity relation is involved\r\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\r\n                const condition = relation.joinColumns\r\n                    .map((joinColumn) => {\r\n                        return (\r\n                            destinationTableAlias +\r\n                            \".\" +\r\n                            joinColumn.referencedColumn!.propertyPath +\r\n                            \"=\" +\r\n                            parentAlias +\r\n                            \".\" +\r\n                            relation.propertyPath +\r\n                            \".\" +\r\n                            joinColumn.referencedColumn!.propertyPath\r\n                        )\r\n                    })\r\n                    .join(\" AND \")\r\n\r\n                return (\r\n                    \" \" +\r\n                    joinAttr.direction +\r\n                    \" JOIN \" +\r\n                    this.getTableName(destinationTableName) +\r\n                    \" \" +\r\n                    this.escape(destinationTableAlias) +\r\n                    this.createTableLockExpression() +\r\n                    \" ON \" +\r\n                    this.replacePropertyNames(condition + appendedCondition)\r\n                )\r\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\r\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\r\n                const condition = relation\r\n                    .inverseRelation!.joinColumns.map((joinColumn) => {\r\n                        if (\r\n                            relation.inverseEntityMetadata.tableType ===\r\n                                \"entity-child\" &&\r\n                            relation.inverseEntityMetadata.discriminatorColumn\r\n                        ) {\r\n                            appendedCondition +=\r\n                                \" AND \" +\r\n                                destinationTableAlias +\r\n                                \".\" +\r\n                                relation.inverseEntityMetadata\r\n                                    .discriminatorColumn.databaseName +\r\n                                \"='\" +\r\n                                relation.inverseEntityMetadata\r\n                                    .discriminatorValue +\r\n                                \"'\"\r\n                        }\r\n\r\n                        return (\r\n                            destinationTableAlias +\r\n                            \".\" +\r\n                            relation.inverseRelation!.propertyPath +\r\n                            \".\" +\r\n                            joinColumn.referencedColumn!.propertyPath +\r\n                            \"=\" +\r\n                            parentAlias +\r\n                            \".\" +\r\n                            joinColumn.referencedColumn!.propertyPath\r\n                        )\r\n                    })\r\n                    .join(\" AND \")\r\n\r\n                if (!condition)\r\n                    throw new TypeORMError(\r\n                        `Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`,\r\n                    )\r\n\r\n                return (\r\n                    \" \" +\r\n                    joinAttr.direction +\r\n                    \" JOIN \" +\r\n                    this.getTableName(destinationTableName) +\r\n                    \" \" +\r\n                    this.escape(destinationTableAlias) +\r\n                    this.createTableLockExpression() +\r\n                    \" ON \" +\r\n                    this.replacePropertyNames(condition + appendedCondition)\r\n                )\r\n            } else {\r\n                // means many-to-many\r\n                const junctionTableName =\r\n                    relation.junctionEntityMetadata!.tablePath\r\n\r\n                const junctionAlias = joinAttr.junctionAlias\r\n                let junctionCondition = \"\",\r\n                    destinationCondition = \"\"\r\n\r\n                if (relation.isOwning) {\r\n                    junctionCondition = relation.joinColumns\r\n                        .map((joinColumn) => {\r\n                            // `post_category`.`postId` = `post`.`id`\r\n                            return (\r\n                                junctionAlias +\r\n                                \".\" +\r\n                                joinColumn.propertyPath +\r\n                                \"=\" +\r\n                                parentAlias +\r\n                                \".\" +\r\n                                joinColumn.referencedColumn!.propertyPath\r\n                            )\r\n                        })\r\n                        .join(\" AND \")\r\n\r\n                    destinationCondition = relation.inverseJoinColumns\r\n                        .map((joinColumn) => {\r\n                            // `category`.`id` = `post_category`.`categoryId`\r\n                            return (\r\n                                destinationTableAlias +\r\n                                \".\" +\r\n                                joinColumn.referencedColumn!.propertyPath +\r\n                                \"=\" +\r\n                                junctionAlias +\r\n                                \".\" +\r\n                                joinColumn.propertyPath\r\n                            )\r\n                        })\r\n                        .join(\" AND \")\r\n                } else {\r\n                    junctionCondition = relation\r\n                        .inverseRelation!.inverseJoinColumns.map(\r\n                            (joinColumn) => {\r\n                                // `post_category`.`categoryId` = `category`.`id`\r\n                                return (\r\n                                    junctionAlias +\r\n                                    \".\" +\r\n                                    joinColumn.propertyPath +\r\n                                    \"=\" +\r\n                                    parentAlias +\r\n                                    \".\" +\r\n                                    joinColumn.referencedColumn!.propertyPath\r\n                                )\r\n                            },\r\n                        )\r\n                        .join(\" AND \")\r\n\r\n                    destinationCondition = relation\r\n                        .inverseRelation!.joinColumns.map((joinColumn) => {\r\n                            // `post`.`id` = `post_category`.`postId`\r\n                            return (\r\n                                destinationTableAlias +\r\n                                \".\" +\r\n                                joinColumn.referencedColumn!.propertyPath +\r\n                                \"=\" +\r\n                                junctionAlias +\r\n                                \".\" +\r\n                                joinColumn.propertyPath\r\n                            )\r\n                        })\r\n                        .join(\" AND \")\r\n                }\r\n\r\n                return (\r\n                    \" \" +\r\n                    joinAttr.direction +\r\n                    \" JOIN \" +\r\n                    this.getTableName(junctionTableName) +\r\n                    \" \" +\r\n                    this.escape(junctionAlias) +\r\n                    this.createTableLockExpression() +\r\n                    \" ON \" +\r\n                    this.replacePropertyNames(junctionCondition) +\r\n                    \" \" +\r\n                    joinAttr.direction +\r\n                    \" JOIN \" +\r\n                    this.getTableName(destinationTableName) +\r\n                    \" \" +\r\n                    this.escape(destinationTableAlias) +\r\n                    this.createTableLockExpression() +\r\n                    \" ON \" +\r\n                    this.replacePropertyNames(\r\n                        destinationCondition + appendedCondition,\r\n                    )\r\n                )\r\n            }\r\n        })\r\n\r\n        return joins.join(\" \")\r\n    }\r\n\r\n    /**\r\n     * Creates \"GROUP BY\" part of SQL query.\r\n     */\r\n    protected createGroupByExpression() {\r\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\r\n            return \"\"\r\n        return (\r\n            \" GROUP BY \" +\r\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"))\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates \"ORDER BY\" part of SQL query.\r\n     */\r\n    protected createOrderByExpression() {\r\n        const orderBys = this.expressionMap.allOrderBys\r\n        if (Object.keys(orderBys).length === 0) return \"\"\r\n\r\n        return (\r\n            \" ORDER BY \" +\r\n            Object.keys(orderBys)\r\n                .map((columnName) => {\r\n                    const orderValue =\r\n                        typeof orderBys[columnName] === \"string\"\r\n                            ? orderBys[columnName]\r\n                            : (orderBys[columnName] as any).order +\r\n                              \" \" +\r\n                              (orderBys[columnName] as any).nulls\r\n                    const selection = this.expressionMap.selects.find(\r\n                        (s) => s.selection === columnName,\r\n                    )\r\n                    if (\r\n                        selection &&\r\n                        !selection.aliasName &&\r\n                        columnName.indexOf(\".\") !== -1\r\n                    ) {\r\n                        const criteriaParts = columnName.split(\".\")\r\n                        const aliasName = criteriaParts[0]\r\n                        const propertyPath = criteriaParts.slice(1).join(\".\")\r\n                        const alias = this.expressionMap.aliases.find(\r\n                            (alias) => alias.name === aliasName,\r\n                        )\r\n                        if (alias) {\r\n                            const column =\r\n                                alias.metadata.findColumnWithPropertyPath(\r\n                                    propertyPath,\r\n                                )\r\n                            if (column) {\r\n                                const orderAlias = DriverUtils.buildAlias(\r\n                                    this.connection.driver,\r\n                                    undefined,\r\n                                    aliasName,\r\n                                    column.databaseName,\r\n                                )\r\n                                return (\r\n                                    this.escape(orderAlias) + \" \" + orderValue\r\n                                )\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return (\r\n                        this.replacePropertyNames(columnName) + \" \" + orderValue\r\n                    )\r\n                })\r\n                .join(\", \")\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\r\n     */\r\n    protected createLimitOffsetExpression(): string {\r\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\r\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\r\n        let offset: number | undefined = this.expressionMap.offset,\r\n            limit: number | undefined = this.expressionMap.limit\r\n        if (\r\n            !offset &&\r\n            !limit &&\r\n            this.expressionMap.joinAttributes.length === 0\r\n        ) {\r\n            offset = this.expressionMap.skip\r\n            limit = this.expressionMap.take\r\n        }\r\n\r\n        if (this.connection.driver.options.type === \"mssql\") {\r\n            // Due to a limitation in SQL Server's parser implementation it does not support using\r\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\r\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\r\n            // have no effect on the query planner or on the order of the results returned.\r\n            // https://dba.stackexchange.com/a/193799\r\n            let prefix = \"\"\r\n            if (\r\n                (limit || offset) &&\r\n                Object.keys(this.expressionMap.allOrderBys).length <= 0\r\n            ) {\r\n                prefix = \" ORDER BY (SELECT NULL)\"\r\n            }\r\n\r\n            if (limit && offset)\r\n                return (\r\n                    prefix +\r\n                    \" OFFSET \" +\r\n                    offset +\r\n                    \" ROWS FETCH NEXT \" +\r\n                    limit +\r\n                    \" ROWS ONLY\"\r\n                )\r\n            if (limit)\r\n                return (\r\n                    prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\"\r\n                )\r\n            if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\"\r\n        } else if (\r\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\r\n            this.connection.driver.options.type === \"aurora-mysql\" ||\r\n            this.connection.driver.options.type === \"sap\" ||\r\n            this.connection.driver.options.type === \"spanner\"\r\n        ) {\r\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\r\n            if (limit) return \" LIMIT \" + limit\r\n            if (offset) throw new OffsetWithoutLimitNotSupportedError()\r\n        } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\r\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\r\n            if (limit) return \" LIMIT \" + limit\r\n            if (offset) return \" LIMIT -1 OFFSET \" + offset\r\n        } else if (this.connection.driver.options.type === \"oracle\") {\r\n            if (limit && offset)\r\n                return (\r\n                    \" OFFSET \" +\r\n                    offset +\r\n                    \" ROWS FETCH NEXT \" +\r\n                    limit +\r\n                    \" ROWS ONLY\"\r\n                )\r\n            if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\"\r\n            if (offset) return \" OFFSET \" + offset + \" ROWS\"\r\n        } else {\r\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\r\n            if (limit) return \" LIMIT \" + limit\r\n            if (offset) return \" OFFSET \" + offset\r\n        }\r\n\r\n        return \"\"\r\n    }\r\n\r\n    /**\r\n     * Creates \"LOCK\" part of SELECT Query after table Clause\r\n     * ex.\r\n     *  SELECT 1\r\n     *  FROM USER U WITH (NOLOCK)\r\n     *  JOIN ORDER O WITH (NOLOCK)\r\n     *      ON U.ID=O.OrderID\r\n     */\r\n    private createTableLockExpression(): string {\r\n        if (this.connection.driver.options.type === \"mssql\") {\r\n            switch (this.expressionMap.lockMode) {\r\n                case \"pessimistic_read\":\r\n                    return \" WITH (HOLDLOCK, ROWLOCK)\"\r\n                case \"pessimistic_write\":\r\n                    return \" WITH (UPDLOCK, ROWLOCK)\"\r\n                case \"dirty_read\":\r\n                    return \" WITH (NOLOCK)\"\r\n            }\r\n        }\r\n\r\n        return \"\"\r\n    }\r\n\r\n    /**\r\n     * Creates \"LOCK\" part of SQL query.\r\n     */\r\n    protected createLockExpression(): string {\r\n        const driver = this.connection.driver\r\n\r\n        let lockTablesClause = \"\"\r\n\r\n        if (this.expressionMap.lockTables) {\r\n            if (\r\n                !(\r\n                    DriverUtils.isPostgresFamily(driver) ||\r\n                    driver.options.type === \"cockroachdb\"\r\n                )\r\n            ) {\r\n                throw new TypeORMError(\r\n                    \"Lock tables not supported in selected driver\",\r\n                )\r\n            }\r\n            if (this.expressionMap.lockTables.length < 1) {\r\n                throw new TypeORMError(\"lockTables cannot be an empty array\")\r\n            }\r\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \")\r\n        }\r\n\r\n        let onLockExpression = \"\"\r\n        if (this.expressionMap.onLocked === \"nowait\") {\r\n            onLockExpression = \" NOWAIT\"\r\n        } else if (this.expressionMap.onLocked === \"skip_locked\") {\r\n            onLockExpression = \" SKIP LOCKED\"\r\n        }\r\n        switch (this.expressionMap.lockMode) {\r\n            case \"pessimistic_read\":\r\n                if (\r\n                    driver.options.type === \"mysql\" ||\r\n                    driver.options.type === \"aurora-mysql\"\r\n                ) {\r\n                    if (\r\n                        DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")\r\n                    ) {\r\n                        return (\r\n                            \" FOR SHARE\" + lockTablesClause + onLockExpression\r\n                        )\r\n                    } else {\r\n                        return \" LOCK IN SHARE MODE\"\r\n                    }\r\n                } else if (driver.options.type === \"mariadb\") {\r\n                    return \" LOCK IN SHARE MODE\"\r\n                } else if (DriverUtils.isPostgresFamily(driver)) {\r\n                    return \" FOR SHARE\" + lockTablesClause + onLockExpression\r\n                } else if (driver.options.type === \"oracle\") {\r\n                    return \" FOR UPDATE\"\r\n                } else if (driver.options.type === \"mssql\") {\r\n                    return \"\"\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError()\r\n                }\r\n            case \"pessimistic_write\":\r\n                if (\r\n                    DriverUtils.isMySQLFamily(driver) ||\r\n                    driver.options.type === \"aurora-mysql\" ||\r\n                    driver.options.type === \"oracle\"\r\n                ) {\r\n                    return \" FOR UPDATE\" + onLockExpression\r\n                } else if (\r\n                    DriverUtils.isPostgresFamily(driver) ||\r\n                    driver.options.type === \"cockroachdb\"\r\n                ) {\r\n                    return \" FOR UPDATE\" + lockTablesClause + onLockExpression\r\n                } else if (driver.options.type === \"mssql\") {\r\n                    return \"\"\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError()\r\n                }\r\n            case \"pessimistic_partial_write\":\r\n                if (DriverUtils.isPostgresFamily(driver)) {\r\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\"\r\n                } else if (DriverUtils.isMySQLFamily(driver)) {\r\n                    return \" FOR UPDATE SKIP LOCKED\"\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError()\r\n                }\r\n            case \"pessimistic_write_or_fail\":\r\n                if (\r\n                    DriverUtils.isPostgresFamily(driver) ||\r\n                    driver.options.type === \"cockroachdb\"\r\n                ) {\r\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\"\r\n                } else if (DriverUtils.isMySQLFamily(driver)) {\r\n                    return \" FOR UPDATE NOWAIT\"\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError()\r\n                }\r\n            case \"for_no_key_update\":\r\n                if (\r\n                    DriverUtils.isPostgresFamily(driver) ||\r\n                    driver.options.type === \"cockroachdb\"\r\n                ) {\r\n                    return (\r\n                        \" FOR NO KEY UPDATE\" +\r\n                        lockTablesClause +\r\n                        onLockExpression\r\n                    )\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError()\r\n                }\r\n            case \"for_key_share\":\r\n                if (DriverUtils.isPostgresFamily(driver)) {\r\n                    return (\r\n                        \" FOR KEY SHARE\" + lockTablesClause + onLockExpression\r\n                    )\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError()\r\n                }\r\n            default:\r\n                return \"\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates \"HAVING\" part of SQL query.\r\n     */\r\n    protected createHavingExpression() {\r\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\r\n            return \"\"\r\n        const conditions = this.expressionMap.havings\r\n            .map((having, index) => {\r\n                switch (having.type) {\r\n                    case \"and\":\r\n                        return (\r\n                            (index > 0 ? \"AND \" : \"\") +\r\n                            this.replacePropertyNames(having.condition)\r\n                        )\r\n                    case \"or\":\r\n                        return (\r\n                            (index > 0 ? \"OR \" : \"\") +\r\n                            this.replacePropertyNames(having.condition)\r\n                        )\r\n                    default:\r\n                        return this.replacePropertyNames(having.condition)\r\n                }\r\n            })\r\n            .join(\" \")\r\n\r\n        if (!conditions.length) return \"\"\r\n        return \" HAVING \" + conditions\r\n    }\r\n\r\n    protected buildEscapedEntityColumnSelects(\r\n        aliasName: string,\r\n        metadata: EntityMetadata,\r\n    ): SelectQuery[] {\r\n        const hasMainAlias = this.expressionMap.selects.some(\r\n            (select) => select.selection === aliasName,\r\n        )\r\n\r\n        const columns: ColumnMetadata[] = []\r\n        if (hasMainAlias) {\r\n            columns.push(\r\n                ...metadata.columns.filter(\r\n                    (column) => column.isSelect === true,\r\n                ),\r\n            )\r\n        }\r\n        columns.push(\r\n            ...metadata.columns.filter((column) => {\r\n                return this.expressionMap.selects.some(\r\n                    (select) =>\r\n                        select.selection ===\r\n                        aliasName + \".\" + column.propertyPath,\r\n                )\r\n            }),\r\n        )\r\n\r\n        // if user used partial selection and did not select some primary columns which are required to be selected\r\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\r\n        // to make entity contain exactly what user selected\r\n        if (columns.length === 0)\r\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\r\n            return []\r\n\r\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\r\n            ? metadata.primaryColumns.filter(\r\n                  (primaryColumn) => columns.indexOf(primaryColumn) === -1,\r\n              )\r\n            : []\r\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns]\r\n        const finalSelects: SelectQuery[] = []\r\n\r\n        const escapedAliasName = this.escape(aliasName)\r\n        allColumns.forEach((column) => {\r\n            let selectionPath =\r\n                escapedAliasName + \".\" + this.escape(column.databaseName)\r\n\r\n            if (column.isVirtualProperty && column.query) {\r\n                selectionPath = `(${column.query(escapedAliasName)})`\r\n            }\r\n\r\n            if (\r\n                this.connection.driver.spatialTypes.indexOf(column.type) !== -1\r\n            ) {\r\n                if (\r\n                    DriverUtils.isMySQLFamily(this.connection.driver) ||\r\n                    this.connection.driver.options.type === \"aurora-mysql\"\r\n                ) {\r\n                    const useLegacy = (\r\n                        this.connection.driver as\r\n                            | MysqlDriver\r\n                            | AuroraMysqlDriver\r\n                    ).options.legacySpatialSupport\r\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\"\r\n                    selectionPath = `${asText}(${selectionPath})`\r\n                }\r\n\r\n                if (DriverUtils.isPostgresFamily(this.connection.driver))\r\n                    if (column.precision) {\r\n                        // cast to JSON to trigger parsing in the driver\r\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`\r\n                    } else {\r\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`\r\n                    }\r\n                if (this.connection.driver.options.type === \"mssql\")\r\n                    selectionPath = `${selectionPath}.ToString()`\r\n            }\r\n\r\n            const selections = this.expressionMap.selects.filter(\r\n                (select) =>\r\n                    select.selection === aliasName + \".\" + column.propertyPath,\r\n            )\r\n            if (selections.length) {\r\n                selections.forEach((selection) => {\r\n                    finalSelects.push({\r\n                        selection: selectionPath,\r\n                        aliasName: selection.aliasName\r\n                            ? selection.aliasName\r\n                            : DriverUtils.buildAlias(\r\n                                  this.connection.driver,\r\n                                  undefined,\r\n                                  aliasName,\r\n                                  column.databaseName,\r\n                              ),\r\n                        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\r\n                        virtual: selection.virtual,\r\n                    })\r\n                })\r\n            } else {\r\n                if (column.isVirtualProperty) {\r\n                    // Do not add unselected virtual properties to final select\r\n                    return\r\n                }\r\n\r\n                finalSelects.push({\r\n                    selection: selectionPath,\r\n                    aliasName: DriverUtils.buildAlias(\r\n                        this.connection.driver,\r\n                        undefined,\r\n                        aliasName,\r\n                        column.databaseName,\r\n                    ),\r\n                    // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\r\n                    virtual: hasMainAlias,\r\n                })\r\n            }\r\n        })\r\n        return finalSelects\r\n    }\r\n\r\n    protected findEntityColumnSelects(\r\n        aliasName: string,\r\n        metadata: EntityMetadata,\r\n    ): SelectQuery[] {\r\n        const mainSelect = this.expressionMap.selects.find(\r\n            (select) => select.selection === aliasName,\r\n        )\r\n        if (mainSelect) return [mainSelect]\r\n\r\n        return this.expressionMap.selects.filter((select) => {\r\n            return metadata.columns.some(\r\n                (column) =>\r\n                    select.selection === aliasName + \".\" + column.propertyPath,\r\n            )\r\n        })\r\n    }\r\n\r\n    private computeCountExpression() {\r\n        const mainAlias = this.expressionMap.mainAlias!.name // todo: will this work with \"fromTableName\"?\r\n        const metadata = this.expressionMap.mainAlias!.metadata\r\n\r\n        const primaryColumns = metadata.primaryColumns\r\n        const distinctAlias = this.escape(mainAlias)\r\n\r\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\r\n        // so we prevent poor query patterns in the most likely cases\r\n        if (\r\n            this.expressionMap.joinAttributes.length === 0 &&\r\n            this.expressionMap.relationIdAttributes.length === 0 &&\r\n            this.expressionMap.relationCountAttributes.length === 0\r\n        ) {\r\n            return \"COUNT(1)\"\r\n        }\r\n\r\n        // For everything else, we'll need to do some hackery to get the correct count values.\r\n\r\n        if (\r\n            this.connection.driver.options.type === \"cockroachdb\" ||\r\n            DriverUtils.isPostgresFamily(this.connection.driver)\r\n        ) {\r\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\r\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\r\n            return (\r\n                \"COUNT(DISTINCT(\" +\r\n                primaryColumns\r\n                    .map(\r\n                        (c) =>\r\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\r\n                    )\r\n                    .join(\", \") +\r\n                \"))\"\r\n            )\r\n        }\r\n\r\n        if (DriverUtils.isMySQLFamily(this.connection.driver)) {\r\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\r\n            // https://mariadb.com/kb/en/count-distinct/\r\n            return (\r\n                \"COUNT(DISTINCT \" +\r\n                primaryColumns\r\n                    .map(\r\n                        (c) =>\r\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\r\n                    )\r\n                    .join(\", \") +\r\n                \")\"\r\n            )\r\n        }\r\n\r\n        if (this.connection.driver.options.type === \"mssql\") {\r\n            // SQL Server has gotta be different from everyone else.  They don't support\r\n            // distinct counting multiple columns & they don't have the same operator\r\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\r\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\r\n\r\n            const columnsExpression = primaryColumns\r\n                .map(\r\n                    (primaryColumn) =>\r\n                        `${distinctAlias}.${this.escape(\r\n                            primaryColumn.databaseName,\r\n                        )}`,\r\n                )\r\n                .join(\", '|;|', \")\r\n\r\n            if (primaryColumns.length === 1) {\r\n                return `COUNT(DISTINCT(${columnsExpression}))`\r\n            }\r\n\r\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\r\n        }\r\n\r\n        if (this.connection.driver.options.type === \"spanner\") {\r\n            // spanner also has gotta be different from everyone else.\r\n            // they do not support concatenation of different column types without casting them to string\r\n\r\n            if (primaryColumns.length === 1) {\r\n                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(\r\n                    primaryColumns[0].databaseName,\r\n                )}))`\r\n            }\r\n\r\n            const columnsExpression = primaryColumns\r\n                .map(\r\n                    (primaryColumn) =>\r\n                        `CAST(${distinctAlias}.${this.escape(\r\n                            primaryColumn.databaseName,\r\n                        )} AS STRING)`,\r\n                )\r\n                .join(\", '|;|', \")\r\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\r\n        }\r\n\r\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\r\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\r\n        // likely to work across servers implementing the SQL standard.\r\n\r\n        // Please note, if there is only one primary column that the concatenation does not occur in this\r\n        // query and the query is a standard `COUNT DISTINCT` in that case.\r\n\r\n        return (\r\n            `COUNT(DISTINCT(` +\r\n            primaryColumns\r\n                .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\r\n                .join(\" || '|;|' || \") +\r\n            \"))\"\r\n        )\r\n    }\r\n\r\n    protected async executeCountQuery(\r\n        queryRunner: QueryRunner,\r\n    ): Promise<number> {\r\n        const countSql = this.computeCountExpression()\r\n\r\n        const results = await this.clone()\r\n            .orderBy()\r\n            .groupBy()\r\n            .offset(undefined)\r\n            .limit(undefined)\r\n            .skip(undefined)\r\n            .take(undefined)\r\n            .select(countSql, \"cnt\")\r\n            .setOption(\"disable-global-order\")\r\n            .loadRawResults(queryRunner)\r\n\r\n        if (!results || !results[0] || !results[0][\"cnt\"]) return 0\r\n\r\n        return parseInt(results[0][\"cnt\"])\r\n    }\r\n\r\n    protected async executeExistsQuery(\r\n        queryRunner: QueryRunner,\r\n    ): Promise<boolean> {\r\n        const results = await this.connection\r\n            .createQueryBuilder()\r\n            .fromDummy()\r\n            .select(\"1\", \"row_exists\")\r\n            .whereExists(this)\r\n            .limit(1)\r\n            .loadRawResults(queryRunner)\r\n\r\n        return results.length > 0\r\n    }\r\n\r\n    protected applyFindOptions() {\r\n        // todo: convert relations: string[] to object map to simplify code\r\n        // todo: same with selects\r\n\r\n        if (this.expressionMap.mainAlias!.metadata) {\r\n            if (this.findOptions.relationLoadStrategy) {\r\n                this.expressionMap.relationLoadStrategy =\r\n                    this.findOptions.relationLoadStrategy\r\n            }\r\n\r\n            if (this.findOptions.comment) {\r\n                this.comment(this.findOptions.comment)\r\n            }\r\n\r\n            if (this.findOptions.withDeleted) {\r\n                this.withDeleted()\r\n            }\r\n\r\n            if (this.findOptions.select) {\r\n                const select = Array.isArray(this.findOptions.select)\r\n                    ? OrmUtils.propertyPathsToTruthyObject(\r\n                          this.findOptions.select as string[],\r\n                      )\r\n                    : this.findOptions.select\r\n\r\n                this.buildSelect(\r\n                    select,\r\n                    this.expressionMap.mainAlias!.metadata,\r\n                    this.expressionMap.mainAlias!.name,\r\n                )\r\n            }\r\n\r\n            if (this.selects.length) {\r\n                this.select(this.selects)\r\n            }\r\n\r\n            this.selects = []\r\n            if (this.findOptions.relations) {\r\n                const relations = Array.isArray(this.findOptions.relations)\r\n                    ? OrmUtils.propertyPathsToTruthyObject(\r\n                          this.findOptions.relations,\r\n                      )\r\n                    : this.findOptions.relations\r\n\r\n                this.buildRelations(\r\n                    relations,\r\n                    typeof this.findOptions.select === \"object\"\r\n                        ? (this.findOptions.select as FindOptionsSelect<any>)\r\n                        : undefined,\r\n                    this.expressionMap.mainAlias!.metadata,\r\n                    this.expressionMap.mainAlias!.name,\r\n                )\r\n                if (\r\n                    this.findOptions.loadEagerRelations !== false &&\r\n                    this.expressionMap.relationLoadStrategy === \"join\"\r\n                ) {\r\n                    this.buildEagerRelations(\r\n                        relations,\r\n                        typeof this.findOptions.select === \"object\"\r\n                            ? (this.findOptions\r\n                                  .select as FindOptionsSelect<any>)\r\n                            : undefined,\r\n                        this.expressionMap.mainAlias!.metadata,\r\n                        this.expressionMap.mainAlias!.name,\r\n                    )\r\n                }\r\n            }\r\n            if (this.selects.length) {\r\n                this.addSelect(this.selects)\r\n            }\r\n\r\n            if (this.findOptions.where) {\r\n                this.conditions = this.buildWhere(\r\n                    this.findOptions.where,\r\n                    this.expressionMap.mainAlias!.metadata,\r\n                    this.expressionMap.mainAlias!.name,\r\n                )\r\n\r\n                if (this.conditions.length)\r\n                    this.andWhere(\r\n                        this.conditions.substr(0, 1) !== \"(\"\r\n                            ? \"(\" + this.conditions + \")\"\r\n                            : this.conditions,\r\n                    ) // temporary and where and braces\r\n            }\r\n\r\n            if (this.findOptions.order) {\r\n                this.buildOrder(\r\n                    this.findOptions.order,\r\n                    this.expressionMap.mainAlias!.metadata,\r\n                    this.expressionMap.mainAlias!.name,\r\n                )\r\n            }\r\n\r\n            // apply joins\r\n            if (this.joins.length) {\r\n                this.joins.forEach((join) => {\r\n                    if (join.select && !join.selection) {\r\n                        // if (join.selection) {\r\n                        //\r\n                        // } else {\r\n                        if (join.type === \"inner\") {\r\n                            this.innerJoinAndSelect(\r\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\r\n                                join.alias,\r\n                            )\r\n                        } else {\r\n                            this.leftJoinAndSelect(\r\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\r\n                                join.alias,\r\n                            )\r\n                        }\r\n                        // }\r\n                    } else {\r\n                        if (join.type === \"inner\") {\r\n                            this.innerJoin(\r\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\r\n                                join.alias,\r\n                            )\r\n                        } else {\r\n                            this.leftJoin(\r\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\r\n                                join.alias,\r\n                            )\r\n                        }\r\n                    }\r\n\r\n                    // if (join.select) {\r\n                    //     if (this.findOptions.loadEagerRelations !== false) {\r\n                    //         FindOptionsUtils.joinEagerRelations(\r\n                    //             this,\r\n                    //             join.alias,\r\n                    //             join.relationMetadata.inverseEntityMetadata\r\n                    //         );\r\n                    //     }\r\n                    // }\r\n                })\r\n            }\r\n\r\n            // if (this.conditions.length) {\r\n            //     this.where(this.conditions.join(\" AND \"));\r\n            // }\r\n\r\n            // apply offset\r\n            if (this.findOptions.skip !== undefined) {\r\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\r\n                //     this.offset(this.findOptions.skip);\r\n                // } else {\r\n                this.skip(this.findOptions.skip)\r\n                // }\r\n            }\r\n\r\n            // apply limit\r\n            if (this.findOptions.take !== undefined) {\r\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\r\n                //     this.limit(this.findOptions.take);\r\n                // } else {\r\n                this.take(this.findOptions.take)\r\n                // }\r\n            }\r\n\r\n            // apply caching options\r\n            if (typeof this.findOptions.cache === \"number\") {\r\n                this.cache(this.findOptions.cache)\r\n            } else if (typeof this.findOptions.cache === \"boolean\") {\r\n                this.cache(this.findOptions.cache)\r\n            } else if (typeof this.findOptions.cache === \"object\") {\r\n                this.cache(\r\n                    this.findOptions.cache.id,\r\n                    this.findOptions.cache.milliseconds,\r\n                )\r\n            }\r\n\r\n            if (this.findOptions.join) {\r\n                if (this.findOptions.join.leftJoin)\r\n                    Object.keys(this.findOptions.join.leftJoin).forEach(\r\n                        (key) => {\r\n                            this.leftJoin(\r\n                                this.findOptions.join!.leftJoin![key],\r\n                                key,\r\n                            )\r\n                        },\r\n                    )\r\n\r\n                if (this.findOptions.join.innerJoin)\r\n                    Object.keys(this.findOptions.join.innerJoin).forEach(\r\n                        (key) => {\r\n                            this.innerJoin(\r\n                                this.findOptions.join!.innerJoin![key],\r\n                                key,\r\n                            )\r\n                        },\r\n                    )\r\n\r\n                if (this.findOptions.join.leftJoinAndSelect)\r\n                    Object.keys(\r\n                        this.findOptions.join.leftJoinAndSelect,\r\n                    ).forEach((key) => {\r\n                        this.leftJoinAndSelect(\r\n                            this.findOptions.join!.leftJoinAndSelect![key],\r\n                            key,\r\n                        )\r\n                    })\r\n\r\n                if (this.findOptions.join.innerJoinAndSelect)\r\n                    Object.keys(\r\n                        this.findOptions.join.innerJoinAndSelect,\r\n                    ).forEach((key) => {\r\n                        this.innerJoinAndSelect(\r\n                            this.findOptions.join!.innerJoinAndSelect![key],\r\n                            key,\r\n                        )\r\n                    })\r\n            }\r\n\r\n            if (this.findOptions.lock) {\r\n                if (this.findOptions.lock.mode === \"optimistic\") {\r\n                    this.setLock(\r\n                        this.findOptions.lock.mode,\r\n                        this.findOptions.lock.version,\r\n                    )\r\n                } else if (\r\n                    this.findOptions.lock.mode === \"pessimistic_read\" ||\r\n                    this.findOptions.lock.mode === \"pessimistic_write\" ||\r\n                    this.findOptions.lock.mode === \"dirty_read\" ||\r\n                    this.findOptions.lock.mode ===\r\n                        \"pessimistic_partial_write\" ||\r\n                    this.findOptions.lock.mode ===\r\n                        \"pessimistic_write_or_fail\" ||\r\n                    this.findOptions.lock.mode === \"for_no_key_update\" ||\r\n                    this.findOptions.lock.mode === \"for_key_share\"\r\n                ) {\r\n                    const tableNames = this.findOptions.lock.tables\r\n                        ? this.findOptions.lock.tables.map((table) => {\r\n                              const tableAlias =\r\n                                  this.expressionMap.aliases.find((alias) => {\r\n                                      return (\r\n                                          alias.metadata\r\n                                              .tableNameWithoutPrefix === table\r\n                                      )\r\n                                  })\r\n                              if (!tableAlias) {\r\n                                  throw new TypeORMError(\r\n                                      `\"${table}\" is not part of this query`,\r\n                                  )\r\n                              }\r\n                              return this.escape(tableAlias.name)\r\n                          })\r\n                        : undefined\r\n                    this.setLock(\r\n                        this.findOptions.lock.mode,\r\n                        undefined,\r\n                        tableNames,\r\n                    )\r\n\r\n                    if (this.findOptions.lock.onLocked) {\r\n                        this.setOnLocked(this.findOptions.lock.onLocked)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.findOptions.loadRelationIds === true) {\r\n                this.loadAllRelationIds()\r\n            } else if (typeof this.findOptions.loadRelationIds === \"object\") {\r\n                this.loadAllRelationIds(this.findOptions.loadRelationIds as any)\r\n            }\r\n\r\n            if (this.findOptions.loadEagerRelations !== false) {\r\n                FindOptionsUtils.joinEagerRelations(\r\n                    this,\r\n                    this.expressionMap.mainAlias!.name,\r\n                    this.expressionMap.mainAlias!.metadata,\r\n                )\r\n            }\r\n\r\n            if (this.findOptions.transaction === true) {\r\n                this.expressionMap.useTransaction = true\r\n            }\r\n\r\n            // if (this.orderBys.length) {\r\n            //     this.orderBys.forEach(orderBy => {\r\n            //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\r\n            //     });\r\n            // }\r\n\r\n            // todo\r\n            // if (this.options.options && this.options.options.eagerRelations) {\r\n            //     this.queryBuilder\r\n            // }\r\n\r\n            // todo\r\n            // if (this.findOptions.options && this.findOptions.listeners === false) {\r\n            //     this.callListeners(false);\r\n            // }\r\n        }\r\n    }\r\n\r\n    public concatRelationMetadata(relationMetadata: RelationMetadata) {\r\n        this.relationMetadatas.push(relationMetadata)\r\n    }\r\n\r\n    /**\r\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\r\n     */\r\n    protected async executeEntitiesAndRawResults(\r\n        queryRunner: QueryRunner,\r\n    ): Promise<{ entities: Entity[]; raw: any[] }> {\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new TypeORMError(\r\n                `Alias is not set. Use \"from\" method to set an alias.`,\r\n            )\r\n\r\n        if (\r\n            (this.expressionMap.lockMode === \"pessimistic_read\" ||\r\n                this.expressionMap.lockMode === \"pessimistic_write\" ||\r\n                this.expressionMap.lockMode === \"pessimistic_partial_write\" ||\r\n                this.expressionMap.lockMode === \"pessimistic_write_or_fail\" ||\r\n                this.expressionMap.lockMode === \"for_no_key_update\" ||\r\n                this.expressionMap.lockMode === \"for_key_share\") &&\r\n            !queryRunner.isTransactionActive\r\n        )\r\n            throw new PessimisticLockTransactionRequiredError()\r\n\r\n        if (this.expressionMap.lockMode === \"optimistic\") {\r\n            const metadata = this.expressionMap.mainAlias.metadata\r\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\r\n                throw new NoVersionOrUpdateDateColumnError(metadata.name)\r\n        }\r\n\r\n        const relationIdLoader = new RelationIdLoader(\r\n            this.connection,\r\n            queryRunner,\r\n            this.expressionMap.relationIdAttributes,\r\n        )\r\n        const relationCountLoader = new RelationCountLoader(\r\n            this.connection,\r\n            queryRunner,\r\n            this.expressionMap.relationCountAttributes,\r\n        )\r\n        const relationIdMetadataTransformer =\r\n            new RelationIdMetadataToAttributeTransformer(this.expressionMap)\r\n        relationIdMetadataTransformer.transform()\r\n        const relationCountMetadataTransformer =\r\n            new RelationCountMetadataToAttributeTransformer(this.expressionMap)\r\n        relationCountMetadataTransformer.transform()\r\n\r\n        let rawResults: any[] = [],\r\n            entities: any[] = []\r\n\r\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\r\n        // where we make two queries to find the data we need\r\n        // first query find ids in skip and take range\r\n        // and second query loads the actual data in given ids range\r\n        if (\r\n            (this.expressionMap.skip || this.expressionMap.take) &&\r\n            this.expressionMap.joinAttributes.length > 0\r\n        ) {\r\n            // we are skipping order by here because its not working in subqueries anyway\r\n            // to make order by working we need to apply it on a distinct query\r\n            const [selects, orderBys] =\r\n                this.createOrderByCombinedWithSelectExpression(\"distinctAlias\")\r\n            const metadata = this.expressionMap.mainAlias.metadata\r\n            const mainAliasName = this.expressionMap.mainAlias.name\r\n\r\n            const querySelects = metadata.primaryColumns.map(\r\n                (primaryColumn) => {\r\n                    const distinctAlias = this.escape(\"distinctAlias\")\r\n                    const columnAlias = this.escape(\r\n                        DriverUtils.buildAlias(\r\n                            this.connection.driver,\r\n                            undefined,\r\n                            mainAliasName,\r\n                            primaryColumn.databaseName,\r\n                        ),\r\n                    )\r\n                    if (!orderBys[columnAlias])\r\n                        // make sure we aren't overriding user-defined order in inverse direction\r\n                        orderBys[columnAlias] = \"ASC\"\r\n\r\n                    const alias = DriverUtils.buildAlias(\r\n                        this.connection.driver,\r\n                        undefined,\r\n                        \"ids_\" + mainAliasName,\r\n                        primaryColumn.databaseName,\r\n                    )\r\n\r\n                    return `${distinctAlias}.${columnAlias} AS ${this.escape(\r\n                        alias,\r\n                    )}`\r\n                },\r\n            )\r\n\r\n            const originalQuery = this.clone()\r\n\r\n            // preserve original timeTravel value since we set it to \"false\" in subquery\r\n            const originalQueryTimeTravel =\r\n                originalQuery.expressionMap.timeTravel\r\n\r\n            rawResults = await new SelectQueryBuilder(\r\n                this.connection,\r\n                queryRunner,\r\n            )\r\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\r\n                .addSelect(selects)\r\n                .from(\r\n                    `(${originalQuery\r\n                        .orderBy()\r\n                        .timeTravelQuery(false) // set it to \"false\" since time travel clause must appear at the very end and applies to the entire SELECT clause.\r\n                        .getQuery()})`,\r\n                    \"distinctAlias\",\r\n                )\r\n                .timeTravelQuery(originalQueryTimeTravel)\r\n                .offset(this.expressionMap.skip)\r\n                .limit(this.expressionMap.take)\r\n                .orderBy(orderBys)\r\n                .cache(\r\n                    this.expressionMap.cache && this.expressionMap.cacheId\r\n                        ? `${this.expressionMap.cacheId}-pagination`\r\n                        : this.expressionMap.cache,\r\n                    this.expressionMap.cacheDuration,\r\n                )\r\n                .setParameters(this.getParameters())\r\n                .setNativeParameters(this.expressionMap.nativeParameters)\r\n                .getRawMany()\r\n\r\n            if (rawResults.length > 0) {\r\n                let condition = \"\"\r\n                const parameters: ObjectLiteral = {}\r\n                if (metadata.hasMultiplePrimaryKeys) {\r\n                    condition = rawResults\r\n                        .map((result, index) => {\r\n                            return metadata.primaryColumns\r\n                                .map((primaryColumn) => {\r\n                                    const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`\r\n                                    const paramKeyResult =\r\n                                        DriverUtils.buildAlias(\r\n                                            this.connection.driver,\r\n                                            undefined,\r\n                                            \"ids_\" + mainAliasName,\r\n                                            primaryColumn.databaseName,\r\n                                        )\r\n                                    parameters[paramKey] =\r\n                                        result[paramKeyResult]\r\n                                    return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`\r\n                                })\r\n                                .join(\" AND \")\r\n                        })\r\n                        .join(\" OR \")\r\n                } else {\r\n                    const alias = DriverUtils.buildAlias(\r\n                        this.connection.driver,\r\n                        undefined,\r\n                        \"ids_\" + mainAliasName,\r\n                        metadata.primaryColumns[0].databaseName,\r\n                    )\r\n\r\n                    const ids = rawResults.map((result) => result[alias])\r\n                    const areAllNumbers = ids.every(\r\n                        (id: any) => typeof id === \"number\",\r\n                    )\r\n                    if (areAllNumbers) {\r\n                        // fixes #190. if all numbers then its safe to perform query without parameter\r\n                        condition = `${mainAliasName}.${\r\n                            metadata.primaryColumns[0].propertyPath\r\n                        } IN (${ids.join(\", \")})`\r\n                    } else {\r\n                        parameters[\"orm_distinct_ids\"] = ids\r\n                        condition =\r\n                            mainAliasName +\r\n                            \".\" +\r\n                            metadata.primaryColumns[0].propertyPath +\r\n                            \" IN (:...orm_distinct_ids)\"\r\n                    }\r\n                }\r\n                rawResults = await this.clone()\r\n                    .mergeExpressionMap({\r\n                        extraAppendedAndWhereCondition: condition,\r\n                    })\r\n                    .setParameters(parameters)\r\n                    .loadRawResults(queryRunner)\r\n            }\r\n        } else {\r\n            rawResults = await this.loadRawResults(queryRunner)\r\n        }\r\n\r\n        if (rawResults.length > 0) {\r\n            // transform raw results into entities\r\n            const rawRelationIdResults = await relationIdLoader.load(rawResults)\r\n            const rawRelationCountResults = await relationCountLoader.load(\r\n                rawResults,\r\n            )\r\n            const transformer = new RawSqlResultsToEntityTransformer(\r\n                this.expressionMap,\r\n                this.connection.driver,\r\n                rawRelationIdResults,\r\n                rawRelationCountResults,\r\n                this.queryRunner,\r\n            )\r\n            entities = transformer.transform(\r\n                rawResults,\r\n                this.expressionMap.mainAlias!,\r\n            )\r\n\r\n            // broadcast all \"after load\" events\r\n            if (\r\n                this.expressionMap.callListeners === true &&\r\n                this.expressionMap.mainAlias.hasMetadata\r\n            ) {\r\n                await queryRunner.broadcaster.broadcast(\r\n                    \"Load\",\r\n                    this.expressionMap.mainAlias.metadata,\r\n                    entities,\r\n                )\r\n            }\r\n        }\r\n\r\n        if (this.expressionMap.relationLoadStrategy === \"query\") {\r\n            const queryStrategyRelationIdLoader =\r\n                new QueryStrategyRelationIdLoader(this.connection, queryRunner)\r\n\r\n            await Promise.all(\r\n                this.relationMetadatas.map(async (relation) => {\r\n                    const relationTarget = relation.inverseEntityMetadata.target\r\n                    const relationAlias =\r\n                        relation.inverseEntityMetadata.targetName\r\n\r\n                    const select = Array.isArray(this.findOptions.select)\r\n                        ? OrmUtils.propertyPathsToTruthyObject(\r\n                              this.findOptions.select as string[],\r\n                          )\r\n                        : this.findOptions.select\r\n                    const relations = Array.isArray(this.findOptions.relations)\r\n                        ? OrmUtils.propertyPathsToTruthyObject(\r\n                              this.findOptions.relations,\r\n                          )\r\n                        : this.findOptions.relations\r\n\r\n                    const queryBuilder = this.createQueryBuilder(queryRunner)\r\n                        .select(relationAlias)\r\n                        .from(relationTarget, relationAlias)\r\n                        .setFindOptions({\r\n                            select: select\r\n                                ? OrmUtils.deepValue(\r\n                                      select,\r\n                                      relation.propertyPath,\r\n                                  )\r\n                                : undefined,\r\n                            order: this.findOptions.order\r\n                                ? OrmUtils.deepValue(\r\n                                      this.findOptions.order,\r\n                                      relation.propertyPath,\r\n                                  )\r\n                                : undefined,\r\n                            relations: relations\r\n                                ? OrmUtils.deepValue(\r\n                                      relations,\r\n                                      relation.propertyPath,\r\n                                  )\r\n                                : undefined,\r\n                            withDeleted: this.findOptions.withDeleted,\r\n                            relationLoadStrategy:\r\n                                this.findOptions.relationLoadStrategy,\r\n                        })\r\n                    if (entities.length > 0) {\r\n                        const relatedEntityGroups: any[] =\r\n                            await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(\r\n                                relation,\r\n                                entities,\r\n                                undefined,\r\n                                queryBuilder,\r\n                            )\r\n                        entities.forEach((entity) => {\r\n                            const relatedEntityGroup = relatedEntityGroups.find(\r\n                                (group) => group.entity === entity,\r\n                            )\r\n                            if (relatedEntityGroup) {\r\n                                const value =\r\n                                    relatedEntityGroup.related === undefined\r\n                                        ? null\r\n                                        : relatedEntityGroup.related\r\n                                relation.setEntityValue(entity, value)\r\n                            }\r\n                        })\r\n                    }\r\n                }),\r\n            )\r\n        }\r\n\r\n        return {\r\n            raw: rawResults,\r\n            entities: entities,\r\n        }\r\n    }\r\n\r\n    protected createOrderByCombinedWithSelectExpression(\r\n        parentAlias: string,\r\n    ): [string, OrderByCondition] {\r\n        // if table has a default order then apply it\r\n        const orderBys = this.expressionMap.allOrderBys\r\n        const selectString = Object.keys(orderBys)\r\n            .map((orderCriteria) => {\r\n                if (orderCriteria.indexOf(\".\") !== -1) {\r\n                    const criteriaParts = orderCriteria.split(\".\")\r\n                    const aliasName = criteriaParts[0]\r\n                    const propertyPath = criteriaParts.slice(1).join(\".\")\r\n                    const alias = this.expressionMap.findAliasByName(aliasName)\r\n                    const column =\r\n                        alias.metadata.findColumnWithPropertyPath(propertyPath)\r\n                    return (\r\n                        this.escape(parentAlias) +\r\n                        \".\" +\r\n                        this.escape(\r\n                            DriverUtils.buildAlias(\r\n                                this.connection.driver,\r\n                                undefined,\r\n                                aliasName,\r\n                                column!.databaseName,\r\n                            ),\r\n                        )\r\n                    )\r\n                } else {\r\n                    if (\r\n                        this.expressionMap.selects.find(\r\n                            (select) =>\r\n                                select.selection === orderCriteria ||\r\n                                select.aliasName === orderCriteria,\r\n                        )\r\n                    )\r\n                        return (\r\n                            this.escape(parentAlias) +\r\n                            \".\" +\r\n                            this.escape(orderCriteria)\r\n                        )\r\n\r\n                    return \"\"\r\n                }\r\n            })\r\n            .join(\", \")\r\n\r\n        const orderByObject: OrderByCondition = {}\r\n        Object.keys(orderBys).forEach((orderCriteria) => {\r\n            if (orderCriteria.indexOf(\".\") !== -1) {\r\n                const criteriaParts = orderCriteria.split(\".\")\r\n                const aliasName = criteriaParts[0]\r\n                const propertyPath = criteriaParts.slice(1).join(\".\")\r\n                const alias = this.expressionMap.findAliasByName(aliasName)\r\n                const column =\r\n                    alias.metadata.findColumnWithPropertyPath(propertyPath)\r\n                orderByObject[\r\n                    this.escape(parentAlias) +\r\n                        \".\" +\r\n                        this.escape(\r\n                            DriverUtils.buildAlias(\r\n                                this.connection.driver,\r\n                                undefined,\r\n                                aliasName,\r\n                                column!.databaseName,\r\n                            ),\r\n                        )\r\n                ] = orderBys[orderCriteria]\r\n            } else {\r\n                if (\r\n                    this.expressionMap.selects.find(\r\n                        (select) =>\r\n                            select.selection === orderCriteria ||\r\n                            select.aliasName === orderCriteria,\r\n                    )\r\n                ) {\r\n                    orderByObject[\r\n                        this.escape(parentAlias) +\r\n                            \".\" +\r\n                            this.escape(orderCriteria)\r\n                    ] = orderBys[orderCriteria]\r\n                } else {\r\n                    orderByObject[orderCriteria] = orderBys[orderCriteria]\r\n                }\r\n            }\r\n        })\r\n\r\n        return [selectString, orderByObject]\r\n    }\r\n\r\n    /**\r\n     * Loads raw results from the database.\r\n     */\r\n    protected async loadRawResults(queryRunner: QueryRunner) {\r\n        const [sql, parameters] = this.getQueryAndParameters()\r\n        const queryId =\r\n            sql +\r\n            \" -- PARAMETERS: \" +\r\n            JSON.stringify(parameters, (_, value) =>\r\n                typeof value === \"bigint\" ? value.toString() : value,\r\n            )\r\n        const cacheOptions =\r\n            typeof this.connection.options.cache === \"object\"\r\n                ? this.connection.options.cache\r\n                : {}\r\n        let savedQueryResultCacheOptions: QueryResultCacheOptions | undefined =\r\n            undefined\r\n        const isCachingEnabled =\r\n            // Caching is enabled globally and isn't disabled locally.\r\n            (cacheOptions.alwaysEnabled &&\r\n                this.expressionMap.cache !== false) ||\r\n            // ...or it's enabled locally explicitly.\r\n            this.expressionMap.cache === true\r\n        let cacheError = false\r\n        if (this.connection.queryResultCache && isCachingEnabled) {\r\n            try {\r\n                savedQueryResultCacheOptions =\r\n                    await this.connection.queryResultCache.getFromCache(\r\n                        {\r\n                            identifier: this.expressionMap.cacheId,\r\n                            query: queryId,\r\n                            duration:\r\n                                this.expressionMap.cacheDuration ||\r\n                                cacheOptions.duration ||\r\n                                1000,\r\n                        },\r\n                        queryRunner,\r\n                    )\r\n                if (\r\n                    savedQueryResultCacheOptions &&\r\n                    !this.connection.queryResultCache.isExpired(\r\n                        savedQueryResultCacheOptions,\r\n                    )\r\n                ) {\r\n                    return JSON.parse(savedQueryResultCacheOptions.result)\r\n                }\r\n            } catch (error) {\r\n                if (!cacheOptions.ignoreErrors) {\r\n                    throw error\r\n                }\r\n                cacheError = true\r\n            }\r\n        }\r\n\r\n        const results = await queryRunner.query(sql, parameters, true)\r\n\r\n        if (\r\n            !cacheError &&\r\n            this.connection.queryResultCache &&\r\n            isCachingEnabled\r\n        ) {\r\n            try {\r\n                await this.connection.queryResultCache.storeInCache(\r\n                    {\r\n                        identifier: this.expressionMap.cacheId,\r\n                        query: queryId,\r\n                        time: new Date().getTime(),\r\n                        duration:\r\n                            this.expressionMap.cacheDuration ||\r\n                            cacheOptions.duration ||\r\n                            1000,\r\n                        result: JSON.stringify(results.records),\r\n                    },\r\n                    savedQueryResultCacheOptions,\r\n                    queryRunner,\r\n                )\r\n            } catch (error) {\r\n                if (!cacheOptions.ignoreErrors) {\r\n                    throw error\r\n                }\r\n            }\r\n        }\r\n\r\n        return results.records\r\n    }\r\n\r\n    /**\r\n     * Merges into expression map given expression map properties.\r\n     */\r\n    protected mergeExpressionMap(\r\n        expressionMap: Partial<QueryExpressionMap>,\r\n    ): this {\r\n        ObjectUtils.assign(this.expressionMap, expressionMap)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Normalizes a give number - converts to int if possible.\r\n     */\r\n    protected normalizeNumber(num: any) {\r\n        if (typeof num === \"number\" || num === undefined || num === null)\r\n            return num\r\n\r\n        return Number(num)\r\n    }\r\n\r\n    /**\r\n     * Creates a query builder used to execute sql queries inside this query builder.\r\n     */\r\n    protected obtainQueryRunner() {\r\n        return (\r\n            this.queryRunner ||\r\n            this.connection.createQueryRunner(\r\n                this.connection.defaultReplicationModeForReads(),\r\n            )\r\n        )\r\n    }\r\n\r\n    protected buildSelect(\r\n        select: FindOptionsSelect<any>,\r\n        metadata: EntityMetadata,\r\n        alias: string,\r\n        embedPrefix?: string,\r\n    ) {\r\n        for (let key in select) {\r\n            if (select[key] === undefined || select[key] === false) continue\r\n\r\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\r\n            const column =\r\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\r\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\r\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\r\n\r\n            if (!embed && !column && !relation)\r\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\r\n\r\n            if (column) {\r\n                this.selects.push(alias + \".\" + propertyPath)\r\n                // this.addSelect(alias + \".\" + propertyPath);\r\n            } else if (embed) {\r\n                this.buildSelect(\r\n                    select[key] as FindOptionsSelect<any>,\r\n                    metadata,\r\n                    alias,\r\n                    propertyPath,\r\n                )\r\n\r\n                // } else if (relation) {\r\n                //     const joinAlias = alias + \"_\" + relation.propertyName;\r\n                //     const existJoin = this.joins.find(join => join.alias === joinAlias);\r\n                //     if (!existJoin) {\r\n                //         this.joins.push({\r\n                //             type: \"left\",\r\n                //             select: false,\r\n                //             alias: joinAlias,\r\n                //             parentAlias: alias,\r\n                //             relationMetadata: relation\r\n                //         });\r\n                //     }\r\n                //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected buildRelations(\r\n        relations: FindOptionsRelations<any>,\r\n        selection: FindOptionsSelect<any> | undefined,\r\n        metadata: EntityMetadata,\r\n        alias: string,\r\n        embedPrefix?: string,\r\n    ) {\r\n        if (!relations) return\r\n\r\n        Object.keys(relations).forEach((relationName) => {\r\n            const relationValue = (relations as any)[relationName]\r\n            const propertyPath = embedPrefix\r\n                ? embedPrefix + \".\" + relationName\r\n                : relationName\r\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\r\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\r\n            if (!embed && !relation)\r\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\r\n\r\n            if (embed) {\r\n                this.buildRelations(\r\n                    relationValue,\r\n                    typeof selection === \"object\"\r\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\r\n                        : undefined,\r\n                    metadata,\r\n                    alias,\r\n                    propertyPath,\r\n                )\r\n            } else if (relation) {\r\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\r\n                joinAlias = DriverUtils.buildAlias(\r\n                    this.connection.driver,\r\n                    { joiner: \"__\" },\r\n                    alias,\r\n                    joinAlias,\r\n                )\r\n                if (\r\n                    relationValue === true ||\r\n                    typeof relationValue === \"object\"\r\n                ) {\r\n                    if (this.expressionMap.relationLoadStrategy === \"query\") {\r\n                        this.concatRelationMetadata(relation)\r\n                    } else {\r\n                        // join\r\n                        this.joins.push({\r\n                            type: \"left\",\r\n                            select: true,\r\n                            selection:\r\n                                selection &&\r\n                                typeof selection[relationName] === \"object\"\r\n                                    ? (selection[\r\n                                          relationName\r\n                                      ] as FindOptionsSelect<any>)\r\n                                    : undefined,\r\n                            alias: joinAlias,\r\n                            parentAlias: alias,\r\n                            relationMetadata: relation,\r\n                        })\r\n\r\n                        if (\r\n                            selection &&\r\n                            typeof selection[relationName] === \"object\"\r\n                        ) {\r\n                            this.buildSelect(\r\n                                selection[\r\n                                    relationName\r\n                                ] as FindOptionsSelect<any>,\r\n                                relation.inverseEntityMetadata,\r\n                                joinAlias,\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    typeof relationValue === \"object\" &&\r\n                    this.expressionMap.relationLoadStrategy === \"join\"\r\n                ) {\r\n                    this.buildRelations(\r\n                        relationValue,\r\n                        typeof selection === \"object\"\r\n                            ? OrmUtils.deepValue(\r\n                                  selection,\r\n                                  relation.propertyPath,\r\n                              )\r\n                            : undefined,\r\n                        relation.inverseEntityMetadata,\r\n                        joinAlias,\r\n                        undefined,\r\n                    )\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    protected buildEagerRelations(\r\n        relations: FindOptionsRelations<any>,\r\n        selection: FindOptionsSelect<any> | undefined,\r\n        metadata: EntityMetadata,\r\n        alias: string,\r\n        embedPrefix?: string,\r\n    ) {\r\n        if (!relations) return\r\n\r\n        Object.keys(relations).forEach((relationName) => {\r\n            const relationValue = (relations as any)[relationName]\r\n            const propertyPath = embedPrefix\r\n                ? embedPrefix + \".\" + relationName\r\n                : relationName\r\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\r\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\r\n            if (!embed && !relation)\r\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\r\n\r\n            if (embed) {\r\n                this.buildEagerRelations(\r\n                    relationValue,\r\n                    typeof selection === \"object\"\r\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\r\n                        : undefined,\r\n                    metadata,\r\n                    alias,\r\n                    propertyPath,\r\n                )\r\n            } else if (relation) {\r\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\r\n                joinAlias = DriverUtils.buildAlias(\r\n                    this.connection.driver,\r\n                    { joiner: \"__\" },\r\n                    alias,\r\n                    joinAlias,\r\n                )\r\n\r\n                if (\r\n                    relationValue === true ||\r\n                    typeof relationValue === \"object\"\r\n                ) {\r\n                    relation.inverseEntityMetadata.eagerRelations.forEach(\r\n                        (eagerRelation) => {\r\n                            let eagerRelationJoinAlias =\r\n                                joinAlias +\r\n                                \"_\" +\r\n                                eagerRelation.propertyPath.replace(\".\", \"_\")\r\n                            eagerRelationJoinAlias = DriverUtils.buildAlias(\r\n                                this.connection.driver,\r\n                                { joiner: \"__\" },\r\n                                joinAlias,\r\n                                eagerRelationJoinAlias,\r\n                            )\r\n\r\n                            const existJoin = this.joins.find(\r\n                                (join) => join.alias === eagerRelationJoinAlias,\r\n                            )\r\n                            if (!existJoin) {\r\n                                this.joins.push({\r\n                                    type: \"left\",\r\n                                    select: true,\r\n                                    alias: eagerRelationJoinAlias,\r\n                                    parentAlias: joinAlias,\r\n                                    selection: undefined,\r\n                                    relationMetadata: eagerRelation,\r\n                                })\r\n                            }\r\n\r\n                            if (\r\n                                selection &&\r\n                                typeof selection[relationName] === \"object\"\r\n                            ) {\r\n                                this.buildSelect(\r\n                                    selection[\r\n                                        relationName\r\n                                    ] as FindOptionsSelect<any>,\r\n                                    relation.inverseEntityMetadata,\r\n                                    joinAlias,\r\n                                )\r\n                            }\r\n                        },\r\n                    )\r\n                }\r\n\r\n                if (typeof relationValue === \"object\") {\r\n                    this.buildEagerRelations(\r\n                        relationValue,\r\n                        typeof selection === \"object\"\r\n                            ? OrmUtils.deepValue(\r\n                                  selection,\r\n                                  relation.propertyPath,\r\n                              )\r\n                            : undefined,\r\n                        relation.inverseEntityMetadata,\r\n                        joinAlias,\r\n                        undefined,\r\n                    )\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    protected buildOrder(\r\n        order: FindOptionsOrder<any>,\r\n        metadata: EntityMetadata,\r\n        alias: string,\r\n        embedPrefix?: string,\r\n    ) {\r\n        for (let key in order) {\r\n            if (order[key] === undefined) continue\r\n\r\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\r\n            const column =\r\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\r\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\r\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\r\n\r\n            if (!embed && !column && !relation)\r\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\r\n\r\n            if (column) {\r\n                let direction =\r\n                    typeof order[key] === \"object\"\r\n                        ? (order[key] as any).direction\r\n                        : order[key]\r\n                direction =\r\n                    direction === \"DESC\" ||\r\n                    direction === \"desc\" ||\r\n                    direction === -1\r\n                        ? \"DESC\"\r\n                        : \"ASC\"\r\n                let nulls =\r\n                    typeof order[key] === \"object\"\r\n                        ? (order[key] as any).nulls\r\n                        : undefined\r\n                nulls =\r\n                    nulls?.toLowerCase() === \"first\"\r\n                        ? \"NULLS FIRST\"\r\n                        : nulls?.toLowerCase() === \"last\"\r\n                        ? \"NULLS LAST\"\r\n                        : undefined\r\n\r\n                let aliasPath = `${alias}.${propertyPath}`\r\n                // const selection = this.expressionMap.selects.find(\r\n                //     (s) => s.selection === aliasPath,\r\n                // )\r\n                // if (selection) {\r\n                //     // this is not building correctly now???\r\n                //     aliasPath = this.escape(\r\n                //         DriverUtils.buildAlias(\r\n                //             this.connection.driver,\r\n                //             undefined,\r\n                //             alias,\r\n                //             column.databaseName,\r\n                //         ),\r\n                //     )\r\n                //     // selection.aliasName = aliasPath\r\n                // } else {\r\n                //     if (column.isVirtualProperty && column.query) {\r\n                //         aliasPath = `(${column.query(alias)})`\r\n                //     }\r\n                // }\r\n\r\n                // console.log(\"add sort\", selection, aliasPath, direction, nulls)\r\n                this.addOrderBy(aliasPath, direction, nulls)\r\n                // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\r\n            } else if (embed) {\r\n                this.buildOrder(\r\n                    order[key] as FindOptionsOrder<any>,\r\n                    metadata,\r\n                    alias,\r\n                    propertyPath,\r\n                )\r\n            } else if (relation) {\r\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\r\n                joinAlias = DriverUtils.buildAlias(\r\n                    this.connection.driver,\r\n                    { joiner: \"__\" },\r\n                    alias,\r\n                    joinAlias,\r\n                )\r\n                // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\r\n                // todo: use expressionMap.joinAttributes, and create a new one using\r\n                //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\r\n\r\n                const existJoin = this.joins.find(\r\n                    (join) => join.alias === joinAlias,\r\n                )\r\n                if (!existJoin) {\r\n                    this.joins.push({\r\n                        type: \"left\",\r\n                        select: false,\r\n                        alias: joinAlias,\r\n                        parentAlias: alias,\r\n                        selection: undefined,\r\n                        relationMetadata: relation,\r\n                    })\r\n                }\r\n                this.buildOrder(\r\n                    order[key] as FindOptionsOrder<any>,\r\n                    relation.inverseEntityMetadata,\r\n                    joinAlias,\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    protected buildWhere(\r\n        where: FindOptionsWhere<any>[] | FindOptionsWhere<any>,\r\n        metadata: EntityMetadata,\r\n        alias: string,\r\n        embedPrefix?: string,\r\n    ) {\r\n        let condition: string = \"\"\r\n        // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\r\n        if (Array.isArray(where)) {\r\n            if (where.length) {\r\n                condition = where\r\n                    .map((whereItem) => {\r\n                        return this.buildWhere(\r\n                            whereItem,\r\n                            metadata,\r\n                            alias,\r\n                            embedPrefix,\r\n                        )\r\n                    })\r\n                    .filter((condition) => !!condition)\r\n                    .map((condition) => \"(\" + condition + \")\")\r\n                    .join(\" OR \")\r\n            }\r\n        } else {\r\n            let andConditions: string[] = []\r\n            for (let key in where) {\r\n                if (where[key] === undefined || where[key] === null) continue\r\n\r\n                const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\r\n                const column =\r\n                    metadata.findColumnWithPropertyPathStrict(propertyPath)\r\n                const embed =\r\n                    metadata.findEmbeddedWithPropertyPath(propertyPath)\r\n                const relation =\r\n                    metadata.findRelationWithPropertyPath(propertyPath)\r\n\r\n                if (!embed && !column && !relation)\r\n                    throw new EntityPropertyNotFoundError(\r\n                        propertyPath,\r\n                        metadata,\r\n                    )\r\n\r\n                if (column) {\r\n                    let aliasPath = `${alias}.${propertyPath}`\r\n                    if (column.isVirtualProperty && column.query) {\r\n                        aliasPath = `(${column.query(alias)})`\r\n                    }\r\n                    // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\r\n\r\n                    // todo: we need to handle other operators as well?\r\n                    let parameterValue = where[key]\r\n                    if (InstanceChecker.isEqualOperator(where[key])) {\r\n                        parameterValue = where[key].value\r\n                    }\r\n                    if (column.transformer) {\r\n                        parameterValue instanceof FindOperator\r\n                            ? parameterValue.transformValue(column.transformer)\r\n                            : (parameterValue =\r\n                                  ApplyValueTransformers.transformTo(\r\n                                      column.transformer,\r\n                                      parameterValue,\r\n                                  ))\r\n                    }\r\n\r\n                    // if (parameterValue === null) {\r\n                    //     andConditions.push(`${aliasPath} IS NULL`);\r\n                    //\r\n                    // } else if (parameterValue instanceof FindOperator) {\r\n                    //     // let parameters: any[] = [];\r\n                    //     // if (parameterValue.useParameter) {\r\n                    //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\r\n                    //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\r\n                    //     //\r\n                    //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\r\n                    //     //         if (typeof realParameterValue === \"number\") {\r\n                    //     //             parameters.push(realParameterValue);\r\n                    //     //\r\n                    //     //         } else {\r\n                    //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\r\n                    //     //             parameterIndex++;\r\n                    //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\r\n                    //     //         }\r\n                    //     //     });\r\n                    //     // }\r\n                    //     andConditions.push(\r\n                    //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\r\n                    //         // parameterValue.toSql(this.connection, aliasPath, parameters));\r\n                    //     )\r\n                    //\r\n                    // } else {\r\n                    //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\r\n                    //     parameterIndex++;\r\n                    //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\r\n                    //     andConditions.push(`${aliasPath} = ${parameter}`);\r\n                    // }\r\n\r\n                    andConditions.push(\r\n                        this.createWhereConditionExpression(\r\n                            this.getWherePredicateCondition(\r\n                                aliasPath,\r\n                                parameterValue,\r\n                            ),\r\n                        ),\r\n                        // parameterValue.toSql(this.connection, aliasPath, parameters));\r\n                    )\r\n\r\n                    // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\r\n                    // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\r\n                } else if (embed) {\r\n                    const condition = this.buildWhere(\r\n                        where[key],\r\n                        metadata,\r\n                        alias,\r\n                        propertyPath,\r\n                    )\r\n                    if (condition) andConditions.push(condition)\r\n                } else if (relation) {\r\n                    // if all properties of where are undefined we don't need to join anything\r\n                    // this can happen when user defines map with conditional queries inside\r\n                    if (typeof where[key] === \"object\") {\r\n                        const allAllUndefined = Object.keys(where[key]).every(\r\n                            (k) => where[key][k] === undefined,\r\n                        )\r\n                        if (allAllUndefined) {\r\n                            continue\r\n                        }\r\n                    }\r\n\r\n                    if (InstanceChecker.isFindOperator(where[key])) {\r\n                        if (\r\n                            where[key].type === \"moreThan\" ||\r\n                            where[key].type === \"lessThan\" ||\r\n                            where[key].type === \"moreThanOrEqual\" ||\r\n                            where[key].type === \"lessThanOrEqual\"\r\n                        ) {\r\n                            let sqlOperator = \"\"\r\n                            if (where[key].type === \"moreThan\") {\r\n                                sqlOperator = \">\"\r\n                            } else if (where[key].type === \"lessThan\") {\r\n                                sqlOperator = \"<\"\r\n                            } else if (where[key].type === \"moreThanOrEqual\") {\r\n                                sqlOperator = \">=\"\r\n                            } else if (where[key].type === \"lessThanOrEqual\") {\r\n                                sqlOperator = \"<=\"\r\n                            }\r\n                            // basically relation count functionality\r\n                            const qb: QueryBuilder<any> = this.subQuery()\r\n                            if (relation.isManyToManyOwner) {\r\n                                qb.select(\"COUNT(*)\")\r\n                                    .from(\r\n                                        relation.joinTableName,\r\n                                        relation.joinTableName,\r\n                                    )\r\n                                    .where(\r\n                                        relation.joinColumns\r\n                                            .map((column) => {\r\n                                                return `${\r\n                                                    relation.joinTableName\r\n                                                }.${\r\n                                                    column.propertyName\r\n                                                } = ${alias}.${\r\n                                                    column.referencedColumn!\r\n                                                        .propertyName\r\n                                                }`\r\n                                            })\r\n                                            .join(\" AND \"),\r\n                                    )\r\n                            } else if (relation.isManyToManyNotOwner) {\r\n                                qb.select(\"COUNT(*)\")\r\n                                    .from(\r\n                                        relation.inverseRelation!.joinTableName,\r\n                                        relation.inverseRelation!.joinTableName,\r\n                                    )\r\n                                    .where(\r\n                                        relation\r\n                                            .inverseRelation!.inverseJoinColumns.map(\r\n                                                (column) => {\r\n                                                    return `${\r\n                                                        relation.inverseRelation!\r\n                                                            .joinTableName\r\n                                                    }.${\r\n                                                        column.propertyName\r\n                                                    } = ${alias}.${\r\n                                                        column.referencedColumn!\r\n                                                            .propertyName\r\n                                                    }`\r\n                                                },\r\n                                            )\r\n                                            .join(\" AND \"),\r\n                                    )\r\n                            } else if (relation.isOneToMany) {\r\n                                qb.select(\"COUNT(*)\")\r\n                                    .from(\r\n                                        relation.inverseEntityMetadata.target,\r\n                                        relation.inverseEntityMetadata\r\n                                            .tableName,\r\n                                    )\r\n                                    .where(\r\n                                        relation\r\n                                            .inverseRelation!.joinColumns.map(\r\n                                                (column) => {\r\n                                                    return `${\r\n                                                        relation\r\n                                                            .inverseEntityMetadata\r\n                                                            .tableName\r\n                                                    }.${\r\n                                                        column.propertyName\r\n                                                    } = ${alias}.${\r\n                                                        column.referencedColumn!\r\n                                                            .propertyName\r\n                                                    }`\r\n                                                },\r\n                                            )\r\n                                            .join(\" AND \"),\r\n                                    )\r\n                            } else {\r\n                                throw new Error(\r\n                                    `This relation isn't supported by given find operator`,\r\n                                )\r\n                            }\r\n                            // this\r\n                            //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\r\n                            //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\r\n                            this.andWhere(\r\n                                qb.getSql() +\r\n                                    \" \" +\r\n                                    sqlOperator +\r\n                                    \" \" +\r\n                                    parseInt(where[key].value),\r\n                            )\r\n                        } else {\r\n                            if (\r\n                                relation.isManyToOne ||\r\n                                (relation.isOneToOne &&\r\n                                    relation.isOneToOneOwner)\r\n                            ) {\r\n                                const aliasPath = `${alias}.${propertyPath}`\r\n\r\n                                andConditions.push(\r\n                                    this.createWhereConditionExpression(\r\n                                        this.getWherePredicateCondition(\r\n                                            aliasPath,\r\n                                            where[key],\r\n                                        ),\r\n                                    ),\r\n                                )\r\n                            } else {\r\n                                throw new Error(\r\n                                    `This relation isn't supported by given find operator`,\r\n                                )\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // const joinAlias = alias + \"_\" + relation.propertyName;\r\n                        let joinAlias =\r\n                            alias +\r\n                            \"_\" +\r\n                            relation.propertyPath.replace(\".\", \"_\")\r\n                        joinAlias = DriverUtils.buildAlias(\r\n                            this.connection.driver,\r\n                            { joiner: \"__\" },\r\n                            alias,\r\n                            joinAlias,\r\n                        )\r\n\r\n                        const existJoin = this.joins.find(\r\n                            (join) => join.alias === joinAlias,\r\n                        )\r\n                        if (!existJoin) {\r\n                            this.joins.push({\r\n                                type: \"left\",\r\n                                select: false,\r\n                                selection: undefined,\r\n                                alias: joinAlias,\r\n                                parentAlias: alias,\r\n                                relationMetadata: relation,\r\n                            })\r\n                        }\r\n\r\n                        const condition = this.buildWhere(\r\n                            where[key],\r\n                            relation.inverseEntityMetadata,\r\n                            joinAlias,\r\n                        )\r\n                        if (condition) {\r\n                            andConditions.push(condition)\r\n                            // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            condition = andConditions.length\r\n                ? \"(\" + andConditions.join(\") AND (\") + \")\"\r\n                : andConditions.join(\" AND \")\r\n        }\r\n        return condition.length ? \"(\" + condition + \")\" : condition\r\n    }\r\n}\r\n"],"sourceRoot":".."}