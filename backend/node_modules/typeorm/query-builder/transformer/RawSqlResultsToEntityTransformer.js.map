{"version":3,"sources":["../../src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts"],"names":[],"mappings":"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","file":"RawSqlResultsToEntityTransformer.js","sourcesContent":["import { Driver } from \"../../driver/Driver\"\r\nimport { RelationIdLoadResult } from \"../relation-id/RelationIdLoadResult\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\r\nimport { Alias } from \"../Alias\"\r\nimport { RelationCountLoadResult } from \"../relation-count/RelationCountLoadResult\"\r\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\r\nimport { OrmUtils } from \"../../util/OrmUtils\"\r\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\r\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\r\nimport { QueryRunner } from \"../..\"\r\nimport { DriverUtils } from \"../../driver/DriverUtils\"\r\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\r\n\r\n/**\r\n * Transforms raw sql results returned from the database into entity object.\r\n * Entity is constructed based on its entity metadata.\r\n */\r\nexport class RawSqlResultsToEntityTransformer {\r\n    /**\r\n     * Contains a hashmap for every rawRelationIdResults given.\r\n     * In the hashmap you will find the idMaps of a result under the hash of this.hashEntityIds for the result.\r\n     */\r\n    private relationIdMaps: Array<{ [idHash: string]: any[] }>\r\n\r\n    private pojo: boolean\r\n    private selections: Set<string>\r\n    private aliasCache: Map<string, Map<string, string>>\r\n    private columnsCache: Map<\r\n        string,\r\n        Map<EntityMetadata, [string, ColumnMetadata][]>\r\n    >\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        protected expressionMap: QueryExpressionMap,\r\n        protected driver: Driver,\r\n        protected rawRelationIdResults: RelationIdLoadResult[],\r\n        protected rawRelationCountResults: RelationCountLoadResult[],\r\n        protected queryRunner?: QueryRunner,\r\n    ) {\r\n        this.pojo = this.expressionMap.options.includes(\"create-pojo\")\r\n        this.selections = new Set(\r\n            this.expressionMap.selects.map((s) => s.selection),\r\n        )\r\n        this.aliasCache = new Map()\r\n        this.columnsCache = new Map()\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\r\n     * we need to group our result and we must have some unique id (primary key in our case)\r\n     */\r\n    transform(rawResults: any[], alias: Alias): any[] {\r\n        const group = this.group(rawResults, alias)\r\n        const entities: any[] = []\r\n        for (const results of group.values()) {\r\n            const entity = this.transformRawResultsGroup(results, alias)\r\n            if (entity !== undefined) entities.push(entity)\r\n        }\r\n        return entities\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Build an alias from a name and column name.\r\n     */\r\n    protected buildAlias(aliasName: string, columnName: string) {\r\n        let aliases = this.aliasCache.get(aliasName)\r\n        if (!aliases) {\r\n            aliases = new Map()\r\n            this.aliasCache.set(aliasName, aliases)\r\n        }\r\n        let columnAlias = aliases.get(columnName)\r\n        if (!columnAlias) {\r\n            columnAlias = DriverUtils.buildAlias(\r\n                this.driver,\r\n                undefined,\r\n                aliasName,\r\n                columnName,\r\n            )\r\n            aliases.set(columnName, columnAlias)\r\n        }\r\n        return columnAlias\r\n    }\r\n\r\n    /**\r\n     * Groups given raw results by ids of given alias.\r\n     */\r\n    protected group(rawResults: any[], alias: Alias): Map<string, any[]> {\r\n        const map = new Map()\r\n        const keys: string[] = []\r\n        if (alias.metadata.tableType === \"view\") {\r\n            keys.push(\r\n                ...alias.metadata.columns.map((column) =>\r\n                    this.buildAlias(alias.name, column.databaseName),\r\n                ),\r\n            )\r\n        } else {\r\n            keys.push(\r\n                ...alias.metadata.primaryColumns.map((column) =>\r\n                    this.buildAlias(alias.name, column.databaseName),\r\n                ),\r\n            )\r\n        }\r\n        for (const rawResult of rawResults) {\r\n            const id = keys\r\n                .map((key) => {\r\n                    const keyValue = rawResult[key]\r\n\r\n                    if (Buffer.isBuffer(keyValue)) {\r\n                        return keyValue.toString(\"hex\")\r\n                    }\r\n\r\n                    if (ObjectUtils.isObject(keyValue)) {\r\n                        return JSON.stringify(keyValue)\r\n                    }\r\n\r\n                    return keyValue\r\n                })\r\n                .join(\"_\") // todo: check partial\r\n\r\n            const items = map.get(id)\r\n            if (!items) {\r\n                map.set(id, [rawResult])\r\n            } else {\r\n                items.push(rawResult)\r\n            }\r\n        }\r\n        return map\r\n    }\r\n\r\n    /**\r\n     * Transforms set of data results into single entity.\r\n     */\r\n    protected transformRawResultsGroup(\r\n        rawResults: any[],\r\n        alias: Alias,\r\n    ): ObjectLiteral | undefined {\r\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\r\n        let metadata = alias.metadata\r\n\r\n        if (metadata.discriminatorColumn) {\r\n            const discriminatorValues = rawResults.map(\r\n                (result) =>\r\n                    result[\r\n                        this.buildAlias(\r\n                            alias.name,\r\n                            alias.metadata.discriminatorColumn!.databaseName,\r\n                        )\r\n                    ],\r\n            )\r\n            const discriminatorMetadata = metadata.childEntityMetadatas.find(\r\n                (childEntityMetadata) => {\r\n                    return (\r\n                        typeof discriminatorValues.find(\r\n                            (value) =>\r\n                                value ===\r\n                                childEntityMetadata.discriminatorValue,\r\n                        ) !== \"undefined\"\r\n                    )\r\n                },\r\n            )\r\n            if (discriminatorMetadata) metadata = discriminatorMetadata\r\n        }\r\n        let entity: any = metadata.create(this.queryRunner, {\r\n            fromDeserializer: true,\r\n            pojo: this.pojo,\r\n        })\r\n\r\n        // get value from columns selections and put them into newly created entity\r\n        const hasColumns = this.transformColumns(\r\n            rawResults,\r\n            alias,\r\n            entity,\r\n            metadata,\r\n        )\r\n        const hasRelations = this.transformJoins(\r\n            rawResults,\r\n            entity,\r\n            alias,\r\n            metadata,\r\n        )\r\n        const hasRelationIds = this.transformRelationIds(\r\n            rawResults,\r\n            alias,\r\n            entity,\r\n            metadata,\r\n        )\r\n        const hasRelationCounts = this.transformRelationCounts(\r\n            rawResults,\r\n            alias,\r\n            entity,\r\n        )\r\n\r\n        // if we have at least one selected column then return this entity\r\n        // since entity must have at least primary columns to be really selected and transformed into entity\r\n        if (hasColumns) return entity\r\n\r\n        // if we don't have any selected column we should not return entity,\r\n        // except for the case when entity only contain a primary column as a relation to another entity\r\n        // in this case its absolutely possible our entity to not have any columns except a single relation\r\n        const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.every(\r\n            (column) => column.isVirtual === true,\r\n        ) // todo: create metadata.hasOnlyVirtualPrimaryColumns\r\n        if (\r\n            hasOnlyVirtualPrimaryColumns &&\r\n            (hasRelations || hasRelationIds || hasRelationCounts)\r\n        )\r\n            return entity\r\n\r\n        return undefined\r\n    }\r\n\r\n    // get value from columns selections and put them into object\r\n    protected transformColumns(\r\n        rawResults: any[],\r\n        alias: Alias,\r\n        entity: ObjectLiteral,\r\n        metadata: EntityMetadata,\r\n    ): boolean {\r\n        let hasData = false\r\n        const result = rawResults[0]\r\n        for (const [key, column] of this.getColumnsToProcess(\r\n            alias.name,\r\n            metadata,\r\n        )) {\r\n            const value = result[key]\r\n\r\n            if (value === undefined) continue\r\n            // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\r\n            else if (value !== null) hasData = true\r\n\r\n            column.setEntityValue(\r\n                entity,\r\n                this.driver.prepareHydratedValue(value, column),\r\n            )\r\n        }\r\n        return hasData\r\n    }\r\n\r\n    /**\r\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\r\n     */\r\n    protected transformJoins(\r\n        rawResults: any[],\r\n        entity: ObjectLiteral,\r\n        alias: Alias,\r\n        metadata: EntityMetadata,\r\n    ) {\r\n        let hasData = false\r\n\r\n        // let discriminatorValue: string = \"\";\r\n        // if (metadata.discriminatorColumn)\r\n        //     discriminatorValue = rawResults[0][this.buildAlias(alias.name, alias.metadata.discriminatorColumn!.databaseName)];\r\n\r\n        for (const join of this.expressionMap.joinAttributes) {\r\n            // todo: we have problem here - when inner joins are used without selects it still create empty array\r\n\r\n            // skip joins without metadata\r\n            if (!join.metadata) continue\r\n\r\n            // if simple left or inner join was performed without selection then we don't need to do anything\r\n            if (!join.isSelected) continue\r\n\r\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\r\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\r\n            if (\r\n                join.relation &&\r\n                !metadata.relations.find(\r\n                    (relation) => relation === join.relation,\r\n                )\r\n            )\r\n                continue\r\n\r\n            // some checks to make sure this join is for current alias\r\n            if (join.mapToProperty) {\r\n                if (join.mapToPropertyParentAlias !== alias.name) continue\r\n            } else {\r\n                if (\r\n                    !join.relation ||\r\n                    join.parentAlias !== alias.name ||\r\n                    join.relationPropertyPath !== join.relation!.propertyPath\r\n                )\r\n                    continue\r\n            }\r\n\r\n            // transform joined data into entities\r\n            let result: any = this.transform(rawResults, join.alias)\r\n            result = !join.isMany ? result[0] : result\r\n            result = !join.isMany && result === undefined ? null : result // this is needed to make relations to return null when its joined but nothing was found in the database\r\n            // if nothing was joined then simply continue\r\n            if (result === undefined) continue\r\n\r\n            // if join was mapped to some property then save result to that property\r\n            if (join.mapToPropertyPropertyName) {\r\n                entity[join.mapToPropertyPropertyName] = result // todo: fix embeds\r\n            } else {\r\n                // otherwise set to relation\r\n                join.relation!.setEntityValue(entity, result)\r\n            }\r\n\r\n            hasData = true\r\n        }\r\n        return hasData\r\n    }\r\n\r\n    protected transformRelationIds(\r\n        rawSqlResults: any[],\r\n        alias: Alias,\r\n        entity: ObjectLiteral,\r\n        metadata: EntityMetadata,\r\n    ): boolean {\r\n        let hasData = false\r\n        for (const [\r\n            index,\r\n            rawRelationIdResult,\r\n        ] of this.rawRelationIdResults.entries()) {\r\n            if (\r\n                rawRelationIdResult.relationIdAttribute.parentAlias !==\r\n                alias.name\r\n            )\r\n                continue\r\n\r\n            const relation = rawRelationIdResult.relationIdAttribute.relation\r\n            const valueMap = this.createValueMapFromJoinColumns(\r\n                relation,\r\n                rawRelationIdResult.relationIdAttribute.parentAlias,\r\n                rawSqlResults,\r\n            )\r\n            if (valueMap === undefined || valueMap === null) {\r\n                continue\r\n            }\r\n\r\n            // prepare common data for this call\r\n            this.prepareDataForTransformRelationIds()\r\n\r\n            // Extract idMaps from prepared data by hash\r\n            const hash = this.hashEntityIds(relation, valueMap)\r\n            const idMaps = this.relationIdMaps[index][hash] || []\r\n\r\n            // Map data to properties\r\n            const properties =\r\n                rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\r\n                    \".\",\r\n                )\r\n            const mapToProperty = (\r\n                properties: string[],\r\n                map: ObjectLiteral,\r\n                value: any,\r\n            ): any => {\r\n                const property = properties.shift()\r\n                if (property && properties.length === 0) {\r\n                    map[property] = value\r\n                    return map\r\n                }\r\n                if (property && properties.length > 0) {\r\n                    mapToProperty(properties, map[property], value)\r\n                } else {\r\n                    return map\r\n                }\r\n            }\r\n            if (relation.isOneToOne || relation.isManyToOne) {\r\n                if (idMaps[0] !== undefined) {\r\n                    mapToProperty(properties, entity, idMaps[0])\r\n                    hasData = true\r\n                }\r\n            } else {\r\n                mapToProperty(properties, entity, idMaps)\r\n                hasData = hasData || idMaps.length > 0\r\n            }\r\n        }\r\n\r\n        return hasData\r\n    }\r\n\r\n    protected transformRelationCounts(\r\n        rawSqlResults: any[],\r\n        alias: Alias,\r\n        entity: ObjectLiteral,\r\n    ): boolean {\r\n        let hasData = false\r\n        for (const rawRelationCountResult of this.rawRelationCountResults) {\r\n            if (\r\n                rawRelationCountResult.relationCountAttribute.parentAlias !==\r\n                alias.name\r\n            )\r\n                continue\r\n            const relation =\r\n                rawRelationCountResult.relationCountAttribute.relation\r\n            let referenceColumnName: string\r\n\r\n            if (relation.isOneToMany) {\r\n                referenceColumnName =\r\n                    relation.inverseRelation!.joinColumns[0].referencedColumn!\r\n                        .databaseName // todo: fix joinColumns[0]\r\n            } else {\r\n                referenceColumnName = relation.isOwning\r\n                    ? relation.joinColumns[0].referencedColumn!.databaseName\r\n                    : relation.inverseRelation!.joinColumns[0].referencedColumn!\r\n                          .databaseName\r\n            }\r\n\r\n            const referenceColumnValue =\r\n                rawSqlResults[0][\r\n                    this.buildAlias(alias.name, referenceColumnName)\r\n                ] // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\r\n            if (\r\n                referenceColumnValue !== undefined &&\r\n                referenceColumnValue !== null\r\n            ) {\r\n                entity[\r\n                    rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\r\n                ] = 0\r\n                for (const result of rawRelationCountResult.results) {\r\n                    if (result[\"parentId\"] !== referenceColumnValue) continue\r\n                    entity[\r\n                        rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\r\n                    ] = parseInt(result[\"cnt\"])\r\n                    hasData = true\r\n                }\r\n            }\r\n        }\r\n\r\n        return hasData\r\n    }\r\n\r\n    private getColumnsToProcess(aliasName: string, metadata: EntityMetadata) {\r\n        let metadatas = this.columnsCache.get(aliasName)\r\n        if (!metadatas) {\r\n            metadatas = new Map()\r\n            this.columnsCache.set(aliasName, metadatas)\r\n        }\r\n        let columns = metadatas.get(metadata)\r\n        if (!columns) {\r\n            columns = metadata.columns\r\n                .filter(\r\n                    (column) =>\r\n                        !column.isVirtual &&\r\n                        // if user does not selected the whole entity or he used partial selection and does not select this particular column\r\n                        // then we don't add this column and its value into the entity\r\n                        (this.selections.has(aliasName) ||\r\n                            this.selections.has(\r\n                                `${aliasName}.${column.propertyPath}`,\r\n                            )) &&\r\n                        // if table inheritance is used make sure this column is not child's column\r\n                        !metadata.childEntityMetadatas.some(\r\n                            (childMetadata) =>\r\n                                childMetadata.target === column.target,\r\n                        ),\r\n                )\r\n                .map((column) => [\r\n                    this.buildAlias(aliasName, column.databaseName),\r\n                    column,\r\n                ])\r\n            metadatas.set(metadata, columns)\r\n        }\r\n        return columns\r\n    }\r\n\r\n    private createValueMapFromJoinColumns(\r\n        relation: RelationMetadata,\r\n        parentAlias: string,\r\n        rawSqlResults: any[],\r\n    ): ObjectLiteral {\r\n        let columns: ColumnMetadata[]\r\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n            columns = relation.entityMetadata.primaryColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\r\n            columns = relation.inverseRelation!.joinColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else {\r\n            if (relation.isOwning) {\r\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\r\n            } else {\r\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\r\n                    (joinColumn) => joinColumn,\r\n                )\r\n            }\r\n        }\r\n        return columns.reduce((valueMap, column) => {\r\n            for (const rawSqlResult of rawSqlResults) {\r\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n                    valueMap[column.databaseName] =\r\n                        this.driver.prepareHydratedValue(\r\n                            rawSqlResult[\r\n                                this.buildAlias(\r\n                                    parentAlias,\r\n                                    column.databaseName,\r\n                                )\r\n                            ],\r\n                            column,\r\n                        )\r\n                } else {\r\n                    valueMap[column.databaseName] =\r\n                        this.driver.prepareHydratedValue(\r\n                            rawSqlResult[\r\n                                this.buildAlias(\r\n                                    parentAlias,\r\n                                    column.referencedColumn!.databaseName,\r\n                                )\r\n                            ],\r\n                            column.referencedColumn!,\r\n                        )\r\n                }\r\n            }\r\n            return valueMap\r\n        }, {} as ObjectLiteral)\r\n    }\r\n\r\n    private extractEntityPrimaryIds(\r\n        relation: RelationMetadata,\r\n        relationIdRawResult: any,\r\n    ) {\r\n        let columns: ColumnMetadata[]\r\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n            columns = relation.entityMetadata.primaryColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\r\n            columns = relation.inverseRelation!.joinColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else {\r\n            if (relation.isOwning) {\r\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\r\n            } else {\r\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\r\n                    (joinColumn) => joinColumn,\r\n                )\r\n            }\r\n        }\r\n        return columns.reduce((data, column) => {\r\n            data[column.databaseName] = relationIdRawResult[column.databaseName]\r\n            return data\r\n        }, {} as ObjectLiteral)\r\n    }\r\n\r\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\r\n        const virtualColumns = this.expressionMap.selects\r\n            .filter(select => select.virtual)\r\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\r\n\r\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\r\n    }*/\r\n\r\n    /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\r\n    private prepareDataForTransformRelationIds() {\r\n        // Return early if the relationIdMaps were already calculated\r\n        if (this.relationIdMaps) {\r\n            return\r\n        }\r\n\r\n        // Ensure this prepare function is only called once\r\n        this.relationIdMaps = this.rawRelationIdResults.map(\r\n            (rawRelationIdResult) => {\r\n                const relation =\r\n                    rawRelationIdResult.relationIdAttribute.relation\r\n\r\n                // Calculate column metadata\r\n                let columns: ColumnMetadata[]\r\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n                    columns = relation.joinColumns\r\n                } else if (\r\n                    relation.isOneToMany ||\r\n                    relation.isOneToOneNotOwner\r\n                ) {\r\n                    columns = relation.inverseEntityMetadata.primaryColumns\r\n                } else {\r\n                    // ManyToMany\r\n                    if (relation.isOwning) {\r\n                        columns = relation.inverseJoinColumns\r\n                    } else {\r\n                        columns = relation.inverseRelation!.joinColumns\r\n                    }\r\n                }\r\n\r\n                // Calculate the idMaps for the rawRelationIdResult\r\n                return rawRelationIdResult.results.reduce((agg, result) => {\r\n                    let idMap = columns.reduce((idMap, column) => {\r\n                        let value = result[column.databaseName]\r\n                        if (\r\n                            relation.isOneToMany ||\r\n                            relation.isOneToOneNotOwner\r\n                        ) {\r\n                            if (\r\n                                column.isVirtual &&\r\n                                column.referencedColumn &&\r\n                                column.referencedColumn.propertyName !==\r\n                                    column.propertyName\r\n                            ) {\r\n                                // if column is a relation\r\n                                value =\r\n                                    column.referencedColumn.createValueMap(\r\n                                        value,\r\n                                    )\r\n                            }\r\n\r\n                            return OrmUtils.mergeDeep(\r\n                                idMap,\r\n                                column.createValueMap(value),\r\n                            )\r\n                        }\r\n                        if (\r\n                            !column.isPrimary &&\r\n                            column.referencedColumn!.referencedColumn\r\n                        ) {\r\n                            // if column is a relation\r\n                            value =\r\n                                column.referencedColumn!.referencedColumn!.createValueMap(\r\n                                    value,\r\n                                )\r\n                        }\r\n\r\n                        return OrmUtils.mergeDeep(\r\n                            idMap,\r\n                            column.referencedColumn!.createValueMap(value),\r\n                        )\r\n                    }, {} as ObjectLiteral)\r\n\r\n                    if (\r\n                        columns.length === 1 &&\r\n                        !rawRelationIdResult.relationIdAttribute.disableMixedMap\r\n                    ) {\r\n                        if (\r\n                            relation.isOneToMany ||\r\n                            relation.isOneToOneNotOwner\r\n                        ) {\r\n                            idMap = columns[0].getEntityValue(idMap)\r\n                        } else {\r\n                            idMap =\r\n                                columns[0].referencedColumn!.getEntityValue(\r\n                                    idMap,\r\n                                )\r\n                        }\r\n                    }\r\n\r\n                    // If an idMap is found, set it in the aggregator under the correct hash\r\n                    if (idMap !== undefined) {\r\n                        const hash = this.hashEntityIds(relation, result)\r\n\r\n                        if (agg[hash]) {\r\n                            agg[hash].push(idMap)\r\n                        } else {\r\n                            agg[hash] = [idMap]\r\n                        }\r\n                    }\r\n\r\n                    return agg\r\n                }, {})\r\n            },\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\r\n     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\r\n     * given, a simple JSON.stringify should be enough to get a unique hash per entity!\r\n     */\r\n    private hashEntityIds(relation: RelationMetadata, data: ObjectLiteral) {\r\n        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data)\r\n        return JSON.stringify(entityPrimaryIds)\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}