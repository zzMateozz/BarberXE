{"version":3,"sources":["../../src/query-builder/ReturningResultsEntityUpdator.ts"],"names":[],"mappings":"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","file":"ReturningResultsEntityUpdator.js","sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\r\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\r\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\r\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\r\nimport { UpdateResult } from \"./result/UpdateResult\"\r\nimport { InsertResult } from \"./result/InsertResult\"\r\nimport { TypeORMError } from \"../error\"\r\n\r\n/**\r\n * Updates entity with returning results in the entity insert and update operations.\r\n */\r\nexport class ReturningResultsEntityUpdator {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        protected queryRunner: QueryRunner,\r\n        protected expressionMap: QueryExpressionMap,\r\n    ) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Updates entities with a special columns after updation query execution.\r\n     */\r\n    async update(\r\n        updateResult: UpdateResult,\r\n        entities: ObjectLiteral[],\r\n    ): Promise<void> {\r\n        const metadata = this.expressionMap.mainAlias!.metadata\r\n\r\n        await Promise.all(\r\n            entities.map(async (entity, entityIndex) => {\r\n                // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\r\n                if (\r\n                    this.queryRunner.connection.driver.isReturningSqlSupported(\r\n                        \"update\",\r\n                    )\r\n                ) {\r\n                    if (\r\n                        this.queryRunner.connection.driver.options.type ===\r\n                            \"oracle\" &&\r\n                        Array.isArray(updateResult.raw) &&\r\n                        this.expressionMap.extraReturningColumns.length > 0\r\n                    ) {\r\n                        updateResult.raw = updateResult.raw.reduce(\r\n                            (newRaw, rawItem, rawItemIndex) => {\r\n                                newRaw[\r\n                                    this.expressionMap.extraReturningColumns[\r\n                                        rawItemIndex\r\n                                    ].databaseName\r\n                                ] = rawItem[0]\r\n                                return newRaw\r\n                            },\r\n                            {} as ObjectLiteral,\r\n                        )\r\n                    }\r\n                    const result = Array.isArray(updateResult.raw)\r\n                        ? updateResult.raw[entityIndex]\r\n                        : updateResult.raw\r\n                    const returningColumns =\r\n                        this.queryRunner.connection.driver.createGeneratedMap(\r\n                            metadata,\r\n                            result,\r\n                        )\r\n                    if (returningColumns) {\r\n                        this.queryRunner.manager.merge(\r\n                            metadata.target as any,\r\n                            entity,\r\n                            returningColumns,\r\n                        )\r\n                        updateResult.generatedMaps.push(returningColumns)\r\n                    }\r\n                } else {\r\n                    // for driver which do not support returning/output statement we need to perform separate query and load what we need\r\n                    const updationColumns =\r\n                        this.expressionMap.extraReturningColumns\r\n                    if (updationColumns.length > 0) {\r\n                        // get entity id by which we will get needed data\r\n                        const entityId =\r\n                            this.expressionMap.mainAlias!.metadata.getEntityIdMap(\r\n                                entity,\r\n                            )\r\n                        if (!entityId)\r\n                            throw new TypeORMError(\r\n                                `Cannot update entity because entity id is not set in the entity.`,\r\n                            )\r\n\r\n                        // execute query to get needed data\r\n                        const loadedReturningColumns =\r\n                            (await this.queryRunner.manager\r\n                                .createQueryBuilder()\r\n                                .select(\r\n                                    metadata.primaryColumns.map(\r\n                                        (column) =>\r\n                                            metadata.targetName +\r\n                                            \".\" +\r\n                                            column.propertyPath,\r\n                                    ),\r\n                                )\r\n                                .addSelect(\r\n                                    updationColumns.map(\r\n                                        (column) =>\r\n                                            metadata.targetName +\r\n                                            \".\" +\r\n                                            column.propertyPath,\r\n                                    ),\r\n                                )\r\n                                .from(metadata.target, metadata.targetName)\r\n                                .where(entityId)\r\n                                .withDeleted()\r\n                                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\r\n                                .getOne()) as any\r\n\r\n                        if (loadedReturningColumns) {\r\n                            this.queryRunner.manager.merge(\r\n                                metadata.target as any,\r\n                                entity,\r\n                                loadedReturningColumns,\r\n                            )\r\n                            updateResult.generatedMaps.push(\r\n                                loadedReturningColumns,\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n            }),\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Updates entities with a special columns after insertion query execution.\r\n     */\r\n    async insert(\r\n        insertResult: InsertResult,\r\n        entities: ObjectLiteral[],\r\n    ): Promise<void> {\r\n        const metadata = this.expressionMap.mainAlias!.metadata\r\n        let insertionColumns = metadata.getInsertionReturningColumns()\r\n\r\n        // to prevent extra select SQL execution for databases not supporting RETURNING\r\n        // in the case if we have generated column and it's value returned by underlying driver\r\n        // we remove this column from the insertionColumns list\r\n        const needToCheckGenerated =\r\n            this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\")\r\n        insertionColumns = insertionColumns.filter((column) => {\r\n            if (!column.isGenerated) return true\r\n            return needToCheckGenerated === true\r\n        })\r\n\r\n        const generatedMaps = entities.map((entity, entityIndex) => {\r\n            if (\r\n                this.queryRunner.connection.driver.options.type === \"oracle\" &&\r\n                Array.isArray(insertResult.raw) &&\r\n                this.expressionMap.extraReturningColumns.length > 0\r\n            ) {\r\n                insertResult.raw = insertResult.raw.reduce(\r\n                    (newRaw, rawItem, rawItemIndex) => {\r\n                        newRaw[\r\n                            this.expressionMap.extraReturningColumns[\r\n                                rawItemIndex\r\n                            ].databaseName\r\n                        ] = rawItem[0]\r\n                        return newRaw\r\n                    },\r\n                    {} as ObjectLiteral,\r\n                )\r\n            }\r\n            // get all values generated by a database for us\r\n            const result = Array.isArray(insertResult.raw)\r\n                ? insertResult.raw[entityIndex]\r\n                : insertResult.raw\r\n\r\n            const generatedMap =\r\n                this.queryRunner.connection.driver.createGeneratedMap(\r\n                    metadata,\r\n                    result,\r\n                    entityIndex,\r\n                    entities.length,\r\n                ) || {}\r\n\r\n            if (entityIndex in this.expressionMap.locallyGenerated) {\r\n                this.queryRunner.manager.merge(\r\n                    metadata.target as any,\r\n                    generatedMap,\r\n                    this.expressionMap.locallyGenerated[entityIndex],\r\n                )\r\n            }\r\n\r\n            this.queryRunner.manager.merge(\r\n                metadata.target as any,\r\n                entity,\r\n                generatedMap,\r\n            )\r\n\r\n            return generatedMap\r\n        })\r\n\r\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\r\n        // for other drivers we have to re-select this data from the database\r\n        if (\r\n            insertionColumns.length > 0 &&\r\n            !this.queryRunner.connection.driver.isReturningSqlSupported(\r\n                \"insert\",\r\n            )\r\n        ) {\r\n            const entityIds = entities.map((entity) => {\r\n                const entityId = metadata.getEntityIdMap(entity)!\r\n\r\n                // We have to check for an empty `entityId` - if we don't, the query against the database\r\n                // effectively drops the `where` clause entirely and the first record will be returned -\r\n                // not what we want at all.\r\n                if (!entityId)\r\n                    throw new TypeORMError(\r\n                        `Cannot update entity because entity id is not set in the entity.`,\r\n                    )\r\n\r\n                return entityId\r\n            })\r\n\r\n            // to select just inserted entities we need a criteria to select by.\r\n            // for newly inserted entities in drivers which do not support returning statement\r\n            // row identifier can only be an increment column\r\n            // (since its the only thing that can be generated by those databases)\r\n            // or (and) other primary key which is defined by a user and inserted value has it\r\n\r\n            const returningResult: any = await this.queryRunner.manager\r\n                .createQueryBuilder()\r\n                .select(\r\n                    metadata.primaryColumns.map(\r\n                        (column) =>\r\n                            metadata.targetName + \".\" + column.propertyPath,\r\n                    ),\r\n                )\r\n                .addSelect(\r\n                    insertionColumns.map(\r\n                        (column) =>\r\n                            metadata.targetName + \".\" + column.propertyPath,\r\n                    ),\r\n                )\r\n                .from(metadata.target, metadata.targetName)\r\n                .where(entityIds)\r\n                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\r\n                .getMany()\r\n\r\n            entities.forEach((entity, entityIndex) => {\r\n                this.queryRunner.manager.merge(\r\n                    metadata.target as any,\r\n                    generatedMaps[entityIndex],\r\n                    returningResult[entityIndex],\r\n                )\r\n\r\n                this.queryRunner.manager.merge(\r\n                    metadata.target as any,\r\n                    entity,\r\n                    returningResult[entityIndex],\r\n                )\r\n            })\r\n        }\r\n\r\n        entities.forEach((entity, entityIndex) => {\r\n            const entityId = metadata.getEntityIdMap(entity)!\r\n            insertResult.identifiers.push(entityId)\r\n            insertResult.generatedMaps.push(generatedMaps[entityIndex])\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Columns we need to be returned from the database when we update entity.\r\n     */\r\n    getUpdationReturningColumns(): ColumnMetadata[] {\r\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\r\n            (column) => {\r\n                return (\r\n                    column.asExpression !== undefined ||\r\n                    column.isUpdateDate ||\r\n                    column.isVersion\r\n                )\r\n            },\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Columns we need to be returned from the database when we soft delete and restore entity.\r\n     */\r\n    getSoftDeletionReturningColumns(): ColumnMetadata[] {\r\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\r\n            (column) => {\r\n                return (\r\n                    column.asExpression !== undefined ||\r\n                    column.isUpdateDate ||\r\n                    column.isVersion ||\r\n                    column.isDeleteDate\r\n                )\r\n            },\r\n        )\r\n    }\r\n}\r\n"],"sourceRoot":".."}